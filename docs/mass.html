<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>nhsmasslib.mass API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>nhsmasslib.mass</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#    Copyright 2019-2021 Rukhovich Gleb
#    Copyright 2022 Volikov Alexander &lt;ab.volikov@gmail.com&gt;
#
#    This file is part of nhsmasslib. 
#    Developed in Natural Humic System laboratory
#    Moscow State University (Head of lab - Perminova I.V.)
#
#    nhsmasslib is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    nhsmasslib is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with nhsmasslib.  If not, see &lt;http://www.gnu.org/licenses/&gt;.

from pathlib import Path
from typing import Sequence, Union, Optional, Mapping, Tuple
import copy

import matplotlib.pyplot as plt
from matplotlib.gridspec import GridSpec
import numpy as np
import pandas as pd
import seaborn as sns

from scipy.signal import savgol_filter, find_peaks
from scipy.interpolate import interp1d
import scipy.stats as st
from scipy import spatial
from scipy.optimize import curve_fit

from tqdm import tqdm

from .brutto import brutto_gen, elements_table, get_elements_masses

class SpectrumIsNotAssigned(Exception):
    pass

class MassSpectrum(object):
    &#34;&#34;&#34; 
    A class used to represent mass spectrum

    Attributes
    ----------
    table : pandas Datarame
        Optional. consist spectrum (mass and intensity of peaks) and all calculated parameters
        like brutto formulas, calculated mass, relative errorr
    elems : list
        Optional. Consist elements that used for mass spectrum treatment
        can be finded by class method find_elems()
    &#34;&#34;&#34;

    def __init__(
                self,
                table: pd.DataFrame = None,
                elems: Sequence[str] = None,
                ) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        Parameters
        ----------
        table : pandas Datarame
            Optional. Consist spectrum (mass and intensity of peaks) and all calculated 
            parameters like brutto formulas, calculated mass, relative errorr
        elems : list
            Optional. Consist elements that used for mass spectrum treatment
            can be finded by class method find_elems()
        &#34;&#34;&#34;

        self.features = [&#34;mass&#34;, &#34;calculated_mass&#34;, &#39;intensity&#39;, &#34;abs_error&#34;, &#34;rel_error&#34;]

        if table is not None:
            self.table = table
        else:
            self.table = pd.DataFrame(columns=[&#39;intensity&#39;, &#34;mass&#34;, &#34;brutto&#34;, &#34;calculated_mass&#34;, &#34;abs_error&#34;, &#34;rel_error&#34;])

        if elems is not None:
            self.elems = elems
        else:
            self.elems = self.find_elems()

    def find_elems(self) -&gt; Sequence[str]:
        &#34;&#34;&#34; 
        Find elems from mass spectrum table.

        Find elements in table columns. Used elems_mass_table with all elements and isotopes.
        For example, element &#39;C&#39; will be recognised as carbon 12C, element &#39;C_13&#34; as 13C

        Returns
        -------
        list of found elemets in columns label. For example: [&#39;C&#39;,&#39;H&#39;,&#39;O&#39;,&#39;N&#39;]
        &#34;&#34;&#34;

        main_elems = elements_table()[&#39;element&#39;].values
        all_elems = elements_table()[&#39;element_isotop&#39;].values

        elems = []
        for col in self.table.columns:
            if col in main_elems:
                elems.append(col)
            elif col in all_elems:
                elems.append(col)

        if len(elems) == 0:
            elems = None

        return elems

    def load(
        self,
        filename: Union[Path, str],
        mapper: Mapping[str, str] = None,
        ignore_columns: Sequence[str] = None,
        take_columns: Sequence[str] = None,
        take_only_mz: Sequence[str] = False,
        sep: str = &#34;,&#34;,
        intens_min: float =  None,
        intens_max: float = None,
        mass_min: float =  None,
        mass_max: float = None,
    ) -&gt; &#34;MassSpectrum&#34;:
        &#34;&#34;&#34;
        Load mass pectrum table to MassSpectrum object

        All parameters is optional except filename

        Parameters
        ----------
        filename: str
            path to mass spectrum table, absoulute or relative
        mapper: dict
            dictonary for recognize columns in mass spec file. 
            Example: {&#39;m/z&#39;:&#39;mass&#39;,&#39;I&#39;:&#39;intensity&#39;}
        ignore_columns: list of str
            list with names of columns that willn&#39;t loaded.
            if None load all columns.
            Example: [&#34;index&#34;, &#34;s/n&#34;]
        take_columns: list of str
            list with names of columns that only will be loaded.
            if None load all columns.
            Example: [&#34;mass&#34;, &#34;intensity&#34;, &#34;C&#34;, &#34;H&#34;, &#34;N&#34;, &#34;O&#34;]
        take_only_mz: bool
            load only mass and intesivity columns
        sep: str
            separator in mass spectrum table, \\t - for tab.
        intens_min: numeric
            bottom limit for intensivity.
            by default None and don&#39;t restrict by this.
            But for some spectrum it is necessary to cut noise.
        intens_max: numeric
            upper limit for intensivity.
            by default None and don&#39;t restrict by this
        mass_min: numeric
            bottom limit for m/z.
            by default None and don&#39;t restrict by this
        mass_max: numeric
            upper limit for m/z.
            by default None and don&#39;t restrict by this

        Return
        ------
        MassSpectrum object
        &#34;&#34;&#34;

        self.table = pd.read_csv(filename, sep=sep)
        if mapper:
            self.table = self.table.rename(columns=mapper)

        if take_columns:
            self.table = self.table.loc[:,take_columns]

        if ignore_columns:
            self.table = self.table.drop(columns=ignore_columns)

        if take_only_mz:
            self.table = self.table.loc[:,[&#39;mass&#39;,&#39;intensity&#39;]]

        if intens_min is not None:
            self.table = self.table.loc[self.table[&#39;intensity&#39;]&gt;intens_min]

        if intens_max is not None:
            self.table = self.table.loc[self.table[&#39;intensity&#39;]&lt;intens_max]

        if mass_min is not None:
            self.table = self.table.loc[self.table[&#39;mass&#39;]&gt;mass_min]

        if mass_max is not None:
            self.table = self.table.loc[self.table[&#39;mass&#39;]&lt;mass_max]

        self.elems = self.find_elems()

        if self.elems is not None:
            self._mark_assigned_by_brutto()

        self.table = self.table.reset_index(drop=True)

        return self

    def _mark_assigned_by_brutto(self) -&gt; None:
        &#34;&#34;&#34;Mark paeks in loaded mass list if they have brutto

        Return
        ------
        MassSpectrum object with assigned mark
        &#34;&#34;&#34;

        assign = []
        for i, row in self.table.iterrows():
            flag = False
            for el in self.elems:
                if row[el] &gt; 0:
                    flag = True
            assign.append(flag) 
        self.table[&#39;assign&#39;] = assign

    def save(self, filename: Union[Path, str], sep: str = &#34;,&#34;) -&gt; None:
        &#34;&#34;&#34;
        Saves to csv MassSpectrum
        
        Parameters
        ----------
        filename: str
            Path for saving mass spectrum table with calculation to csv file
        sep: str
            Optional. Separator in saved file. By default it is &#39;,&#39;        
        &#34;&#34;&#34;
        self.table.to_csv(filename, sep=sep, index=False)

    def assign(
            self,
            generated_bruttos_table: pd.DataFrame = None,
            rel_error: float = 0.5,
            sign: str =&#39;-&#39;
    ) -&gt; &#34;MassSpectrum&#34;:
        &#34;&#34;&#34;
        Finding the nearest mass in generated_bruttos_table
        
        Parameters
        -----------
        generated_bruttos_table: pandas DataFrame 
            Optional. Contain column &#39;mass&#39; and elements, 
            should be sorted by &#39;mass&#39;.
            Can be generated by function brutto_generator.brutto_gen(). 
            if &#39;None&#39; generate table with default elemnets and ranges
            C: 0-40, H 0-80, O 0-40, N 0-2
        rel_error: float
            Optional? default 0.5, permissible error in ppm for assign mass to brutto formulas
        sign: str
            Optional. Deafult &#39;-&#39;.
            Mode in which mass spectrum was gotten. 
            &#39;-&#39; for negative mode
            &#39;+&#39; for positive mode
            None for neutral

        Return
        ------
        MassSpectra object with assigned signals
        &#34;&#34;&#34;

        if generated_bruttos_table is None:
            generated_bruttos_table = brutto_gen()

        table = self.table.loc[:,[&#39;mass&#39;, &#39;intensity&#39;]].copy()

        masses = generated_bruttos_table[&#34;mass&#34;].values
        
        if sign == &#39;-&#39;:
            mass_shift = - 0.00054858 + 1.007825  # electron and hydrogen mass
        elif sign == &#39;+&#39;:
            mass_shift = 0.00054858  # electron mass
        else:
            mass_shift = 0

        elems = list(generated_bruttos_table.drop(columns=[&#34;mass&#34;]))
        bruttos = generated_bruttos_table[elems].values.tolist()

        res = []
        for index, row in table.iterrows():
            mass = row[&#34;mass&#34;] + mass_shift
            idx = np.searchsorted(masses, mass, side=&#39;left&#39;)
            if idx &gt; 0 and (idx == len(masses) or np.fabs(mass - masses[idx - 1]) &lt; np.fabs(mass - masses[idx])):
                idx -= 1

            if np.fabs(masses[idx] - mass) / mass * 1e6 &lt;= rel_error:
                res.append({**dict(zip(elems, bruttos[idx])), &#34;assign&#34;: True})
            else:
                res.append({&#34;assign&#34;: False})

        res = pd.DataFrame(res)

        return MassSpectrum(table.join(res), elems=elems)

    def filter_by_C13(
        self, 
        rel_error: float = 0.5,
        remove: bool = False,
    ) -&gt; &#39;MassSpectrum&#39;:
        &#34;&#34;&#34; 
        C13 isotope peak checking

        Parameters
        ----------
        rel_error: float
            Optional. Default 0.5.
            Allowable ppm error when checking c13 isotope peak
        remove: bool
            Optional, default False. 
            if True peakes without C13 isotopes peak will be dropped
        
        Return
        ------
        MassSpectra object with cleaned or checked mass-signals
        &#34;&#34;&#34;

        table = self.table.sort_values(by=&#39;mass&#39;).reset_index(drop=True)
        
        flags = np.zeros(table.shape[0], dtype=bool)
        masses = table[&#34;mass&#34;].values
        
        C13_C12 = 1.003355  # C13 - C12 mass difference

        
        for index, row in table.iterrows():
            mass = row[&#34;mass&#34;] + C13_C12
            error = mass * rel_error * 0.000001

            idx = np.searchsorted(masses, mass, side=&#39;left&#39;)
            
            if idx &gt; 0 and (idx == len(masses) or np.fabs(mass - masses[idx - 1]) &lt; np.fabs(mass - masses[idx])):
                idx -= 1
            
            if np.fabs(masses[idx] - mass)  &lt;= error:
                flags[index] = True
        
        table[&#39;C13_peak&#39;] = flags

        if remove:
            table = table.loc[(table[&#39;C13_peak&#39;] == True) &amp; (table[&#39;assign&#39;] == True)].reset_index(drop=True)

        return MassSpectrum(table)

    def calculate_brutto(self) -&gt; &#39;MassSpectrum&#39;:
        &#34;&#34;&#34;
        Calculate brutto formulas from assign table

        Return
        ------
        MassSpectrum object wit calculated bruttos
        &#34;&#34;&#34;

        table = copy.deepcopy(self.table)

        elems = self.find_elems()
        out = []
        for i, row in table.iterrows():
            s = &#39;&#39;
            for el in elems:
                if row[el] == 1:
                    s = s + f&#39;{el}&#39;
                elif row[el] &gt; 0:
                    s = s + f&#39;{el}{int(row[el])}&#39;
            out.append(s)
        
        table[&#39;brutto&#39;] = out

        return MassSpectrum(table)

    def copy(self) -&gt; &#39;MassSpectrum&#39;:
        &#34;&#34;&#34;
        Deepcopy of self MassSpectrum object

        Return
        ------
        Deepcopy of self MassSpectrum object
        &#34;&#34;&#34;
        return copy.deepcopy(MassSpectrum(self.table))

    def calculate_error(self, sign: str =&#39;-&#39;) -&gt; &#34;MassSpectrum&#34;:
        &#34;&#34;&#34;
        Calculate relative and absolute error of assigned peaks

        Parameters
        ----------
        sign: str
            Optional. Default &#39;-&#39;. 
            Mode in which mass spectrum was gotten. 
            &#39;-&#39; for negative mode
            &#39;+&#39; for positive mode
            None for neutral
        
        Return
        ------
        MassSpectrum object wit calculated error
        &#34;&#34;&#34;
        if &#34;calculated_mass&#34; not in self.table:
            table = self.calculate_mass().table
        else:
            table = copy.deepcopy(self.table)

        if sign == &#39;-&#39;:
            table[&#34;abs_error&#34;] = table[&#34;mass&#34;] - table[&#34;calculated_mass&#34;] + (- 0.00054858 + 1.007825) #-electron + proton
        elif sign == &#39;+&#39;:
            table[&#34;abs_error&#34;] = table[&#34;mass&#34;] - table[&#34;calculated_mass&#34;] + 0.00054858 #+electron
        else:
            table[&#34;abs_error&#34;] = table[&#34;mass&#34;] - table[&#34;calculated_mass&#34;]
        
        table[&#34;rel_error&#34;] = table[&#34;abs_error&#34;] / table[&#34;mass&#34;] * 1e6

        return MassSpectrum(table)

    def show_error(self) -&gt; None:
        &#34;&#34;&#34;
        Plot relative error of assigned brutto formulas vs mass
        &#34;&#34;&#34;

        if &#34;rel_error&#34; not in self.table:
            self = self.calculate_error()      

        fig, ax = plt.subplots(figsize=(4, 4), dpi=75)
        ax.scatter(self.table[&#39;mass&#39;], self.table[&#39;rel_error&#39;], s=0.1)
        ax.set_xlabel(&#39;m/z, Da&#39;)
        ax.set_ylabel(&#39;error, ppm&#39;)

    def calculate_mass(self) -&gt; &#34;MassSpectrum&#34;:
        &#34;&#34;&#34;
        Calculate mass from assigned brutto formulas

        Return
        ------
        MassSpectrum object with calculated mass
        &#34;&#34;&#34;

        if &#34;assign&#34; not in self.table:
            raise SpectrumIsNotAssigned()
        
        table = copy.deepcopy(self.table)
        self.elems = self.find_elems()
        
        table = table.loc[:,self.elems]
        
        masses = get_elements_masses(self.elems)

        self.table[&#34;calculated_mass&#34;] = table.multiply(masses).sum(axis=1)
        self.table[&#34;calculated_mass&#34;] = np.round(self.table[&#34;calculated_mass&#34;], 6)
        self.table.loc[self.table[&#34;calculated_mass&#34;] == 0, &#34;calculated_mass&#34;] = np.NaN

        return MassSpectrum(self.table)
    
    def __repr__(self) -&gt; str:
        &#34;&#34;&#34;
        Representation of MassSpectrum object.

        Return
        ------
        the string representation of MassSpectrum object
        &#34;&#34;&#34;

        columns = [column for column in self.features if column in self.table]
        return self.table[columns].__repr__()

    def __str__(self) -&gt; str:
        &#34;&#34;&#34;
        Representation of MassSpectrum object.

        Return
        ------
        the string representation of MassSpectrum object
        &#34;&#34;&#34;
        columns = [column for column in self.features if column in self.table]
        return self.table[columns].__str__()

    def __or__(self: &#34;MassSpectrum&#34;, other: &#34;MassSpectrum&#34;) -&gt; &#34;MassSpectrum&#34;:
        &#34;&#34;&#34;
        Logic function or for two MassSpectrum object

        Work by calculated mass from brutto formulas

        Return
        ------
        MassSpectrum object contain all assigned brutto formulas from two spectrum
        &#34;&#34;&#34;
        
        if &#34;calculated_mass&#34; not in self.table:
            e = copy.deepcopy(self.calculate_mass())
        else:
            e = copy.deepcopy(self)
        if &#34;calculated_mass&#34; not in other.table:
            s = copy.deepcopy(other.calculate_mass())
        else:
            s = copy.deepcopy(other)

        a = e.table.dropna()
        b = s.table.dropna()
        
        a = a.append(b, ignore_index=True)
        a = a.drop_duplicates(subset=[&#39;calculated_mass&#39;])

        return MassSpectrum(a)

    def __xor__(self: &#34;MassSpectrum&#34;, other: &#34;MassSpectrum&#34;) -&gt; &#34;MassSpectrum&#34;:
        &#34;&#34;&#34;
        Logic function xor for two MassSpectrum object

        Work by calculated mass from brutto formulas

        Return
        ------
        MassSpectrum object contain xor assigned brutto formulas from two spectrum
        &#34;&#34;&#34;

        other2 = copy.deepcopy(self)
        sub1 = self.__sub__(other)
        sub2 = other.__sub__(other2)
        
        return sub1.__or__(sub2)

    def __and__(self: &#34;MassSpectrum&#34;, other: &#34;MassSpectrum&#34;) -&gt; &#34;MassSpectrum&#34;:
        &#34;&#34;&#34;
        Logic function and for two MassSpectrum object

        Work by calculated mass from brutto formulas

        Return
        ------
        MassSpectrum object contain common assigned brutto formulas from two spectrum
        &#34;&#34;&#34;

        if &#34;calculated_mass&#34; not in self.table:
            e = copy.deepcopy(self.calculate_mass())
        else:
            e = copy.deepcopy(self)
        if &#34;calculated_mass&#34; not in other.table:
            s = copy.deepcopy(other.calculate_mass())
        else:
            s = copy.deepcopy(other)

        a = e.table[&#39;calculated_mass&#39;].dropna().values
        b = s.table[&#39;calculated_mass&#39;].dropna().values
        
        operate = set(a) &amp; set(b)

        mark = []
        res = copy.deepcopy(self.table)
        for i, row in res.iterrows():
            if row[&#39;calculated_mass&#39;] in operate:
                mark.append(row[&#39;calculated_mass&#39;])
            else:
                mark.append(np.NaN)
        res[&#39;calculated_mass&#39;] = mark
        res = res.dropna()

        return MassSpectrum(res)

    def __add__(self: &#34;MassSpectrum&#34;, other: &#34;MassSpectrum&#34;) -&gt; &#34;MassSpectrum&#34;:
        &#34;&#34;&#34;
        Logic function or for two MassSpectrum object

        Work by calculated mass from brutto formulas

        Return
        ------
        MassSpectrum object contain all assigned brutto formulas from two spectrum
        &#34;&#34;&#34;
        return self.__or__(other)

    def __sub__(self, other):
        &#34;&#34;&#34;
        Logic function substraction for two MassSpectrum object

        Work by calculated mass from brutto formulas

        Return
        ------
        MassSpectrum object contain substraction assigned brutto formulas from two spectrum
        &#34;&#34;&#34;
        
        if &#34;calculated_mass&#34; not in self.table:
            e = copy.deepcopy(self.calculate_mass())
        else:
            e = copy.deepcopy(self)
        if &#34;calculated_mass&#34; not in other.table:
            s = copy.deepcopy(other.calculate_mass())
        else:
            s = copy.deepcopy(other)

        a = e.table[&#39;calculated_mass&#39;].dropna().values
        b = s.table[&#39;calculated_mass&#39;].dropna().values
        
        operate = set(a) - set(b)

        mark = []
        res = copy.deepcopy(self.table)
        for i, row in res.iterrows():
            if row[&#39;calculated_mass&#39;] in operate:
                mark.append(row[&#39;calculated_mass&#39;])
            else:
                mark.append(np.NaN)
        res[&#39;calculated_mass&#39;] = mark
        res = res.dropna()

        return MassSpectrum(res)

    def intens_sub(self, other:&#34;MassSpectrum&#34;) -&gt; &#34;MassSpectrum&#34;:
        &#34;&#34;&#34;
        Calculate substruction by intensivity

        Parameters
        ----------
        other: MassSpectrum object
            other mass-scpectrum

        Return
        ------
        MassSpectrum object contain only that peak
        that higher than in other. And intensity of this peaks
        is substraction of self and other.
        &#34;&#34;&#34;
        #find common masses
        m = self &amp; other
        msc = m.table[&#39;calculated_mass&#39;].values

        #extract table with common masses
        massE = self.table[&#39;calculated_mass&#39;].values
        rE = self.table[np.isin(massE, msc)]
        massL = other.table[&#39;calculated_mass&#39;].values
        rL = other.table[np.isin(massL, msc)]

        #substract intensity each others
        rE = rE.copy()
        rE[&#39;intensity&#39;] = rE[&#39;intensity&#39;] - rL[&#39;intensity&#39;]
        rE = rE.loc[rE[&#39;intensity&#39;] &gt; 0]
        
        #and add only own molecules
        return (self - other) + MassSpectrum(rE)  

    def __len__(self) -&gt; int:
        &#34;&#34;&#34;
        Length of Mass-Spectrum table

        Return
        ------
        int - length of Mass-Spectrum table
        &#34;&#34;&#34;
        return len(self.table)
    
    def __getitem__(self, item: Union[str, Sequence[str]]) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        Get items or slice from spec

        Return
        ------
        Pandas Dataframe or Series slices
        &#34;&#34;&#34;

        return self.table[item]

    def drop_unassigned(self) -&gt; &#34;MassSpectrum&#34;:
        &#34;&#34;&#34;
        Drop unassigned mass from Mass Spectrum table

        Return
        ------
        MassSpectrum object that contain only assigned by brutto formulas peaks

        Caution
        -------
        Danger of lose data - with these operation we exclude data that can be usefull
        &#34;&#34;&#34;

        if &#34;assign&#34; not in self.table:
            raise SpectrumIsNotAssigned()

        return MassSpectrum(self.table.loc[self.table[&#34;assign&#34;] == True].reset_index(drop=True))

    def calculate_simmilarity(self, other:&#34;MassSpectrum&#34;, mode:str=&#39;cosine&#39;) -&gt; float:
        &#34;&#34;&#34;
        Calculate Simmilarity

        Parameters
        ----------
        other: MassSpectrum object
            second MaasSpectrum object with that calc simmilarity
        mode: str
            Optionaly. Default cosine. 
            one of the similarity functions
            Mode can be: &#34;tanimoto&#34;, &#34;jaccard&#34;, &#34;cosine&#34;

        Return
        ------
        float Simmilarity index
        &#34;&#34;&#34;

        if &#39;calculated_mass&#39; not in self.table:
            self = self.calculate_mass()
        if &#39;calculated_mass&#39; not in other.table:
            other = other.calculate_mass()

        a = self.table[&#39;calculated_mass&#39;].dropna().values
        b = other.table[&#39;calculated_mass&#39;].dropna().values
        c = np.union1d(a, b)

        A = np.zeros(len(c), dtype=bool)
        B = np.zeros(len(c), dtype=bool)
        for i, el in enumerate(c):
            if el in a:
                A[i] = True
            if el in b:
                B[i] = True

        if mode == &#34;jaccard&#34;:
            return 1 - spatial.distance.jaccard(A, B)
        elif mode == &#34;tanimoto&#34;:
            return 1 - spatial.distance.rogerstanimoto(A, B)
        elif mode == &#39;cosine&#39;:
            return 1 - spatial.distance.cosine(A, B)
        else:
            raise Exception(f&#34;There is no such mode: {mode}&#34;)

    def calculate_cram(self) -&gt; &#34;MassSpectrum&#34;:
        &#34;&#34;&#34;
        Calculate if include into CRAM
        (carboxylic-rich alicyclic molecules)

        Return
        ------
        MassSpectrun object with check CRAM (bool)

        Reference
        ---------
        Hertkorn, N. et al. Characterization of a major 
        refractory component of marine dissolved organic matter.
        Geochimica et. Cosmochimica Acta 70, 2990-3010 (2006)
        &#34;&#34;&#34;
        spec = self.copy()
        if &#34;DBE&#34; not in spec.table:
            spec = spec.calculate_dbe()

        def check(row):
            if row[&#39;DBE&#39;]/row[&#39;C&#39;] &lt; 0.3 or row[&#39;DBE&#39;]/row[&#39;C&#39;] &gt; 0.68:
                return False
            if row[&#39;DBE&#39;]/row[&#39;H&#39;] &lt; 0.2 or row[&#39;DBE&#39;]/row[&#39;H&#39;] &gt; 0.95:
                return False
            if row[&#39;O&#39;] == 0:
                False
            elif row[&#39;DBE&#39;]/row[&#39;O&#39;] &lt; 0.77 or row[&#39;DBE&#39;]/row[&#39;O&#39;] &gt; 1.75:
                return False
            return True

        spec.table[&#39;CRAM&#39;] = spec.table.apply(check, axis=1)

        return spec

    def get_cram_value(self) -&gt; int:
        &#34;&#34;&#34;
        Calculate percent of CRAM molecules
        (carboxylic-rich alicyclic molecules)

        Return
        ------
        int. percent of CRAM molecules in mass-spec
        weight by intensity
        &#34;&#34;&#34;
        spec = self.copy()
        if &#34;CRAM&#34; not in spec.table:
            spec = spec.calculate_cram().drop_unassigned()

        value = spec.table.loc[spec.table[&#39;CRAM&#39;] == True, &#39;intensity&#39;].sum()/spec.table[&#39;intensity&#39;].sum()
        return int(value*100)

    def calculate_ai(self) -&gt; &#39;MassSpectrum&#39;:
        &#34;&#34;&#34;
        Calculate AI

        Return
        ------
        MassSpectrum object with calculated AI
        &#34;&#34;&#34;
        table = self.calculate_cai().calculate_dbe_ai().table
        table[&#34;AI&#34;] = table[&#34;DBE_AI&#34;] / table[&#34;CAI&#34;]

        return MassSpectrum(table)

    def calculate_cai(self) -&gt; &#39;MassSpectrum&#39;:
        &#34;&#34;&#34;
        Calculate CAI

        Return
        ------
        MassSpectrum object with calculated CAI
        &#34;&#34;&#34;
        
        if &#34;assign&#34; not in self.table:
            raise SpectrumIsNotAssigned()

        table = copy.deepcopy(self.table)

        # very careful
        # anyway it&#39;s necessary to have at least column with C?
        for element in &#34;CONSP&#34;:
            if element not in table:
                table[element] = 0

        self.table[&#39;CAI&#39;] = table[&#34;C&#34;] - table[&#34;O&#34;] - table[&#34;N&#34;] - table[&#34;S&#34;] - table[&#34;P&#34;]

        return self

    def calculate_dbe_ai(self) -&gt; &#39;MassSpectrum&#39;:
        &#34;&#34;&#34;
        Calculate DBE

        Return
        ------
        MassSpectrum object with calculated DBE
        &#34;&#34;&#34;
        if &#34;assign&#34; not in self.table:
            raise SpectrumIsNotAssigned()

        table = copy.deepcopy(self.table)

        for element in &#34;CHONPS&#34;:
            if element not in table:
                table[element] = 0

        self.table[&#39;DBE_AI&#39;] = 1.0 + table[&#34;C&#34;] - table[&#34;O&#34;] - table[&#34;S&#34;] - 0.5 * (table[&#34;H&#34;] + table[&#39;N&#39;] + table[&#34;P&#34;])

        return self

    def calculate_dbe(self) -&gt; &#39;MassSpectrum&#39;:
        &#34;&#34;&#34;
        Calculate DBE

        Return
        ------
        MassSpectrum object with calculated DBE
        &#34;&#34;&#34;
        if &#34;assign&#34; not in self.table:
            raise SpectrumIsNotAssigned()

        table = copy.deepcopy(self.table)

        for element in &#34;CHON&#34;:
            if element not in table:
                table[element] = 0

        self.table[&#39;DBE&#39;] = 1.0 + table[&#34;C&#34;] - 0.5 * (table[&#34;H&#34;] - table[&#39;N&#39;])

        return self

    def normalize(self) -&gt; &#39;MassSpectrum&#39;:
        &#34;&#34;&#34;
        Intensity normalize by max intensity
        
        Return
        ------
        Intensity normalized by max intensity MassSpectrum instance
        &#34;&#34;&#34;
        table = self.table.copy()
        table[&#39;intensity&#39;] /= table[&#39;intensity&#39;].max()
        return MassSpectrum(table)

    def head(self, num:int = None) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        Show head of mass spec table

        Parameters
        ----------
        num: int
            Optional. number of head string

        Return
        ------
        Pandas Dataframe head of MassSpec table
        &#34;&#34;&#34;
        if num is None:
            return self.table.head()
        else:
            return self.table.head(num)

    def tail(self, num:int = None) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        Show tail of mass spec table

        Parameters
        ----------
        num: int
            Optional. number of tail string

        Return
        ------
        Pandas Dataframe tail of MassSpec table
        &#34;&#34;&#34;
        if num is None:
            return self.table.tail()
        else:
            return self.table.tail(num)

    def draw(self,
        xlim: Tuple[Optional[float], Optional[float]] = (None, None),
        ylim: Tuple[Optional[float], Optional[float]] = (None, None),
        color: str = &#39;black&#39;,
        ax: plt.axes = None,
        ) -&gt; None:
        &#34;&#34;&#34;
        Draw mass spectrum

        All parameters is optional

        Parameters
        ----------
        xlim: Tuple (float, float)
            restrict for mass
        ylim: Tuple (float, float)
            restrict for intensity
        color: str
            color of draw
        ax: matplotlyp axes object
            send here ax to plot in your own condition
        &#34;&#34;&#34;

        df = self.table.sort_values(by=&#34;mass&#34;)

        mass = df.mass.values
        if xlim[0] is None:
            xlim = (mass.min(), xlim[1])
        if xlim[1] is None:
            xlim = (xlim[0], mass.max())

        intensity = df[&#39;intensity&#39;].values
        # filter first intensity and only after mass (because we will lose the information)
        intensity = intensity[(xlim[0] &lt;= mass) &amp; (mass &lt;= xlim[1])]
        mass = mass[(xlim[0] &lt;= mass) &amp; (mass &lt;= xlim[1])]

        # bas solution, probably it&#39;s needed to rewrite this piece
        M = np.zeros((len(mass), 3))
        M[:, 0] = mass
        M[:, 1] = mass
        M[:, 2] = mass
        M = M.reshape(-1)

        I = np.zeros((len(intensity), 3))
        I[:, 1] = intensity
        I = I.reshape(-1)

        if ax is None:
            fig, ax = plt.subplots(figsize=(4,4), dpi=75)
    
        ax.plot(M, I, color=color, linewidth=0.2)
        ax.plot([xlim[0], xlim[1]], [0, 0], color=color, linewidth=0.2)
        ax.set_xlim(xlim)
        ax.set_ylim(ylim)
        ax.set_xlabel(&#39;m/z, Da&#39;)
        ax.set_ylabel(&#39;Intensity&#39;)
        ax.set_title(f&#39;{len(self.table)} peaks&#39;)

        return

    def recallibrate(self, error_table: &#34;ErrorTable&#34; = None, how = &#39;assign&#39;) -&gt; &#34;MassSpectrum&#34;:
        &#39;&#39;&#39;
        Recallibrate data by error-table

        Parameters
        ----------
        error_table: ErrorTable object
            Optional. If None - calculate for self. 
            ErrorTable object contain table error in ppm for mass, default 100 string            

        how: str
            Optional. Default &#39;assign&#39;.
            If error_table is None we can choose how to recalculate.
            &#39;assign&#39; - by assign error, default.
            &#39;mdm&#39; - by calculation mass-difference map.
            filename - path to etalon spectrum, treated and saved by masslib

        Returns
        -------
        MassSpectrum object with recallibrated mass
        &#39;&#39;&#39;
        if error_table is None:
            if how == &#39;assign&#39;:
                if &#34;assign&#34; not in self.table:
                    raise SpectrumIsNotAssigned()
                error_table = ErrorTable().assign_error(self).zeroshift(self)
            elif how == &#39;mdm&#39;:
                error_table = ErrorTable().massdiff_error(self)
            else:
                etalon = MassSpectrum().load(filename=how)
                error_table = ErrorTable().etalon_error(spec=self, etalon=etalon)

        err = copy.deepcopy(error_table.table)
        data = self.table.reset_index(drop=True)
        wide = len(err)

        data[&#39;old_mass&#39;] = data[&#39;mass&#39;]

        min_mass = err[&#39;mass&#39;].min()
        max_mass = err[&#39;mass&#39;].max()
        a = np.linspace(min_mass, max_mass, wide+1)

        for i in range(wide):
            for ind in data.loc[(data[&#39;mass&#39;]&gt;a[i]) &amp; (data[&#39;mass&#39;]&lt;a[i+1])].index:
                mass = data.loc[ind, &#39;mass&#39;]
                e = mass * err.loc[i, &#39;ppm&#39;] / 1000000
                data.loc[ind, &#39;mass&#39;] = data.loc[ind, &#39;mass&#39;] + e
                
        return MassSpectrum(data)

    def assign_by_tmds (
        self, 
        tmds_spec: &#34;Tmds&#34; = None, 
        abs_error: float = 0.001,
        p = 0.2,
        max_num: int = None,
        C13_filter: bool = True
        ) -&gt; &#34;MassSpectrum&#34;:
        &#39;&#39;&#39;
        Assigne brutto formulas by TMDS

        Parameters
        ----------
        tmds_spec: Tmds object
            Optional. if None generate tmds spectr with default parameters
            Tmds object, include table with most probability mass difference
        abs_error: float
            Optional, default 0.001. Error for assign peaks by massdif
        p: float
            Optional. Default 0.2. 
            Relative probability coefficient for treshold tmds spectrum
        max_num: int
            Optional. Max mass diff numbers
        C13_filter: bool
            Use only peaks with C13 isotope peak for generate tmds

        Return
        ------
        MassSpectrum object new assign brutto formulas
        &#39;&#39;&#39;
        if &#34;assign&#34; not in self.table:
            raise SpectrumIsNotAssigned()

        if tmds_spec is None:
            tmds_spec = Tmds().calc(self, p=p, C13_filter=C13_filter) #by varifiy p-value we can choose how much mass-diff we will take
            tmds_spec = tmds_spec.assign(max_num=max_num)
            tmds_spec = tmds_spec.calculate_mass()

        tmds = tmds_spec.table.sort_values(by=&#39;probability&#39;, ascending=False).reset_index(drop=True)
        tmds = tmds.loc[tmds[&#39;probability&#39;] &gt; p]
        elem = tmds_spec.elems

        spec = copy.deepcopy(self)
        
        assign_false = copy.deepcopy(spec.table.loc[spec.table[&#39;assign&#39;] == False]).reset_index(drop=True)
        assign_true = copy.deepcopy(spec.table.loc[spec.table[&#39;assign&#39;] == True]).reset_index(drop=True)
        masses = assign_true[&#39;mass&#39;].values
        mass_dif_num = len(tmds)

        for i, row_tmds in tqdm(tmds.iterrows(), total=mass_dif_num):

            mass_shift = - row_tmds[&#39;calculated_mass&#39;]
            
            for index, row in assign_false.iterrows():
                if row[&#39;assign&#39;] == True:
                    continue
                     
                mass = row[&#34;mass&#34;] + mass_shift
                idx = np.searchsorted(masses, mass, side=&#39;left&#39;)
                if idx &gt; 0 and (idx == len(masses) or np.fabs(mass - masses[idx - 1]) &lt; np.fabs(mass - masses[idx])):
                    idx -= 1

                if np.fabs(masses[idx] - mass) &lt;= abs_error:
                    assign_false.loc[index,&#39;assign&#39;] = True
                    for el in elem:
                        assign_false.loc[index,el] = row_tmds[el] + assign_true.loc[idx,el]

        assign_true = assign_true.append(assign_false, ignore_index=True).sort_values(by=&#39;mass&#39;).reset_index(drop=True)

        out = MassSpectrum(assign_true)
        out = out.calculate_error()
        
        out_false = out.table.loc[out.table[&#39;assign&#39;] == False]
        out_true = out.table.loc[out.table[&#39;assign&#39;] == True].drop_duplicates(subset=&#34;calculated_mass&#34;)

        out2 = pd.merge(out_true, out_false, how=&#39;outer&#39;).reset_index(drop=True).sort_values(by=&#39;mass&#39;).reset_index(drop=True)
        
        return MassSpectrum(out2)

    def calculate_DBEvsO(self, ax=None, olim=None, **kwargs) -&gt; None:
        &#34;&#34;&#34;
        DBE by nO
        
        Paramters
        ---------
        ax: matplotlib axes
            ax fo outer plot. Default None
        olim: tuple of two int
            limit for nO. Deafult None
        **kwargs: dict
            dict for additional condition to scatter method 

        References
        ----------
        Bae, E., Yeo, I. J., Jeong, B., Shin, Y., Shin, K. H., &amp; Kim, S. (2011). 
        Study of double bond equivalents and the numbers of carbon and oxygen 
        atom distribution of dissolved organic matter with negative-mode FT-ICR MS.
        Analytical chemistry, 83(11), 4193-4199.
        
        &#34;&#34;&#34;

        spec = self.copy().calculate_dbe().drop_unassigned()
        if olim is None:
            no = list(range(5, int(spec.table[&#39;O&#39;].max())-4))
        else:
            no = list(range(olim[0],olim[1]))

        dbe_o = []
        
        for i in no:
            dbes = spec.table.loc[spec.table[&#39;O&#39;] == i, &#39;DBE&#39;]
            intens = spec.table.loc[spec.table[&#39;O&#39;] == i, &#39;intensity&#39;]
            dbe_o.append((dbes*intens).sum()/intens.sum())
    
        def linear(x, a, b):
            return a*x + b

        x = np.array(no)
        y = np.array(dbe_o)

        popt, pcov = curve_fit(linear, x, y)
        residuals = y- linear(x, *popt)
        ss_res = np.sum(residuals**2)
        ss_tot = np.sum((y-np.mean(y))**2)
        r_squared = 1 - (ss_res / ss_tot)

        if ax is None:
            fig,ax = plt.subplots(figsize=(3,3), dpi=100)
        
        ax.scatter(x, y, **kwargs)
        ax.plot(x, linear(x, *popt), label=f&#39;y={round(popt[0],2)}x + {round(popt[1],1)} R2={round(r_squared, 4)}&#39;, **kwargs)
        ax.set_xlim(4)
        ax.set_ylim(5)
        ax.set_xlabel(&#39;number of oxygen&#39;)
        ax.set_ylabel(&#39;DBE average&#39;)
        ax.legend()


class CanNotCreateVanKrevelen(Exception):
    pass


class VanKrevelen(object):
    &#34;&#34;&#34;
    A class used to plot Van-Krevelen diagramm

    Attributes
    ----------
    table : pandas Datarame or MassSpectrum object
        consist spectrum (mass and intensity of peaks) and all calculated parameters.
        Must contain elements &#39;C&#39;, &#39;H&#39;, &#39;N&#39;
    &#34;&#34;&#34;

    def __init__(self, table: Optional[Union[pd.DataFrame, &#39;MassSpectrum&#39;]] = None) -&gt; None:
        &#34;&#34;&#34;
        Init and calculate C/H, O/C relatives

        Parameters
        ----------
        table : pandas Datarame or MassSpectrum object
            consist spectrum (mass and intensity of peaks) and all calculated parameters
            Must contain elements &#39;C&#39;, &#39;H&#39;, &#39;N&#39;
        &#34;&#34;&#34;
        if table is None:
            return

        if isinstance(table, MassSpectrum):
            table = table.table

        if not ((&#34;C&#34; in table and &#34;H&#34; in table and &#34;O&#34; in table) or (&#34;O/C&#34; in table or &#34;H/C&#34; in table)):
            raise CanNotCreateVanKrevelen()

        table = table.loc[table[&#34;C&#34;] &gt; 0]

        self.table = table
        if &#34;O/C&#34; not in self.table:
            self.table[&#34;O/C&#34;] = self.table[&#34;O&#34;] / self.table[&#34;C&#34;]

        if &#34;H/C&#34; not in self.table:
            self.table[&#34;H/C&#34;] = self.table[&#34;H&#34;] / self.table[&#34;C&#34;]

    def draw_density(
        self, 
        cmap:str =&#34;Blues&#34;, 
        ax: plt.axes = None, 
        shade: bool = True
        ) -&gt; None:
        &#34;&#34;&#34;
        Draw Van-Krevelen density

        All parameters is optional

        Parameters
        ----------
        cmap: str
            color map
        ax: matplotlib ax
            external ax
        shade: bool
            show shade
        &#34;&#34;&#34;
        sns.kdeplot(self.table[&#34;O/C&#34;], self.table[&#34;H/C&#34;], ax=ax, cmap=cmap, shade=shade)

    def draw_scatter(
        self, 
        ax:plt.axes = None, 
        volumes:float = None,
        color:str = &#39;blue&#39;,
        nitrogen:bool = False,
        sulphur:bool = False,
        alpha:float = 0.3, 
        mark_elem:str = None, 
        **kwargs) -&gt; None:
        &#34;&#34;&#34;
        plot Van-Krevelen diagramm

        All parameters is optional.

        Parameters
        ----------
        ax: Matplotlyb axes object
            send here ax if you want plot special graph
        volumes: float
            size of dot at diagram.
            By default calc by median intensity of spectrum
        color: str
            color of VK. Default blue
        nitrogen: bool
            mark nitrogen in brutto-formulas as orange
        sulphur: bool
            mark sulphur in brutto-formulas as green for CHOS and red for CHONS
        alpha: float
            transparency of dot at the scatter from 0 to 1
        mark_elem: str
            mark element in brutto-formulas by pink color
        **kwargs: dict
            dict for additional condition to scatter method        
        &#34;&#34;&#34;
        
        if ax is None:
            fig, ax = plt.subplots(figsize=(4, 4), dpi=75)
        else:
            ax=ax
        
        if volumes is None:
            self.table[&#39;volume&#39;] = self.table[&#39;intensity&#39;] / self.table[&#39;intensity&#39;].median()
        else:
            self.table[&#39;volume&#39;] = volumes

        self.table[&#39;color&#39;] = color

        if mark_elem is not None:
            
            self.table.loc[self.table[mark_elem] &gt; 0, &#39;color&#39;] = &#39;purple&#39;

        if nitrogen and &#39;N&#39; in self.table.columns:
            self.table.loc[(self.table[&#39;C&#39;] &gt; 0) &amp; (self.table[&#39;H&#39;] &gt; 0) &amp;(self.table[&#39;O&#39;] &gt; 0) &amp; (self.table[&#39;N&#39;] &gt; 0), &#39;color&#39;] = &#39;orange&#39;

        if sulphur and &#39;S&#39; in self.table.columns:
            self.table.loc[(self.table[&#39;C&#39;] &gt; 0) &amp; (self.table[&#39;H&#39;] &gt; 0) &amp;(self.table[&#39;O&#39;] &gt; 0) &amp; (self.table[&#39;N&#39;] &lt; 1) &amp; (self.table[&#39;S&#39;] &gt; 0), &#39;color&#39;] = &#39;green&#39;
            self.table.loc[(self.table[&#39;C&#39;] &gt; 0) &amp; (self.table[&#39;H&#39;] &gt; 0) &amp;(self.table[&#39;O&#39;] &gt; 0) &amp; (self.table[&#39;N&#39;] &gt; 0) &amp; (self.table[&#39;S&#39;] &gt; 0), &#39;color&#39;] = &#39;red&#39;
        
        if mark_elem is not None:
            ax.scatter(self.table.loc[self.table[mark_elem] &gt; 0, &#39;O/C&#39;], 
                        self.table.loc[self.table[mark_elem] &gt; 0, &#39;H/C&#39;],
                        s=self.table.loc[self.table[mark_elem] &gt; 0, &#39;volume&#39;], 
                        c=&#39;red&#39;, 
                        alpha=alpha, 
                        **kwargs)
        else:
            ax.scatter(self.table[&#34;O/C&#34;], self.table[&#34;H/C&#34;], s=self.table[&#39;volume&#39;], c=self.table[&#39;color&#39;], alpha=alpha, **kwargs)
        ax.set_xlabel(&#34;O/C&#34;)
        ax.set_ylabel(&#34;H/C&#34;)
        ax.yaxis.set_ticks(np.arange(0, 2.2, 0.4))
        ax.xaxis.set_ticks(np.arange(0, 1.1, 0.2))
        ax.set_xlim(0, 1)
        ax.set_ylim(0, 2.2)
        
        num_formules = self.table[&#39;C&#39;].count()
        ax.set_title(f&#39;{num_formules} formulas&#39;, size=10)

    def _plot_heatmap(self, df:pd.DataFrame) -&gt; None:
        &#34;&#34;&#34;Plot density map for VK

        Parameters
        ----------
        df: pd.DataFrame
            dataframe with density        
        &#34;&#34;&#34;

        fig, ax = plt.subplots(figsize=(4, 4), dpi=75)
        sns.heatmap(df.round(4),cmap=&#39;coolwarm&#39;,annot=True, linewidths=.5, ax=ax)
        bottom, top = ax.get_ylim()
        plt.yticks(rotation=0)
        plt.xticks(rotation=90) 
        ax.set_ylim(bottom + 0.5, top - 0.5)

        ax.set_xlabel(&#39;O/C&#39;)
        ax.set_ylabel(&#39;H/C&#39;)

    def squares(self, draw:bool = True) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        Calculate density  in VK divided into 20 squares

        Parameters:
        draw: bool
            Optional, default True. Draw heatmap for squares

        Return
        ------
        Pandas Dataframe with calculated square density
        &#34;&#34;&#34;

        d_table = []
        sq = []
        table = copy.deepcopy(self.table)
        total_i = len(table)
        for y in [ (1.8, 2.2), (1.4, 1.8), (1, 1.4), (0.6, 1), (0, 0.6)]:
            hc = []
            for x in  [(0, 0.25), (0.25, 0.5), (0.5, 0.75), (0.75, 1)]:
                temp = copy.deepcopy(self)
                temp.table = temp.table.loc[(temp.table[&#39;O/C&#39;] &gt;= x[0]) &amp; (temp.table[&#39;O/C&#39;] &lt; x[1]) &amp; (temp.table[&#39;H/C&#39;] &gt;= y[0]) &amp; (temp.table[&#39;H/C&#39;] &lt; y[1])]
                temp_i = len(temp.table)
                hc.append(temp_i/total_i)
                sq.append(temp_i/total_i)
            d_table.append(hc)
        out = pd.DataFrame(data = d_table, columns=[&#39;0-0.25&#39;, &#39;0,25-0.5&#39;,&#39;0.5-0.75&#39;,&#39;0.75-1&#39;], index=[&#39;1.8-2.2&#39;, &#39;1.4-1.8&#39;, &#39;1-1.4&#39;, &#39;0.6-1&#39;, &#39;0-0.6&#39;])
        self._plot_heatmap(out)

        # just for proper naming of squars. bad solution
        square = pd.DataFrame(data=sq, columns=[&#39;value&#39;], index=[5,10,15,20,   4,9,14,19,   3,8,13,18,    2,7,12,17,   1,6,11,16])

        return square.sort_index()

    def scatter_density(self, ax=None, ax_x=None, ax_y=None, color:str=&#39;blue&#39;, alpha:float=0.3, volumes:float=None) -&gt; None:
        &#34;&#34;&#34;
        Plot VK scatter with density
        Same as joinplot in seaborn
        but you can use external axes

        Parameters
        ----------
        ax: matplotlib ax
            central ax for scatter
        ax_x: matplotlib ax
            horizontal ax for density
        ax_y: matplotlib ax
            vertical ax for density
        color: str
            color for scatter and density
        alpha: float
            alpha for scatter
        &#34;&#34;&#34;
        if ax is None:
            fig = plt.figure(figsize=(6,6), dpi=100)
            gs = GridSpec(4, 4)

            ax = fig.add_subplot(gs[1:4, 0:3])
            ax_x = fig.add_subplot(gs[0,0:3])
            ax_y = fig.add_subplot(gs[1:4, 3])

        self.table[&#39;intensity&#39;] = self.table[&#39;intensity&#39;] / self.table[&#39;intensity&#39;].median()

        if volumes is None:
            self.table[&#39;volume&#39;] = self.table[&#39;intensity&#39;] / self.table[&#39;intensity&#39;].median()
        else:
            self.table[&#39;volume&#39;] = volumes

        ax.scatter(self.table[&#39;O/C&#39;],self.table[&#39;H/C&#39;], s=self.table[&#39;volume&#39;], alpha=alpha, c=color)
        ax.set_ylim(0,2.2)
        ax.set_xlim(0,1)
        ax.set_xlabel(&#34;O/C&#34;)
        ax.set_ylabel(&#34;H/C&#34;)
        ax.yaxis.set_ticks(np.arange(0, 2.2, 0.4))
        ax.xaxis.set_ticks(np.arange(0, 1.1, 0.2))

        oc = self.table[&#39;O/C&#39;]*self.table[&#39;intensity&#39;]
        hc = self.table[&#39;H/C&#39;]*self.table[&#39;intensity&#39;]
        total_int = self.table[&#39;intensity&#39;].sum()

        x = np.linspace(self.table[&#39;O/C&#39;].min(), self.table[&#39;O/C&#39;].max(), 100)        
        oc = np.array([])
        for i, el in enumerate(x[1:]):
            s = self.table.loc[(self.table[&#39;O/C&#39;] &gt; x[i-1]) &amp; (self.table[&#39;O/C&#39;] &lt;= el), &#39;intensity&#39;].sum()
            coun = len(self.table) * s/total_int
            m = (x[i-1] + x[i])/2
            oc = np.append(oc, [m]*int(coun))
        sns.kdeplot(x = oc, ax=ax_x, color=color, fill=True, alpha=0.1, bw_adjust=2)
        ax_x.set_axis_off()
        ax_x.set_xlim(0,1)
        
        y = np.linspace(self.table[&#39;H/C&#39;].min(), self.table[&#39;H/C&#39;].max(), 100)        
        hc = np.array([])
        for i, el in enumerate(y[1:]):
            s = self.table.loc[(self.table[&#39;H/C&#39;] &gt; y[i-1]) &amp; (self.table[&#39;H/C&#39;] &lt;= el), &#39;intensity&#39;].sum()
            coun = len(self.table) * s/total_int
            m = (y[i-1] + y[i])/2
            hc = np.append(hc, [m]*int(coun))
        sns.kdeplot(x = hc, ax=ax_y, color=color, vertical=True, fill=True, alpha=0.1, bw_adjust=2)
        ax_y.set_axis_off()
        ax_y.set_ylim(0,2.2)


class ErrorTable(object):
    &#34;&#34;&#34;
    A class used to recallibrate mass spectrum

    Attributes
    ----------
    table : pandas Datarame
        consist error table: error in ppm for mass
    &#34;&#34;&#34;

    def __init__(
            self,
            table: pd.DataFrame = None,
    ) -&gt; None:
        &#34;&#34;&#34;
        Init ErrorTable object

        Parameters
        ----------
        table : pandas Datarame
            consist error table: error in ppm for mass
        &#34;&#34;&#34;
        self.table = table

    def dif_mass(self) -&gt; list:
        &#39;&#39;&#39;Generate common mass diffrence list

        Return:
        -------
        List of float, containing most common mass difference
        &#39;&#39;&#39;
        H = 1.007825
        C = 12.000000
        O = 15.994915

        dif = []
        for k in range(1,11):
            dif.append(k*(C + H*2))
            dif.append(k*(O))
            dif.append(k*(C + O))
            dif.append(k*(H*2))
            dif.append(k*(C*2 + O + H*2))
            dif.append(k*(C + O + H*2))
            dif.append(k*(O + H*2))
            dif.append(k*(C + O*2))

        return dif

    def md_error_map(
        self, 
        spec: &#34;MassSpectrum&#34;, 
        ppm: float = 5, 
        show_map: bool = True
        ) -&gt; pd.DataFrame:
        &#39;&#39;&#39;
        Calculate mass differnce map

        Parameters
        ----------
        spec: pd.Dataframe
            Dataframe with spectrum table from MassSpectrum
        ppm: float
            Optional. Default 5.
            Permissible error in ppm
        show_map: bool
            Optional. Default True.
            Show error in ppm versus mass

        Return
        ------
        Pandas Dataframe object with calculated error map
        &#39;&#39;&#39;

        dif = self.dif_mass()

        data = copy.deepcopy(spec.table)
        masses = data[&#39;mass&#39;].values

        data = data.sort_values(by=&#39;intensity&#39;, ascending=False).reset_index(drop=True)
        if len(data) &gt; 1000:
            data = data[:1000]
        data = data.sort_values(by=&#39;mass&#39;).reset_index(drop=True)

        data_error = [] #array for new data

        for index, row in tqdm(data.iterrows(), total=len(data)): #take every mass in list
            
            mass = row[&#34;mass&#34;]

            for i in dif:
                mz = mass + i #massdif

                idx = np.searchsorted(masses, mz, side=&#39;left&#39;)                
                if idx &gt; 0 and (idx == len(masses) or np.fabs(mz - masses[idx - 1]) &lt; np.fabs(mz - masses[idx])):
                    idx -= 1

                if np.fabs(masses[idx] - mz) / mz * 1e6 &lt;= ppm:
                    data_error.append([mass, (masses[idx] - mz)/mz*1000000])
        
        df_error = pd.DataFrame(data = data_error, columns=[&#39;mass&#39;, &#39;ppm&#39; ])
        
        if show_map:
            fig, ax = plt.subplots(figsize=(4, 4), dpi=75)
            ax.scatter(df_error[&#39;mass&#39;], df_error[&#39;ppm&#39;], s=0.01)

        return df_error
    
    def fit_kernel(
        self, 
        f: np.array, 
        show_map: bool = True) -&gt; pd.DataFrame:
        &#39;&#39;&#39;
        Fit max intesity of kernel density map

        Parameters
        ----------
        f: np.array
            keerndel density map in numpy array 100*100
        show_map: bool
            Optional. Default true.
            Plot how fit kernel

        Return
        ------
        Pandas Dataframe with error table for 100 values
        &#39;&#39;&#39;
        df = pd.DataFrame(f, index=np.linspace(3,-3,100))
        
        out = []
        for i in df.columns:
            max_kernel = df[i].quantile(q=0.95)
            ppm = df.loc[df[i] &gt; max_kernel].index.values
            out.append([i, np.mean(ppm)])
        kde_err = pd.DataFrame(data=out, columns=[&#39;i&#39;,&#39;ppm&#39;])
        
        #smooth data
        kde_err[&#39;ppm&#39;] = savgol_filter(kde_err[&#39;ppm&#39;], 31,5)

        xmin = 0
        xmax = 100
        ymin = -3
        ymax = 3

        if show_map:
            fig = plt.figure(figsize=(4,4), dpi=75)
            ax = fig.gca()
            ax.set_xlim(xmin, xmax)
            ax.set_ylim(ymin, ymax)
            ax.imshow(df, extent=[xmin, xmax, ymin, ymax], aspect=&#39;auto&#39;)
            ax.plot(kde_err[&#39;i&#39;], kde_err[&#39;ppm&#39;], c=&#39;r&#39;)

        #lock start at zero
        kde_err[&#39;ppm&#39;] = kde_err[&#39;ppm&#39;] - kde_err.loc[0,&#39;ppm&#39;]
        return kde_err

    def kernel_density_map(
        self, 
        df_error: pd.DataFrame, 
        ppm: float = 3, 
        show_map: bool = False
        ) -&gt; np.array:
        &#39;&#39;&#39;
        Plot kernel density map 100*100 for data

        Parameters
        ----------
        df_error: pd.Dataframe
            error_table for generate kerle density map
        ppm: float
            Optional. Default 3.
            treshould for generate
        show_map: bool
            Optional. Default True. plot kde

        Return
        ------
        numpy array 100*100 with generated kde
        &#39;&#39;&#39;
        
        x = np.array(df_error[&#39;mass&#39;])
        y = np.array(df_error[&#39;ppm&#39;])

        xmin = min(x) 
        xmax = max(x) 

        ymin = -ppm 
        ymax = ppm 

        xx, yy = np.mgrid[xmin:xmax:100j, ymin:ymax:100j]

        positions = np.vstack([xx.ravel(), yy.ravel()])
        values = np.vstack([x, y])
        kernel = st.gaussian_kde(values)
        f = np.reshape(kernel(positions).T, xx.shape)
        f = np.rot90(f)

        if show_map:
            fig = plt.figure(figsize=(4,4), dpi=75)
            ax = fig.gca()
            ax.set_xlim(xmin, xmax)
            ax.set_ylim(ymin, ymax)
            ax.imshow(f, extent=[xmin, xmax, ymin, ymax], aspect=&#39;auto&#39;)
        
        return f

    def assign_error(
        self, 
        spec:MassSpectrum,
        ppm = 3,
        sign = &#39;-&#39;,
        show_map:bool = True):
        &#39;&#39;&#39;
        Recallibrate by assign error

        Parameters
        ----------
        spec: MassSpectrum object
            Initial mass spectrum for recallibrate
        ppm: float
            Optional. Default 3.
            permissible relative error in callibrate error
        sign: str
            Optional. Default &#39;-&#39;. 
            for correct recallibration we need to mark mode
            &#39;-&#39; for negative
            &#39;+&#39; for positive
        show_error: bool
            Optional. Default True. Show process 

        Return
        ------
        ErrorTable object that contain recallabrate error ppm for mass diaposone

        &#39;&#39;&#39;
        spectr = copy.deepcopy(spec)
        spectr = spectr.assign(rel_error=ppm) 
        spectr = spectr.calculate_mass()
        spectr = spectr.calculate_error(sign=sign)
        spectr.show_error()

        error_table = spectr.table
        error_table = error_table.loc[:,[&#39;mass&#39;,&#39;rel_error&#39;]]
        error_table.columns = [&#39;mass&#39;, &#39;ppm&#39;]
        error_table = error_table.dropna()

        kde = self.kernel_density_map(df_error = error_table)
        err = self.fit_kernel(f=kde, show_map=show_map)

        err[&#39;ppm&#39;] = - err[&#39;ppm&#39;]
        err[&#39;mass&#39;] = np.linspace(error_table[&#39;mass&#39;].min(), error_table[&#39;mass&#39;].max(),len(err))

        return ErrorTable(err)

    def massdiff_error(
        self,
        spec:MassSpectrum,
        show_map:bool = True):
        &#39;&#39;&#39;
        Self-recallibration of mass-spectra by mass-difference map

        Parameters
        -----------
        spec: MassSpectrum object
            Initial mass spectrum for recallibrate
        show_error: bool
            Optional. Default True. Show process 

        Return
        -------
        ErrorTable object that contain recallabrate error ppm for mass diaposone

        Reference
        ---------
        Smirnov, K. S., Forcisi, S., Moritz, F., Lucio, M., &amp; Schmitt-Kopplin, P. 
        (2019). Mass difference maps and their application for the 
        recalibration of mass spectrometric data in nontargeted metabolomics. 
        Analytical chemistry, 91(5), 3350-3358. 
        &#39;&#39;&#39;
        spec_table = copy.deepcopy(spec)
        mde = self.md_error_map(spec = spec_table, show_map=show_map)
        f = self.kernel_density_map(df_error=mde)
        err = self.fit_kernel(f=f, show_map=show_map)
        err[&#39;mass&#39;] = np.linspace(spec.table[&#39;mass&#39;].min(), spec.table[&#39;mass&#39;].max(),len(err))

        return ErrorTable(err)

    def etalon_error( self,
                    spec: &#34;MassSpectrum&#34;, #initial masspectr
                    etalon: &#34;MassSpectrum&#34;, #etalon massspectr
                    quart: float = 0.9, #treshold by quartile
                    ppm: float = 3,#treshold by ppm
                    show_error: bool = True
                    ): 
        &#39;&#39;&#39;
        Recallibrate by etalon

        Parameters
        ----------
        spec: MassSpectrum object
            Initial mass spectrum for recallibrate
        etalon: MassSpectrum object
            Etalon mass spectrum
        quart: float
            Optionaly. by default it is 0.9. 
            Usualy it is enough for good callibration
            Quartile, which will be taken for calc recallibrate error
        ppm: float
            Optionaly. Default 3.
            permissible relative error in ppm for seak peak in etalon
        show_error: bool
            Optional. Default True. Show process 

        Return
        ------
        ErrorTable object that contain recallabrate error ppm for mass diaposone

        &#39;&#39;&#39;

        et = copy.deepcopy(etalon.table)[&#39;mass&#39;].to_list()
        df = copy.deepcopy(spec.table)

        min_mass = df[&#39;mass&#39;].min()
        max_mass = df[&#39;mass&#39;].max()
        a = np.linspace(min_mass,max_mass,101)

        treshold = df[&#39;intensity&#39;].quantile(quart)
        df = df.loc[df[&#39;intensity&#39;] &gt; treshold].reset_index(drop = True)
        df[&#39;cal&#39;] = 0 #column for check

        #fill data massiv with correct mass
        for i in range(0,len(df)):
            min_mass = df.loc[i, &#39;mass&#39;]*(1 - ppm/1000000)
            max_mass = df.loc[i, &#39;mass&#39;]*(1 + ppm/1000000)
            for mass in et:
                try:
                    if mass &gt; min_mass and mass &lt; max_mass:
                        df.loc[i, &#39;cal&#39;] = mass
                except:
                    pass
        
        # take just assigned peaks
        df = df.loc[df[&#39;cal&#39;]&gt;0]
        #calc error and mean error
        df[&#39;dif&#39;] = df[&#39;cal&#39;] - df[&#39;mass&#39;]
        mean_e = df[&#39;dif&#39;].mean()

        #make error table
        cor = []
        for i in range(0,100):
            correct = df.loc[(df[&#39;mass&#39;] &gt; a[i]) &amp; (df[&#39;mass&#39;] &lt; a[i+1])][&#39;dif&#39;].mean()
            cor.append((a[i], correct))

        #out table
        err = pd.DataFrame(data=cor, columns=[&#39;m/z&#39;, &#39;err&#39;])
        err[&#39;err&#39;] = err[&#39;err&#39;].fillna(mean_e)
        err[&#39;ppm&#39;]=err[&#39;err&#39;]/err[&#39;m/z&#39;]*1000000

        err[&#39;ppm&#39;] = savgol_filter(err[&#39;ppm&#39;], 51,5)
        err[&#39;mass&#39;] = np.linspace(df[&#39;mass&#39;].min(), df[&#39;mass&#39;].max(),len(err))

        if show_error:
            fig, ax = plt.subplots(figsize=(4, 4), dpi=75)
            ax.plot(err[&#39;m/z&#39;], err[&#39;ppm&#39;])
            ax.set_xlabel(&#39;m/z, Da&#39;)
            ax.set_ylabel(&#39;Error, ppm&#39;)

        return ErrorTable(err)

    def extrapolate(self, ranges:Tuple[float, float] = None) -&gt; &#34;ErrorTable&#34;:
        &#34;&#34;&#34;
        Extrapolate error data

        Parameters
        ----------
        ranges: Tuple(numeric, numeric)
            Optionaly. Default None - all width of mass in error table.
            For which diaposone of mass extrapolate existin data

        Return
        ------
        ErrorTable object with extrapolated data
        &#34;&#34;&#34;
        
        if ranges is None:
            ranges = [self.table[&#39;mass&#39;].min(), self.table[&#39;mass&#39;].max()]

        interpolation_range = np.linspace(ranges[0], ranges[1], 100)
        linear_interp = interp1d(self.table[&#39;mass&#39;], self.table[&#39;ppm&#39;],  bounds_error=False, fill_value=&#39;extrapolate&#39;)
        linear_results = linear_interp(interpolation_range)
        err = pd.DataFrame()
        err [&#39;mass&#39;] = interpolation_range
        err [&#39;ppm&#39;] = linear_results

        return ErrorTable(err)

    def show_error(self) -&gt; None:
        &#34;&#34;&#34;
        Plot error map from ErrorTable data
        &#34;&#34;&#34;
        fig, ax = plt.subplots(figsize=(4,4), dpi=75)
        ax.plot(self.table[&#39;mass&#39;], self.table[&#39;ppm&#39;])
        ax.set_xlabel(&#39;m/z, Da&#39;)
        ax.set_ylabel(&#39;error, ppm&#39;)

    def zeroshift(self, spec:&#34;MassSpectrum&#34;) -&gt; &#34;ErrorTable&#34;:
        &#34;&#34;&#34;
        Shift error so mean eror will be zero

        Parameters
        ----------
        spec: MassSpectrum object
            income massspec

        Return
        ------
        ErrorTable object with shifted ppm error
        &#34;&#34;&#34;
        err = copy.deepcopy(self)
        mean_error = spec.drop_unassigned().calculate_error()[&#39;rel_error&#39;].mean()
        err.table[&#39;ppm&#39;] = err.table[&#39;ppm&#39;] - mean_error
        return ErrorTable(err.table)       


class MassSpectrumList(object):
    &#34;&#34;&#34;
    Class for work list of MassSpectrums objects
    
    Attributes
    ----------
    spectra: Sequence[MassSpectrum]
        list of MassSpectrum objects
    names: Optional[Sequence[str]]
        list of names for spectra
    &#34;&#34;&#34;

    def __init__(self, spectra: Sequence[MassSpectrum] = None, names: Optional[Sequence[str]] = None):
        &#34;&#34;&#34;
        init MassSpectrumList Class
        
        Parameters
        ----------
        spectra: Sequence[MassSpectrum]
            list of MassSpectrum objects
        names: Optional[Sequence[str]]
            list of names for spectra
        &#34;&#34;&#34;
        
        if spectra:
            self.spectra = spectra
        else:
            self.spectra = []

        if names:
            self.names = names
        elif len(self.spectra) &gt; 0:
            self.names = list(range(len(self.spectra)))
        else:
            self.names = []

    def calculate_similarity(self, mode: str = &#34;cosine&#34;) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Calculate similarity matrix for all spectra in MassSpectrumList

        Parameters
        ----------
        mode: str
            Optionaly. Default cosine. 
            one of the similarity functions
            Mode can be: &#34;tanimoto&#34;, &#34;jaccard&#34;, &#34;cosine&#34;

        Return
        ------
        similarity matrix, 2d np.ndarray with size [len(names), len(names)]&#34;&#34;&#34;

        def get_vector(a, b):
            # FIXME Probably bad solution
            c = np.union1d(a, b)
            A = np.zeros(len(c), dtype=bool)
            B = np.zeros(len(c), dtype=bool)
            for i, el in enumerate(c):
                if el in a:
                    A[i] = True
                if el in b:
                    B[i] = True
            return A, B

        def jaccard(a, b):
            A, B = get_vector(a, b)
            return 1 - spatial.distance.jaccard(A, B)

        def tanimoto(a, b):
            A, B = get_vector(a, b)
            return 1 - spatial.distance.rogerstanimoto(A, B)

        def cosine(a, b):
            A, B = get_vector(a, b)
            return 1 - spatial.distance.cosine(A, B)

        if mode == &#34;jaccard&#34;:
            similarity_func = jaccard
        elif mode == &#34;tanimoto&#34;:
            similarity_func = tanimoto
        elif mode == &#39;cosine&#39;:
            similarity_func = cosine
        else:
            raise Exception(f&#34;There is no such mode: {mode}&#34;)

        values = []
        for i in self.spectra:
            if &#39;calculated_mass&#39; not in i.table:
                i = i.calculate_mass()
            values.append([])
            for j in self.spectra:
                if &#39;calculated_mass&#39; not in j.table:
                    j = j.calculate_mass()
                values[-1].append(similarity_func(i.table[&#39;calculated_mass&#39;].dropna().values, j.table[&#39;calculated_mass&#39;].dropna().values))

        return np.array(values)

    def draw_similarity(
        self,
        mode: str = &#34;cosine&#34;,
        values: np.ndarray = None,
        ax: plt.axes = None,
        annot = True
        ) -&gt; None:
        &#34;&#34;&#34;
        Draw similarity matrix by using seaborn

        Parameters
        ----------
        values: np.ndarray
            Optionaly. Similarity matix.
            Default None - It is call calculate_similarity() method.
        mode: str
            Optionaly. If values is none for calculate matrix. 
            Default cosine. one of the similarity functions
            Mode can be: &#34;tanimoto&#34;, &#34;jaccard&#34;, &#34;cosine&#34;
        ax: matplotlib axes
            Entarnal axes for plot
        annotate: bool
            Draw value of similarity onto titles
        &#34;&#34;&#34;
        if values is None:
            values = self.calculate_similarity(mode=mode)

        if ax is None:
            fig, ax = plt.subplots(figsize=(len(self.spectra),len(self.spectra)), dpi=75)
        
        x_axis_labels = self.names
        y_axis_labels = self.names
        sns.heatmap(np.array(values), vmin=0, vmax=1, cmap=&#34;viridis&#34;, annot=annot, ax=ax, xticklabels=x_axis_labels, yticklabels=y_axis_labels)
        plt.title(mode)


class Tmds(object):
    &#34;&#34;&#34;
    A class for calculate TMDS spectrum

    Attributes
    ----------
    table: pandas Datarame
        tmds spectrum - mass_dif, probability and caclulatedd parameters
    elems: Sequence[str]
        elements in brutto formulas
    &#34;&#34;&#34;

    def __init__(
        self,
        table: pd.DataFrame = None,
        elems: Sequence[str] = None
        ) -&gt; None:
        &#34;&#34;&#34;
        Parameters
        ----------
        table: pandas Datarame
            Optional. tmds spectrum - mass_dif, probability and caclulatedd parameters
        elems: Sequence[str]
            Optional. elements in brutto formulas
        &#34;&#34;&#34;

        self.elems = elems

        if table is None:
            self.table = pd.DataFrame()
        else:
            self.table = table
            self.elems = self.find_elems()

    def calc(
        self,
        mass_spec:&#34;MassSpectrum&#34;,
        other:&#34;MassSpectrum&#34;=None,
        p: float = 0.2,
        wide: int = 10,
        C13_filter:bool = True,
        ) -&gt; &#34;Tmds&#34;:

        &#34;&#34;&#34;
        Total mass difference statistic calculation 

        Parameters
        ----------
        mass_spec: MassSpectrum object
            for tmds calculation
        other: MassSpectrum object
            Optional. If None, TMDS will call by self.
        p: float
            Optional. Default 0.2. 
            Minimum relative probability for taking mass-difference
        wide: int
            Optional. Default 10.
            Minimum interval in 0.001*wide Da of peaeks.
        C13_filter: bool
            Optional. Default True. 
            Use only peaks that have C13 isotope peak

        Reference
        ---------
        Anal. Chem. 2009, 81, 10106
        &#34;&#34;&#34;

        spec = copy.deepcopy(mass_spec)
        if other is None:
            spec2 = copy.deepcopy(mass_spec)
        else:
            spec2 = copy.deepcopy(other)

        if C13_filter:
            spec = spec.filter_by_C13(remove=True)
            spec2 = spec2.filter_by_C13(remove=True)
        else:
            spec = spec.drop_unassigned()
            spec2 = spec2.drop_unassigned()

        masses = spec.table[&#39;mass&#39;].values
        masses2 = spec2.table[&#39;mass&#39;].values

        mass_num = len(masses)
        mass_num2 = len(masses2)

        if mass_num &lt;2 or mass_num2 &lt; 2:
            raise Exception(f&#34;Too low amount of assigned peaks&#34;)

        mdiff = np.zeros((mass_num, mass_num2), dtype=float)
        for x in range(mass_num):
            for y in range(x, mass_num2):
                dif = np.fabs(masses[x]-masses2[y])
                if dif &lt; 300:
                    mdiff[x,y] = dif

        mdiff = np.round(mdiff, 3)
        unique, counts = np.unique(mdiff, return_counts=True)
        counts[0] = 0

        tmds_spec = pd.DataFrame()
        tmds_spec[&#39;mass_dif&#39;] = unique
        tmds_spec[&#39;count&#39;] = counts
        tmds_spec[&#39;probability&#39;] = tmds_spec[&#39;count&#39;]/mass_num
        tmds_spec = tmds_spec.sort_values(by=&#39;mass_dif&#39;).reset_index(drop=True)

        value_zero = set([i/1000 for i in range (0, 300000)]) - set (unique)
        unique = np.append(unique, np.array(list(value_zero)))
        counts = np.append(counts, np.zeros(len(value_zero), dtype=float))

        peaks, properties = find_peaks(tmds_spec[&#39;probability&#39;], distance=wide, prominence=p/2)
        prob = []
        for peak in peaks:
            prob.append(tmds_spec.loc[peak-5:peak+5,&#39;probability&#39;].sum())
        tmds_spec = tmds_spec.loc[peaks].reset_index(drop=True)
        tmds_spec[&#39;probability&#39;] = prob
        tmds_spec = tmds_spec.loc[tmds_spec[&#39;probability&#39;] &gt; p]

        if len(tmds_spec) &lt; 0:
            raise Exception(f&#34;There isn&#39;t mass diff mass, decrease p-value&#34;)

        return Tmds(tmds_spec)
    
    def calc_by_brutto(
        self,
        mass_spec:&#34;MassSpectrum&#34;
        ) -&gt; &#34;Tmds&#34;:

        &#34;&#34;&#34;
        Calculate self difference by calculated mass from brutto

        Parameters
        ----------
        mass_spec: MassSpectrum object
            for tmds calculation

        Return
        ------
        Tmds object with assigned signals and elements
        &#34;&#34;&#34;

        mass = mass_spec.drop_unassigned().calculate_error().table[&#39;calculated_mass&#39;].values
        massl = len(mass)
        mdiff = np.zeros((massl, massl), dtype=float)
        for x in range(massl):
            for y in range(x, massl):
                mdiff[x,y] = np.fabs(mass[x]-mass[y])

        mdiff = np.round(mdiff, 6)
        unique, counts = np.unique(mdiff, return_counts=True)
        counts[0] = 0

        diff_spec = pd.DataFrame()
        diff_spec[&#39;mass_dif&#39;] = unique
        diff_spec[&#39;count&#39;] = counts
        diff_spec[&#39;probability&#39;] = diff_spec[&#39;count&#39;]/massl
        diff_spec = diff_spec.sort_values(by=&#39;mass_dif&#39;).reset_index(drop=True)

        return Tmds(diff_spec)

    def assign(
        self,
        generated_bruttos_table: pd.DataFrame = None,
        error: float = 0.001,
        gdf:dict = {&#39;C&#39;:(-1,20),&#39;H&#39;:(-4,40), &#39;O&#39;:(-1,20),&#39;N&#39;:(-1,2)},
        max_num: int = None
        ) -&gt; &#34;Tmds&#34;:

        &#34;&#34;&#34;
        Finding the nearest mass in generated_bruttos_table

        Parameters
        ----------
        generated_bruttos_table: pandas DataFrame 
            Optional. with column &#39;mass&#39; and elements, should be sorted by &#39;mass&#39;
        error: float
            Optional. Default 0.001. 
            absolute error iin Da for assign formulas
        gdf: dict
            Optional, default {&#39;C&#39;:(-1,20),&#39;H&#39;:(-4,40), &#39;O&#39;:(-1,20),&#39;N&#39;:(-1,2)}
            generate brutto table if generated_bruttos_table is None.
        max_num: int
            Optional. Default 100
        
        Return
        ------
        Tmds object with assigned signals and elements
        &#34;&#34;&#34;

        if generated_bruttos_table is None:
            generated_bruttos_table = brutto_gen(gdf, rules=False)
            generated_bruttos_table = generated_bruttos_table.loc[generated_bruttos_table[&#39;mass&#39;] &gt; 0]

        table = self.table.copy()

        masses = generated_bruttos_table[&#34;mass&#34;].values
        
        elems = list(generated_bruttos_table.drop(columns=[&#34;mass&#34;]))
        bruttos = generated_bruttos_table[elems].values.tolist()

        res = []
        for index, row in table.iterrows():
            mass = row[&#34;mass_dif&#34;]
            idx = np.searchsorted(masses, mass, side=&#39;left&#39;)
            if idx &gt; 0 and (idx == len(masses) or np.fabs(mass - masses[idx - 1]) &lt; np.fabs(mass - masses[idx])):
                idx -= 1

            if np.fabs(masses[idx] - mass)  &lt;= error:
                res.append({**dict(zip(elems, bruttos[idx])), &#34;assign&#34;: True, &#34;mass_dif&#34;:mass, &#34;probability&#34;:row[&#34;probability&#34;], &#34;count&#34;:row[&#34;count&#34;]})

        res = pd.DataFrame(res)

        if max_num is not None and len(res) &gt; max_num:
            res = res.sort_values(by=&#39;count&#39;, ascending=False).reset_index(drop=True)
            res = res.loc[:max_num].reset_index(drop=True)
            res = res.sort_values(by=&#39;mass_dif&#39;).reset_index(drop=True)
        
        return Tmds(table=res, elems=elems)

    def find_elems(self):
        &#34;&#34;&#34;
        Find elems from mass spectrum table.

        Find elements in table columns. Used elems_mass_table with all elements and isotopes.
        For example, element &#39;C&#39; will be recognised as carbon 12C, element &#39;C_13&#34; as 13C

        Returns
        -------
        list
            a list of found elemets. For example: [&#39;C&#39;,&#39;H&#39;,&#39;O&#39;,&#39;N&#39;]
        &#34;&#34;&#34;

        main_elems = elements_table()[&#39;element&#39;].values
        all_elems = elements_table()[&#39;element_isotop&#39;].values

        elems = []
        for col in self.table.columns:
            if col in main_elems:
                elems.append(col)
            elif col in all_elems:
                elems.append(col)

        return elems

    def calculate_mass(self) -&gt; &#34;Tmds&#34;:
        &#34;&#34;&#34;
        Calculate mass from brutto formulas in tmds table

        Return
        ------
        Tmds object with calculated mass for assigned brutto formulas
        &#34;&#34;&#34;
        
        table = copy.deepcopy(self.table)
        self.elems = self.find_elems()
        
        table = table.loc[:,self.elems]

        masses = get_elements_masses(self.elems)

        self.table[&#34;calculated_mass&#34;] = table.multiply(masses).sum(axis=1)
        self.table[&#34;calculated_mass&#34;] = np.round(self.table[&#34;calculated_mass&#34;], 6)
        self.table.loc[self.table[&#34;calculated_mass&#34;] == 0, &#34;calculated_mass&#34;] = np.NaN

        return Tmds(self.table, elems=self.elems)

    def draw(
        self,
        xlim: Tuple[float, float] = (None, None),
        ylim: Tuple[float, float] = (None, None),
        color: str = &#39;black&#39;,
        ax = None,
        ) -&gt; None:
        &#34;&#34;&#34;
        Draw TMDS spectrum

        All parameters is optional

        Parameters
        ----------
        xlim: Tuple (float, float)
            restrict for mass
        ylim: Tuple (float, float)
            restrict for probability
        color: str
            color of draw
        ax: matplotlyp axes object
            send here ax to plot in your own condition
        &#34;&#34;&#34;

        df = self.table.sort_values(by=&#34;mass_dif&#34;)

        mass = df[&#39;mass_dif&#39;].values
        if xlim[0] is None:
            xlim = (mass.min(), xlim[1])
        if xlim[1] is None:
            xlim = (xlim[0], mass.max())

        intensity = df[&#39;probability&#39;].values
        # filter first intensity and only after mass (because we will lose the information)
        intensity = intensity[(xlim[0] &lt;= mass) &amp; (mass &lt;= xlim[1])]
        mass = mass[(xlim[0] &lt;= mass) &amp; (mass &lt;= xlim[1])]

        # bas solution, probably it&#39;s needed to rewrite this piece
        M = np.zeros((len(mass), 3))
        M[:, 0] = mass
        M[:, 1] = mass
        M[:, 2] = mass
        M = M.reshape(-1)

        I = np.zeros((len(intensity), 3))
        I[:, 1] = intensity
        I = I.reshape(-1)

        if ax is None:
            fig, ax = plt.subplots(figsize=(4,4), dpi=75)
            
        ax.plot(M, I, color=color, linewidth=0.2)
        ax.plot([xlim[0], xlim[1]], [0, 0], color=color, linewidth=0.2)
        ax.set_xlim(xlim)
        ax.set_ylim(ylim)
        ax.set_xlabel(&#39;mass difference, Da&#39;)
        ax.set_ylabel(&#39;P&#39;)
        ax.set_title(f&#39;{len(self.table)} peaks&#39;)
        return

    def save(self, filename:str) -&gt; None:
        &#34;&#34;&#34;
        Save Tmds spectrum as csv

        Parameters
        ----------
        filename: str
            file name with path in which save tmds
        &#34;&#34;&#34;
        self.table.to_csv(filename)

    def load(self, filename:str) -&gt; &#34;Tmds&#34;:
        &#34;&#34;&#34;
        Load Tmds spectrum table from csv

        Parameters
        ----------
        filename: str
            file name with path in which load tmds
        &#34;&#34;&#34;
        return Tmds(pd.read_csv(filename))


class Reaction(object):
    &#34;&#34;&#34;
    Class for discover reaction by MS-difference methods

    Atributes
    ---------
    sourse: MassSpectrum object
        mass spectrum of source
    product: MassSpectrum object
        mass spectrum of product
    &#34;&#34;&#34;
    def __init__(self, 
        sourse:&#34;MassSpectrum&#34; = None, 
        product:&#34;MassSpectrum&#34; = None,
        ) -&gt; None:
        &#34;&#34;&#34;
        Init Reaction

        Parameters
        ---------
        sourse: MassSpectrum object
            mass spectrum of source
        product: MassSpectrum object
            mass spectrum of product
        &#34;&#34;&#34;
        self.sourse = sourse
        self.product = product

    def find_modification(self, brutto_table:pd.DataFrame) -&gt; &#34;Reaction&#34;:
        &#34;&#34;&#34;
        Find in source peaks that have modifed by diff-mass-es in brutto table
        Also cath them in product

        Parameters
        ----------
        brutto_table:pd.DataFrame
            table with element and their masses.
            Can be generated by function brutto_generator.brutto_gen().
        &#34;&#34;&#34;

        self.sourse = self.sourse.drop_unassigned().calculate_mass()
        self.product = self.product.drop_unassigned().calculate_mass()

        sourse_mass = self.sourse.table[&#39;calculated_mass&#39;].values
        product_mass = self.product.table[&#39;calculated_mass&#39;].values

        sourse_mass_num = len(sourse_mass)
        product_mass_num = len(product_mass)

        mdiff = np.zeros((sourse_mass_num, product_mass_num), dtype=float)
        for x in range(sourse_mass_num):
            for y in range(product_mass_num):
                mdiff[x,y] = product_mass[y]-sourse_mass[x]

        sourse_index = np.array([])
        product_index = np.array([])
        for i, row in brutto_table.iterrows():
            arr = np.where(mdiff == row[&#39;mass&#39;])
            sourse_index = np.hstack([sourse_index, arr[0]])
            product_index = np.hstack([product_index, arr[1]])

        self.sourse.table[&#39;modified&#39;] = False
        self.product.table[&#39;modified&#39;] = False

        self.sourse.table.loc[sourse_index,&#39;modified&#39;] = True
        self.product.table.loc[product_index,&#39;modified&#39;] = True

        return Reaction(sourse=self.sourse, product=self.product)

    def draw_modification(self,
        ax:plt.axes = None,
        sourse:bool = True,
        product:bool = True,
        sourse_color:str = &#39;red&#39;,
        product_color:str = &#39;blue&#39;,
        volume:float = 5
        )-&gt;None:
        &#34;&#34;&#34;
        Plot Van-Krevelen for modifed peaks in product and sourse

        Parameters
        ----------
        ax: plt.axes
            Optional. Use external ax
        sourse: bool
            Optional. Default True. plot sourse peaks
        product: bool
            Optional. Default True. plot product peaks
        sourse_color: str
            Optional. Default red. Color of sourse peaks
        product_color: str
            Optional. Default blue. Color of product peaks
        volume: float
            Optional. Default 5. Size of dot on VK
        &#34;&#34;&#34;

        if &#39;modified&#39; not in self.product.table or &#39;modified&#39; not in self.sourse.table:
            raise Exception(f&#34;Modification hasn&#39;t calculated&#34;)

        if ax is None:
            fig, ax = plt.subplots(figsize=(4,4), dpi = 75)

        if sourse:
            s = self.sourse.table.loc[self.sourse.table[&#39;modified&#39;] == True]
            vk_s = VanKrevelen(s).draw_scatter(ax=ax, volumes=volume, color=sourse_color)

        if product:
            p = self.sourse.table.loc[self.product.table[&#39;modified&#39;] == True]
            vk_p = VanKrevelen(p).draw_scatter(ax=ax, volumes=volume, color=product_color)        


if __name__ == &#39;__main__&#39;:
    pass</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="nhsmasslib.mass.CanNotCreateVanKrevelen"><code class="flex name class">
<span>class <span class="ident">CanNotCreateVanKrevelen</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Common base class for all non-exit exceptions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CanNotCreateVanKrevelen(Exception):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="nhsmasslib.mass.ErrorTable"><code class="flex name class">
<span>class <span class="ident">ErrorTable</span></span>
<span>(</span><span>table:pandas.core.frame.DataFrame=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A class used to recallibrate mass spectrum</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>table</code></strong> :&ensp;<code>pandas Datarame</code></dt>
<dd>consist error table: error in ppm for mass</dd>
</dl>
<p>Init ErrorTable object</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>table</code></strong> :&ensp;<code>pandas Datarame</code></dt>
<dd>consist error table: error in ppm for mass</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ErrorTable(object):
    &#34;&#34;&#34;
    A class used to recallibrate mass spectrum

    Attributes
    ----------
    table : pandas Datarame
        consist error table: error in ppm for mass
    &#34;&#34;&#34;

    def __init__(
            self,
            table: pd.DataFrame = None,
    ) -&gt; None:
        &#34;&#34;&#34;
        Init ErrorTable object

        Parameters
        ----------
        table : pandas Datarame
            consist error table: error in ppm for mass
        &#34;&#34;&#34;
        self.table = table

    def dif_mass(self) -&gt; list:
        &#39;&#39;&#39;Generate common mass diffrence list

        Return:
        -------
        List of float, containing most common mass difference
        &#39;&#39;&#39;
        H = 1.007825
        C = 12.000000
        O = 15.994915

        dif = []
        for k in range(1,11):
            dif.append(k*(C + H*2))
            dif.append(k*(O))
            dif.append(k*(C + O))
            dif.append(k*(H*2))
            dif.append(k*(C*2 + O + H*2))
            dif.append(k*(C + O + H*2))
            dif.append(k*(O + H*2))
            dif.append(k*(C + O*2))

        return dif

    def md_error_map(
        self, 
        spec: &#34;MassSpectrum&#34;, 
        ppm: float = 5, 
        show_map: bool = True
        ) -&gt; pd.DataFrame:
        &#39;&#39;&#39;
        Calculate mass differnce map

        Parameters
        ----------
        spec: pd.Dataframe
            Dataframe with spectrum table from MassSpectrum
        ppm: float
            Optional. Default 5.
            Permissible error in ppm
        show_map: bool
            Optional. Default True.
            Show error in ppm versus mass

        Return
        ------
        Pandas Dataframe object with calculated error map
        &#39;&#39;&#39;

        dif = self.dif_mass()

        data = copy.deepcopy(spec.table)
        masses = data[&#39;mass&#39;].values

        data = data.sort_values(by=&#39;intensity&#39;, ascending=False).reset_index(drop=True)
        if len(data) &gt; 1000:
            data = data[:1000]
        data = data.sort_values(by=&#39;mass&#39;).reset_index(drop=True)

        data_error = [] #array for new data

        for index, row in tqdm(data.iterrows(), total=len(data)): #take every mass in list
            
            mass = row[&#34;mass&#34;]

            for i in dif:
                mz = mass + i #massdif

                idx = np.searchsorted(masses, mz, side=&#39;left&#39;)                
                if idx &gt; 0 and (idx == len(masses) or np.fabs(mz - masses[idx - 1]) &lt; np.fabs(mz - masses[idx])):
                    idx -= 1

                if np.fabs(masses[idx] - mz) / mz * 1e6 &lt;= ppm:
                    data_error.append([mass, (masses[idx] - mz)/mz*1000000])
        
        df_error = pd.DataFrame(data = data_error, columns=[&#39;mass&#39;, &#39;ppm&#39; ])
        
        if show_map:
            fig, ax = plt.subplots(figsize=(4, 4), dpi=75)
            ax.scatter(df_error[&#39;mass&#39;], df_error[&#39;ppm&#39;], s=0.01)

        return df_error
    
    def fit_kernel(
        self, 
        f: np.array, 
        show_map: bool = True) -&gt; pd.DataFrame:
        &#39;&#39;&#39;
        Fit max intesity of kernel density map

        Parameters
        ----------
        f: np.array
            keerndel density map in numpy array 100*100
        show_map: bool
            Optional. Default true.
            Plot how fit kernel

        Return
        ------
        Pandas Dataframe with error table for 100 values
        &#39;&#39;&#39;
        df = pd.DataFrame(f, index=np.linspace(3,-3,100))
        
        out = []
        for i in df.columns:
            max_kernel = df[i].quantile(q=0.95)
            ppm = df.loc[df[i] &gt; max_kernel].index.values
            out.append([i, np.mean(ppm)])
        kde_err = pd.DataFrame(data=out, columns=[&#39;i&#39;,&#39;ppm&#39;])
        
        #smooth data
        kde_err[&#39;ppm&#39;] = savgol_filter(kde_err[&#39;ppm&#39;], 31,5)

        xmin = 0
        xmax = 100
        ymin = -3
        ymax = 3

        if show_map:
            fig = plt.figure(figsize=(4,4), dpi=75)
            ax = fig.gca()
            ax.set_xlim(xmin, xmax)
            ax.set_ylim(ymin, ymax)
            ax.imshow(df, extent=[xmin, xmax, ymin, ymax], aspect=&#39;auto&#39;)
            ax.plot(kde_err[&#39;i&#39;], kde_err[&#39;ppm&#39;], c=&#39;r&#39;)

        #lock start at zero
        kde_err[&#39;ppm&#39;] = kde_err[&#39;ppm&#39;] - kde_err.loc[0,&#39;ppm&#39;]
        return kde_err

    def kernel_density_map(
        self, 
        df_error: pd.DataFrame, 
        ppm: float = 3, 
        show_map: bool = False
        ) -&gt; np.array:
        &#39;&#39;&#39;
        Plot kernel density map 100*100 for data

        Parameters
        ----------
        df_error: pd.Dataframe
            error_table for generate kerle density map
        ppm: float
            Optional. Default 3.
            treshould for generate
        show_map: bool
            Optional. Default True. plot kde

        Return
        ------
        numpy array 100*100 with generated kde
        &#39;&#39;&#39;
        
        x = np.array(df_error[&#39;mass&#39;])
        y = np.array(df_error[&#39;ppm&#39;])

        xmin = min(x) 
        xmax = max(x) 

        ymin = -ppm 
        ymax = ppm 

        xx, yy = np.mgrid[xmin:xmax:100j, ymin:ymax:100j]

        positions = np.vstack([xx.ravel(), yy.ravel()])
        values = np.vstack([x, y])
        kernel = st.gaussian_kde(values)
        f = np.reshape(kernel(positions).T, xx.shape)
        f = np.rot90(f)

        if show_map:
            fig = plt.figure(figsize=(4,4), dpi=75)
            ax = fig.gca()
            ax.set_xlim(xmin, xmax)
            ax.set_ylim(ymin, ymax)
            ax.imshow(f, extent=[xmin, xmax, ymin, ymax], aspect=&#39;auto&#39;)
        
        return f

    def assign_error(
        self, 
        spec:MassSpectrum,
        ppm = 3,
        sign = &#39;-&#39;,
        show_map:bool = True):
        &#39;&#39;&#39;
        Recallibrate by assign error

        Parameters
        ----------
        spec: MassSpectrum object
            Initial mass spectrum for recallibrate
        ppm: float
            Optional. Default 3.
            permissible relative error in callibrate error
        sign: str
            Optional. Default &#39;-&#39;. 
            for correct recallibration we need to mark mode
            &#39;-&#39; for negative
            &#39;+&#39; for positive
        show_error: bool
            Optional. Default True. Show process 

        Return
        ------
        ErrorTable object that contain recallabrate error ppm for mass diaposone

        &#39;&#39;&#39;
        spectr = copy.deepcopy(spec)
        spectr = spectr.assign(rel_error=ppm) 
        spectr = spectr.calculate_mass()
        spectr = spectr.calculate_error(sign=sign)
        spectr.show_error()

        error_table = spectr.table
        error_table = error_table.loc[:,[&#39;mass&#39;,&#39;rel_error&#39;]]
        error_table.columns = [&#39;mass&#39;, &#39;ppm&#39;]
        error_table = error_table.dropna()

        kde = self.kernel_density_map(df_error = error_table)
        err = self.fit_kernel(f=kde, show_map=show_map)

        err[&#39;ppm&#39;] = - err[&#39;ppm&#39;]
        err[&#39;mass&#39;] = np.linspace(error_table[&#39;mass&#39;].min(), error_table[&#39;mass&#39;].max(),len(err))

        return ErrorTable(err)

    def massdiff_error(
        self,
        spec:MassSpectrum,
        show_map:bool = True):
        &#39;&#39;&#39;
        Self-recallibration of mass-spectra by mass-difference map

        Parameters
        -----------
        spec: MassSpectrum object
            Initial mass spectrum for recallibrate
        show_error: bool
            Optional. Default True. Show process 

        Return
        -------
        ErrorTable object that contain recallabrate error ppm for mass diaposone

        Reference
        ---------
        Smirnov, K. S., Forcisi, S., Moritz, F., Lucio, M., &amp; Schmitt-Kopplin, P. 
        (2019). Mass difference maps and their application for the 
        recalibration of mass spectrometric data in nontargeted metabolomics. 
        Analytical chemistry, 91(5), 3350-3358. 
        &#39;&#39;&#39;
        spec_table = copy.deepcopy(spec)
        mde = self.md_error_map(spec = spec_table, show_map=show_map)
        f = self.kernel_density_map(df_error=mde)
        err = self.fit_kernel(f=f, show_map=show_map)
        err[&#39;mass&#39;] = np.linspace(spec.table[&#39;mass&#39;].min(), spec.table[&#39;mass&#39;].max(),len(err))

        return ErrorTable(err)

    def etalon_error( self,
                    spec: &#34;MassSpectrum&#34;, #initial masspectr
                    etalon: &#34;MassSpectrum&#34;, #etalon massspectr
                    quart: float = 0.9, #treshold by quartile
                    ppm: float = 3,#treshold by ppm
                    show_error: bool = True
                    ): 
        &#39;&#39;&#39;
        Recallibrate by etalon

        Parameters
        ----------
        spec: MassSpectrum object
            Initial mass spectrum for recallibrate
        etalon: MassSpectrum object
            Etalon mass spectrum
        quart: float
            Optionaly. by default it is 0.9. 
            Usualy it is enough for good callibration
            Quartile, which will be taken for calc recallibrate error
        ppm: float
            Optionaly. Default 3.
            permissible relative error in ppm for seak peak in etalon
        show_error: bool
            Optional. Default True. Show process 

        Return
        ------
        ErrorTable object that contain recallabrate error ppm for mass diaposone

        &#39;&#39;&#39;

        et = copy.deepcopy(etalon.table)[&#39;mass&#39;].to_list()
        df = copy.deepcopy(spec.table)

        min_mass = df[&#39;mass&#39;].min()
        max_mass = df[&#39;mass&#39;].max()
        a = np.linspace(min_mass,max_mass,101)

        treshold = df[&#39;intensity&#39;].quantile(quart)
        df = df.loc[df[&#39;intensity&#39;] &gt; treshold].reset_index(drop = True)
        df[&#39;cal&#39;] = 0 #column for check

        #fill data massiv with correct mass
        for i in range(0,len(df)):
            min_mass = df.loc[i, &#39;mass&#39;]*(1 - ppm/1000000)
            max_mass = df.loc[i, &#39;mass&#39;]*(1 + ppm/1000000)
            for mass in et:
                try:
                    if mass &gt; min_mass and mass &lt; max_mass:
                        df.loc[i, &#39;cal&#39;] = mass
                except:
                    pass
        
        # take just assigned peaks
        df = df.loc[df[&#39;cal&#39;]&gt;0]
        #calc error and mean error
        df[&#39;dif&#39;] = df[&#39;cal&#39;] - df[&#39;mass&#39;]
        mean_e = df[&#39;dif&#39;].mean()

        #make error table
        cor = []
        for i in range(0,100):
            correct = df.loc[(df[&#39;mass&#39;] &gt; a[i]) &amp; (df[&#39;mass&#39;] &lt; a[i+1])][&#39;dif&#39;].mean()
            cor.append((a[i], correct))

        #out table
        err = pd.DataFrame(data=cor, columns=[&#39;m/z&#39;, &#39;err&#39;])
        err[&#39;err&#39;] = err[&#39;err&#39;].fillna(mean_e)
        err[&#39;ppm&#39;]=err[&#39;err&#39;]/err[&#39;m/z&#39;]*1000000

        err[&#39;ppm&#39;] = savgol_filter(err[&#39;ppm&#39;], 51,5)
        err[&#39;mass&#39;] = np.linspace(df[&#39;mass&#39;].min(), df[&#39;mass&#39;].max(),len(err))

        if show_error:
            fig, ax = plt.subplots(figsize=(4, 4), dpi=75)
            ax.plot(err[&#39;m/z&#39;], err[&#39;ppm&#39;])
            ax.set_xlabel(&#39;m/z, Da&#39;)
            ax.set_ylabel(&#39;Error, ppm&#39;)

        return ErrorTable(err)

    def extrapolate(self, ranges:Tuple[float, float] = None) -&gt; &#34;ErrorTable&#34;:
        &#34;&#34;&#34;
        Extrapolate error data

        Parameters
        ----------
        ranges: Tuple(numeric, numeric)
            Optionaly. Default None - all width of mass in error table.
            For which diaposone of mass extrapolate existin data

        Return
        ------
        ErrorTable object with extrapolated data
        &#34;&#34;&#34;
        
        if ranges is None:
            ranges = [self.table[&#39;mass&#39;].min(), self.table[&#39;mass&#39;].max()]

        interpolation_range = np.linspace(ranges[0], ranges[1], 100)
        linear_interp = interp1d(self.table[&#39;mass&#39;], self.table[&#39;ppm&#39;],  bounds_error=False, fill_value=&#39;extrapolate&#39;)
        linear_results = linear_interp(interpolation_range)
        err = pd.DataFrame()
        err [&#39;mass&#39;] = interpolation_range
        err [&#39;ppm&#39;] = linear_results

        return ErrorTable(err)

    def show_error(self) -&gt; None:
        &#34;&#34;&#34;
        Plot error map from ErrorTable data
        &#34;&#34;&#34;
        fig, ax = plt.subplots(figsize=(4,4), dpi=75)
        ax.plot(self.table[&#39;mass&#39;], self.table[&#39;ppm&#39;])
        ax.set_xlabel(&#39;m/z, Da&#39;)
        ax.set_ylabel(&#39;error, ppm&#39;)

    def zeroshift(self, spec:&#34;MassSpectrum&#34;) -&gt; &#34;ErrorTable&#34;:
        &#34;&#34;&#34;
        Shift error so mean eror will be zero

        Parameters
        ----------
        spec: MassSpectrum object
            income massspec

        Return
        ------
        ErrorTable object with shifted ppm error
        &#34;&#34;&#34;
        err = copy.deepcopy(self)
        mean_error = spec.drop_unassigned().calculate_error()[&#39;rel_error&#39;].mean()
        err.table[&#39;ppm&#39;] = err.table[&#39;ppm&#39;] - mean_error
        return ErrorTable(err.table)       </code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="nhsmasslib.mass.ErrorTable.assign_error"><code class="name flex">
<span>def <span class="ident">assign_error</span></span>(<span>self, spec:<a title="nhsmasslib.mass.MassSpectrum" href="#nhsmasslib.mass.MassSpectrum">MassSpectrum</a>, ppm=3, sign='-', show_map:bool=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Recallibrate by assign error</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>spec</code></strong> :&ensp;<code><a title="nhsmasslib.mass.MassSpectrum" href="#nhsmasslib.mass.MassSpectrum">MassSpectrum</a> object</code></dt>
<dd>Initial mass spectrum for recallibrate</dd>
<dt><strong><code>ppm</code></strong> :&ensp;<code>float</code></dt>
<dd>Optional. Default 3.
permissible relative error in callibrate error</dd>
<dt><strong><code>sign</code></strong> :&ensp;<code>str</code></dt>
<dd>Optional. Default '-'.
for correct recallibration we need to mark mode
'-' for negative
'+' for positive</dd>
<dt><strong><code>show_error</code></strong> :&ensp;<code>bool</code></dt>
<dd>Optional. Default True. Show process</dd>
</dl>
<h2 id="return">Return</h2>
<p>ErrorTable object that contain recallabrate error ppm for mass diaposone</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assign_error(
    self, 
    spec:MassSpectrum,
    ppm = 3,
    sign = &#39;-&#39;,
    show_map:bool = True):
    &#39;&#39;&#39;
    Recallibrate by assign error

    Parameters
    ----------
    spec: MassSpectrum object
        Initial mass spectrum for recallibrate
    ppm: float
        Optional. Default 3.
        permissible relative error in callibrate error
    sign: str
        Optional. Default &#39;-&#39;. 
        for correct recallibration we need to mark mode
        &#39;-&#39; for negative
        &#39;+&#39; for positive
    show_error: bool
        Optional. Default True. Show process 

    Return
    ------
    ErrorTable object that contain recallabrate error ppm for mass diaposone

    &#39;&#39;&#39;
    spectr = copy.deepcopy(spec)
    spectr = spectr.assign(rel_error=ppm) 
    spectr = spectr.calculate_mass()
    spectr = spectr.calculate_error(sign=sign)
    spectr.show_error()

    error_table = spectr.table
    error_table = error_table.loc[:,[&#39;mass&#39;,&#39;rel_error&#39;]]
    error_table.columns = [&#39;mass&#39;, &#39;ppm&#39;]
    error_table = error_table.dropna()

    kde = self.kernel_density_map(df_error = error_table)
    err = self.fit_kernel(f=kde, show_map=show_map)

    err[&#39;ppm&#39;] = - err[&#39;ppm&#39;]
    err[&#39;mass&#39;] = np.linspace(error_table[&#39;mass&#39;].min(), error_table[&#39;mass&#39;].max(),len(err))

    return ErrorTable(err)</code></pre>
</details>
</dd>
<dt id="nhsmasslib.mass.ErrorTable.dif_mass"><code class="name flex">
<span>def <span class="ident">dif_mass</span></span>(<span>self) >list</span>
</code></dt>
<dd>
<div class="desc"><p>Generate common mass diffrence list</p>
<h2 id="return">Return:</h2>
<p>List of float, containing most common mass difference</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dif_mass(self) -&gt; list:
    &#39;&#39;&#39;Generate common mass diffrence list

    Return:
    -------
    List of float, containing most common mass difference
    &#39;&#39;&#39;
    H = 1.007825
    C = 12.000000
    O = 15.994915

    dif = []
    for k in range(1,11):
        dif.append(k*(C + H*2))
        dif.append(k*(O))
        dif.append(k*(C + O))
        dif.append(k*(H*2))
        dif.append(k*(C*2 + O + H*2))
        dif.append(k*(C + O + H*2))
        dif.append(k*(O + H*2))
        dif.append(k*(C + O*2))

    return dif</code></pre>
</details>
</dd>
<dt id="nhsmasslib.mass.ErrorTable.etalon_error"><code class="name flex">
<span>def <span class="ident">etalon_error</span></span>(<span>self, spec:<a title="nhsmasslib.mass.MassSpectrum" href="#nhsmasslib.mass.MassSpectrum">MassSpectrum</a>, etalon:<a title="nhsmasslib.mass.MassSpectrum" href="#nhsmasslib.mass.MassSpectrum">MassSpectrum</a>, quart:float=0.9, ppm:float=3, show_error:bool=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Recallibrate by etalon</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>spec</code></strong> :&ensp;<code><a title="nhsmasslib.mass.MassSpectrum" href="#nhsmasslib.mass.MassSpectrum">MassSpectrum</a> object</code></dt>
<dd>Initial mass spectrum for recallibrate</dd>
<dt><strong><code>etalon</code></strong> :&ensp;<code><a title="nhsmasslib.mass.MassSpectrum" href="#nhsmasslib.mass.MassSpectrum">MassSpectrum</a> object</code></dt>
<dd>Etalon mass spectrum</dd>
<dt><strong><code>quart</code></strong> :&ensp;<code>float</code></dt>
<dd>Optionaly. by default it is 0.9.
Usualy it is enough for good callibration
Quartile, which will be taken for calc recallibrate error</dd>
<dt><strong><code>ppm</code></strong> :&ensp;<code>float</code></dt>
<dd>Optionaly. Default 3.
permissible relative error in ppm for seak peak in etalon</dd>
<dt><strong><code>show_error</code></strong> :&ensp;<code>bool</code></dt>
<dd>Optional. Default True. Show process</dd>
</dl>
<h2 id="return">Return</h2>
<p>ErrorTable object that contain recallabrate error ppm for mass diaposone</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def etalon_error( self,
                spec: &#34;MassSpectrum&#34;, #initial masspectr
                etalon: &#34;MassSpectrum&#34;, #etalon massspectr
                quart: float = 0.9, #treshold by quartile
                ppm: float = 3,#treshold by ppm
                show_error: bool = True
                ): 
    &#39;&#39;&#39;
    Recallibrate by etalon

    Parameters
    ----------
    spec: MassSpectrum object
        Initial mass spectrum for recallibrate
    etalon: MassSpectrum object
        Etalon mass spectrum
    quart: float
        Optionaly. by default it is 0.9. 
        Usualy it is enough for good callibration
        Quartile, which will be taken for calc recallibrate error
    ppm: float
        Optionaly. Default 3.
        permissible relative error in ppm for seak peak in etalon
    show_error: bool
        Optional. Default True. Show process 

    Return
    ------
    ErrorTable object that contain recallabrate error ppm for mass diaposone

    &#39;&#39;&#39;

    et = copy.deepcopy(etalon.table)[&#39;mass&#39;].to_list()
    df = copy.deepcopy(spec.table)

    min_mass = df[&#39;mass&#39;].min()
    max_mass = df[&#39;mass&#39;].max()
    a = np.linspace(min_mass,max_mass,101)

    treshold = df[&#39;intensity&#39;].quantile(quart)
    df = df.loc[df[&#39;intensity&#39;] &gt; treshold].reset_index(drop = True)
    df[&#39;cal&#39;] = 0 #column for check

    #fill data massiv with correct mass
    for i in range(0,len(df)):
        min_mass = df.loc[i, &#39;mass&#39;]*(1 - ppm/1000000)
        max_mass = df.loc[i, &#39;mass&#39;]*(1 + ppm/1000000)
        for mass in et:
            try:
                if mass &gt; min_mass and mass &lt; max_mass:
                    df.loc[i, &#39;cal&#39;] = mass
            except:
                pass
    
    # take just assigned peaks
    df = df.loc[df[&#39;cal&#39;]&gt;0]
    #calc error and mean error
    df[&#39;dif&#39;] = df[&#39;cal&#39;] - df[&#39;mass&#39;]
    mean_e = df[&#39;dif&#39;].mean()

    #make error table
    cor = []
    for i in range(0,100):
        correct = df.loc[(df[&#39;mass&#39;] &gt; a[i]) &amp; (df[&#39;mass&#39;] &lt; a[i+1])][&#39;dif&#39;].mean()
        cor.append((a[i], correct))

    #out table
    err = pd.DataFrame(data=cor, columns=[&#39;m/z&#39;, &#39;err&#39;])
    err[&#39;err&#39;] = err[&#39;err&#39;].fillna(mean_e)
    err[&#39;ppm&#39;]=err[&#39;err&#39;]/err[&#39;m/z&#39;]*1000000

    err[&#39;ppm&#39;] = savgol_filter(err[&#39;ppm&#39;], 51,5)
    err[&#39;mass&#39;] = np.linspace(df[&#39;mass&#39;].min(), df[&#39;mass&#39;].max(),len(err))

    if show_error:
        fig, ax = plt.subplots(figsize=(4, 4), dpi=75)
        ax.plot(err[&#39;m/z&#39;], err[&#39;ppm&#39;])
        ax.set_xlabel(&#39;m/z, Da&#39;)
        ax.set_ylabel(&#39;Error, ppm&#39;)

    return ErrorTable(err)</code></pre>
</details>
</dd>
<dt id="nhsmasslib.mass.ErrorTable.extrapolate"><code class="name flex">
<span>def <span class="ident">extrapolate</span></span>(<span>self, ranges:Tuple[float,float]=None) ><a title="nhsmasslib.mass.ErrorTable" href="#nhsmasslib.mass.ErrorTable">ErrorTable</a></span>
</code></dt>
<dd>
<div class="desc"><p>Extrapolate error data</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ranges</code></strong> :&ensp;<code>Tuple(numeric, numeric)</code></dt>
<dd>Optionaly. Default None - all width of mass in error table.
For which diaposone of mass extrapolate existin data</dd>
</dl>
<h2 id="return">Return</h2>
<p>ErrorTable object with extrapolated data</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extrapolate(self, ranges:Tuple[float, float] = None) -&gt; &#34;ErrorTable&#34;:
    &#34;&#34;&#34;
    Extrapolate error data

    Parameters
    ----------
    ranges: Tuple(numeric, numeric)
        Optionaly. Default None - all width of mass in error table.
        For which diaposone of mass extrapolate existin data

    Return
    ------
    ErrorTable object with extrapolated data
    &#34;&#34;&#34;
    
    if ranges is None:
        ranges = [self.table[&#39;mass&#39;].min(), self.table[&#39;mass&#39;].max()]

    interpolation_range = np.linspace(ranges[0], ranges[1], 100)
    linear_interp = interp1d(self.table[&#39;mass&#39;], self.table[&#39;ppm&#39;],  bounds_error=False, fill_value=&#39;extrapolate&#39;)
    linear_results = linear_interp(interpolation_range)
    err = pd.DataFrame()
    err [&#39;mass&#39;] = interpolation_range
    err [&#39;ppm&#39;] = linear_results

    return ErrorTable(err)</code></pre>
</details>
</dd>
<dt id="nhsmasslib.mass.ErrorTable.fit_kernel"><code class="name flex">
<span>def <span class="ident">fit_kernel</span></span>(<span>self, f:<built-infunctionarray>, show_map:bool=True) >pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Fit max intesity of kernel density map</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>f</code></strong> :&ensp;<code>np.array</code></dt>
<dd>keerndel density map in numpy array 100*100</dd>
<dt><strong><code>show_map</code></strong> :&ensp;<code>bool</code></dt>
<dd>Optional. Default true.
Plot how fit kernel</dd>
</dl>
<h2 id="return">Return</h2>
<p>Pandas Dataframe with error table for 100 values</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fit_kernel(
    self, 
    f: np.array, 
    show_map: bool = True) -&gt; pd.DataFrame:
    &#39;&#39;&#39;
    Fit max intesity of kernel density map

    Parameters
    ----------
    f: np.array
        keerndel density map in numpy array 100*100
    show_map: bool
        Optional. Default true.
        Plot how fit kernel

    Return
    ------
    Pandas Dataframe with error table for 100 values
    &#39;&#39;&#39;
    df = pd.DataFrame(f, index=np.linspace(3,-3,100))
    
    out = []
    for i in df.columns:
        max_kernel = df[i].quantile(q=0.95)
        ppm = df.loc[df[i] &gt; max_kernel].index.values
        out.append([i, np.mean(ppm)])
    kde_err = pd.DataFrame(data=out, columns=[&#39;i&#39;,&#39;ppm&#39;])
    
    #smooth data
    kde_err[&#39;ppm&#39;] = savgol_filter(kde_err[&#39;ppm&#39;], 31,5)

    xmin = 0
    xmax = 100
    ymin = -3
    ymax = 3

    if show_map:
        fig = plt.figure(figsize=(4,4), dpi=75)
        ax = fig.gca()
        ax.set_xlim(xmin, xmax)
        ax.set_ylim(ymin, ymax)
        ax.imshow(df, extent=[xmin, xmax, ymin, ymax], aspect=&#39;auto&#39;)
        ax.plot(kde_err[&#39;i&#39;], kde_err[&#39;ppm&#39;], c=&#39;r&#39;)

    #lock start at zero
    kde_err[&#39;ppm&#39;] = kde_err[&#39;ppm&#39;] - kde_err.loc[0,&#39;ppm&#39;]
    return kde_err</code></pre>
</details>
</dd>
<dt id="nhsmasslib.mass.ErrorTable.kernel_density_map"><code class="name flex">
<span>def <span class="ident">kernel_density_map</span></span>(<span>self, df_error:pandas.core.frame.DataFrame, ppm:float=3, show_map:bool=False) ><built-infunctionarray></span>
</code></dt>
<dd>
<div class="desc"><p>Plot kernel density map 100*100 for data</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>df_error</code></strong> :&ensp;<code>pd.Dataframe</code></dt>
<dd>error_table for generate kerle density map</dd>
<dt><strong><code>ppm</code></strong> :&ensp;<code>float</code></dt>
<dd>Optional. Default 3.
treshould for generate</dd>
<dt><strong><code>show_map</code></strong> :&ensp;<code>bool</code></dt>
<dd>Optional. Default True. plot kde</dd>
</dl>
<h2 id="return">Return</h2>
<p>numpy array 100*100 with generated kde</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def kernel_density_map(
    self, 
    df_error: pd.DataFrame, 
    ppm: float = 3, 
    show_map: bool = False
    ) -&gt; np.array:
    &#39;&#39;&#39;
    Plot kernel density map 100*100 for data

    Parameters
    ----------
    df_error: pd.Dataframe
        error_table for generate kerle density map
    ppm: float
        Optional. Default 3.
        treshould for generate
    show_map: bool
        Optional. Default True. plot kde

    Return
    ------
    numpy array 100*100 with generated kde
    &#39;&#39;&#39;
    
    x = np.array(df_error[&#39;mass&#39;])
    y = np.array(df_error[&#39;ppm&#39;])

    xmin = min(x) 
    xmax = max(x) 

    ymin = -ppm 
    ymax = ppm 

    xx, yy = np.mgrid[xmin:xmax:100j, ymin:ymax:100j]

    positions = np.vstack([xx.ravel(), yy.ravel()])
    values = np.vstack([x, y])
    kernel = st.gaussian_kde(values)
    f = np.reshape(kernel(positions).T, xx.shape)
    f = np.rot90(f)

    if show_map:
        fig = plt.figure(figsize=(4,4), dpi=75)
        ax = fig.gca()
        ax.set_xlim(xmin, xmax)
        ax.set_ylim(ymin, ymax)
        ax.imshow(f, extent=[xmin, xmax, ymin, ymax], aspect=&#39;auto&#39;)
    
    return f</code></pre>
</details>
</dd>
<dt id="nhsmasslib.mass.ErrorTable.massdiff_error"><code class="name flex">
<span>def <span class="ident">massdiff_error</span></span>(<span>self, spec:<a title="nhsmasslib.mass.MassSpectrum" href="#nhsmasslib.mass.MassSpectrum">MassSpectrum</a>, show_map:bool=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Self-recallibration of mass-spectra by mass-difference map</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>spec</code></strong> :&ensp;<code><a title="nhsmasslib.mass.MassSpectrum" href="#nhsmasslib.mass.MassSpectrum">MassSpectrum</a> object</code></dt>
<dd>Initial mass spectrum for recallibrate</dd>
<dt><strong><code>show_error</code></strong> :&ensp;<code>bool</code></dt>
<dd>Optional. Default True. Show process</dd>
</dl>
<h2 id="return">Return</h2>
<p>ErrorTable object that contain recallabrate error ppm for mass diaposone</p>
<h2 id="reference">Reference</h2>
<p>Smirnov, K. S., Forcisi, S., Moritz, F., Lucio, M., &amp; Schmitt-Kopplin, P.
(2019). Mass difference maps and their application for the
recalibration of mass spectrometric data in nontargeted metabolomics.
Analytical chemistry, 91(5), 3350-3358.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def massdiff_error(
    self,
    spec:MassSpectrum,
    show_map:bool = True):
    &#39;&#39;&#39;
    Self-recallibration of mass-spectra by mass-difference map

    Parameters
    -----------
    spec: MassSpectrum object
        Initial mass spectrum for recallibrate
    show_error: bool
        Optional. Default True. Show process 

    Return
    -------
    ErrorTable object that contain recallabrate error ppm for mass diaposone

    Reference
    ---------
    Smirnov, K. S., Forcisi, S., Moritz, F., Lucio, M., &amp; Schmitt-Kopplin, P. 
    (2019). Mass difference maps and their application for the 
    recalibration of mass spectrometric data in nontargeted metabolomics. 
    Analytical chemistry, 91(5), 3350-3358. 
    &#39;&#39;&#39;
    spec_table = copy.deepcopy(spec)
    mde = self.md_error_map(spec = spec_table, show_map=show_map)
    f = self.kernel_density_map(df_error=mde)
    err = self.fit_kernel(f=f, show_map=show_map)
    err[&#39;mass&#39;] = np.linspace(spec.table[&#39;mass&#39;].min(), spec.table[&#39;mass&#39;].max(),len(err))

    return ErrorTable(err)</code></pre>
</details>
</dd>
<dt id="nhsmasslib.mass.ErrorTable.md_error_map"><code class="name flex">
<span>def <span class="ident">md_error_map</span></span>(<span>self, spec:<a title="nhsmasslib.mass.MassSpectrum" href="#nhsmasslib.mass.MassSpectrum">MassSpectrum</a>, ppm:float=5, show_map:bool=True) >pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate mass differnce map</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>spec</code></strong> :&ensp;<code>pd.Dataframe</code></dt>
<dd>Dataframe with spectrum table from MassSpectrum</dd>
<dt><strong><code>ppm</code></strong> :&ensp;<code>float</code></dt>
<dd>Optional. Default 5.
Permissible error in ppm</dd>
<dt><strong><code>show_map</code></strong> :&ensp;<code>bool</code></dt>
<dd>Optional. Default True.
Show error in ppm versus mass</dd>
</dl>
<h2 id="return">Return</h2>
<p>Pandas Dataframe object with calculated error map</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def md_error_map(
    self, 
    spec: &#34;MassSpectrum&#34;, 
    ppm: float = 5, 
    show_map: bool = True
    ) -&gt; pd.DataFrame:
    &#39;&#39;&#39;
    Calculate mass differnce map

    Parameters
    ----------
    spec: pd.Dataframe
        Dataframe with spectrum table from MassSpectrum
    ppm: float
        Optional. Default 5.
        Permissible error in ppm
    show_map: bool
        Optional. Default True.
        Show error in ppm versus mass

    Return
    ------
    Pandas Dataframe object with calculated error map
    &#39;&#39;&#39;

    dif = self.dif_mass()

    data = copy.deepcopy(spec.table)
    masses = data[&#39;mass&#39;].values

    data = data.sort_values(by=&#39;intensity&#39;, ascending=False).reset_index(drop=True)
    if len(data) &gt; 1000:
        data = data[:1000]
    data = data.sort_values(by=&#39;mass&#39;).reset_index(drop=True)

    data_error = [] #array for new data

    for index, row in tqdm(data.iterrows(), total=len(data)): #take every mass in list
        
        mass = row[&#34;mass&#34;]

        for i in dif:
            mz = mass + i #massdif

            idx = np.searchsorted(masses, mz, side=&#39;left&#39;)                
            if idx &gt; 0 and (idx == len(masses) or np.fabs(mz - masses[idx - 1]) &lt; np.fabs(mz - masses[idx])):
                idx -= 1

            if np.fabs(masses[idx] - mz) / mz * 1e6 &lt;= ppm:
                data_error.append([mass, (masses[idx] - mz)/mz*1000000])
    
    df_error = pd.DataFrame(data = data_error, columns=[&#39;mass&#39;, &#39;ppm&#39; ])
    
    if show_map:
        fig, ax = plt.subplots(figsize=(4, 4), dpi=75)
        ax.scatter(df_error[&#39;mass&#39;], df_error[&#39;ppm&#39;], s=0.01)

    return df_error</code></pre>
</details>
</dd>
<dt id="nhsmasslib.mass.ErrorTable.show_error"><code class="name flex">
<span>def <span class="ident">show_error</span></span>(<span>self) >None</span>
</code></dt>
<dd>
<div class="desc"><p>Plot error map from ErrorTable data</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show_error(self) -&gt; None:
    &#34;&#34;&#34;
    Plot error map from ErrorTable data
    &#34;&#34;&#34;
    fig, ax = plt.subplots(figsize=(4,4), dpi=75)
    ax.plot(self.table[&#39;mass&#39;], self.table[&#39;ppm&#39;])
    ax.set_xlabel(&#39;m/z, Da&#39;)
    ax.set_ylabel(&#39;error, ppm&#39;)</code></pre>
</details>
</dd>
<dt id="nhsmasslib.mass.ErrorTable.zeroshift"><code class="name flex">
<span>def <span class="ident">zeroshift</span></span>(<span>self, spec:<a title="nhsmasslib.mass.MassSpectrum" href="#nhsmasslib.mass.MassSpectrum">MassSpectrum</a>) ><a title="nhsmasslib.mass.ErrorTable" href="#nhsmasslib.mass.ErrorTable">ErrorTable</a></span>
</code></dt>
<dd>
<div class="desc"><p>Shift error so mean eror will be zero</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>spec</code></strong> :&ensp;<code><a title="nhsmasslib.mass.MassSpectrum" href="#nhsmasslib.mass.MassSpectrum">MassSpectrum</a> object</code></dt>
<dd>income massspec</dd>
</dl>
<h2 id="return">Return</h2>
<p>ErrorTable object with shifted ppm error</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def zeroshift(self, spec:&#34;MassSpectrum&#34;) -&gt; &#34;ErrorTable&#34;:
    &#34;&#34;&#34;
    Shift error so mean eror will be zero

    Parameters
    ----------
    spec: MassSpectrum object
        income massspec

    Return
    ------
    ErrorTable object with shifted ppm error
    &#34;&#34;&#34;
    err = copy.deepcopy(self)
    mean_error = spec.drop_unassigned().calculate_error()[&#39;rel_error&#39;].mean()
    err.table[&#39;ppm&#39;] = err.table[&#39;ppm&#39;] - mean_error
    return ErrorTable(err.table)       </code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="nhsmasslib.mass.MassSpectrum"><code class="flex name class">
<span>class <span class="ident">MassSpectrum</span></span>
<span>(</span><span>table:pandas.core.frame.DataFrame=None, elems:Sequence[str]=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A class used to represent mass spectrum</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>table</code></strong> :&ensp;<code>pandas Datarame</code></dt>
<dd>Optional. consist spectrum (mass and intensity of peaks) and all calculated parameters
like brutto formulas, calculated mass, relative errorr</dd>
<dt><strong><code>elems</code></strong> :&ensp;<code>list</code></dt>
<dd>Optional. Consist elements that used for mass spectrum treatment
can be finded by class method find_elems()</dd>
</dl>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>table</code></strong> :&ensp;<code>pandas Datarame</code></dt>
<dd>Optional. Consist spectrum (mass and intensity of peaks) and all calculated
parameters like brutto formulas, calculated mass, relative errorr</dd>
<dt><strong><code>elems</code></strong> :&ensp;<code>list</code></dt>
<dd>Optional. Consist elements that used for mass spectrum treatment
can be finded by class method find_elems()</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MassSpectrum(object):
    &#34;&#34;&#34; 
    A class used to represent mass spectrum

    Attributes
    ----------
    table : pandas Datarame
        Optional. consist spectrum (mass and intensity of peaks) and all calculated parameters
        like brutto formulas, calculated mass, relative errorr
    elems : list
        Optional. Consist elements that used for mass spectrum treatment
        can be finded by class method find_elems()
    &#34;&#34;&#34;

    def __init__(
                self,
                table: pd.DataFrame = None,
                elems: Sequence[str] = None,
                ) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        Parameters
        ----------
        table : pandas Datarame
            Optional. Consist spectrum (mass and intensity of peaks) and all calculated 
            parameters like brutto formulas, calculated mass, relative errorr
        elems : list
            Optional. Consist elements that used for mass spectrum treatment
            can be finded by class method find_elems()
        &#34;&#34;&#34;

        self.features = [&#34;mass&#34;, &#34;calculated_mass&#34;, &#39;intensity&#39;, &#34;abs_error&#34;, &#34;rel_error&#34;]

        if table is not None:
            self.table = table
        else:
            self.table = pd.DataFrame(columns=[&#39;intensity&#39;, &#34;mass&#34;, &#34;brutto&#34;, &#34;calculated_mass&#34;, &#34;abs_error&#34;, &#34;rel_error&#34;])

        if elems is not None:
            self.elems = elems
        else:
            self.elems = self.find_elems()

    def find_elems(self) -&gt; Sequence[str]:
        &#34;&#34;&#34; 
        Find elems from mass spectrum table.

        Find elements in table columns. Used elems_mass_table with all elements and isotopes.
        For example, element &#39;C&#39; will be recognised as carbon 12C, element &#39;C_13&#34; as 13C

        Returns
        -------
        list of found elemets in columns label. For example: [&#39;C&#39;,&#39;H&#39;,&#39;O&#39;,&#39;N&#39;]
        &#34;&#34;&#34;

        main_elems = elements_table()[&#39;element&#39;].values
        all_elems = elements_table()[&#39;element_isotop&#39;].values

        elems = []
        for col in self.table.columns:
            if col in main_elems:
                elems.append(col)
            elif col in all_elems:
                elems.append(col)

        if len(elems) == 0:
            elems = None

        return elems

    def load(
        self,
        filename: Union[Path, str],
        mapper: Mapping[str, str] = None,
        ignore_columns: Sequence[str] = None,
        take_columns: Sequence[str] = None,
        take_only_mz: Sequence[str] = False,
        sep: str = &#34;,&#34;,
        intens_min: float =  None,
        intens_max: float = None,
        mass_min: float =  None,
        mass_max: float = None,
    ) -&gt; &#34;MassSpectrum&#34;:
        &#34;&#34;&#34;
        Load mass pectrum table to MassSpectrum object

        All parameters is optional except filename

        Parameters
        ----------
        filename: str
            path to mass spectrum table, absoulute or relative
        mapper: dict
            dictonary for recognize columns in mass spec file. 
            Example: {&#39;m/z&#39;:&#39;mass&#39;,&#39;I&#39;:&#39;intensity&#39;}
        ignore_columns: list of str
            list with names of columns that willn&#39;t loaded.
            if None load all columns.
            Example: [&#34;index&#34;, &#34;s/n&#34;]
        take_columns: list of str
            list with names of columns that only will be loaded.
            if None load all columns.
            Example: [&#34;mass&#34;, &#34;intensity&#34;, &#34;C&#34;, &#34;H&#34;, &#34;N&#34;, &#34;O&#34;]
        take_only_mz: bool
            load only mass and intesivity columns
        sep: str
            separator in mass spectrum table, \\t - for tab.
        intens_min: numeric
            bottom limit for intensivity.
            by default None and don&#39;t restrict by this.
            But for some spectrum it is necessary to cut noise.
        intens_max: numeric
            upper limit for intensivity.
            by default None and don&#39;t restrict by this
        mass_min: numeric
            bottom limit for m/z.
            by default None and don&#39;t restrict by this
        mass_max: numeric
            upper limit for m/z.
            by default None and don&#39;t restrict by this

        Return
        ------
        MassSpectrum object
        &#34;&#34;&#34;

        self.table = pd.read_csv(filename, sep=sep)
        if mapper:
            self.table = self.table.rename(columns=mapper)

        if take_columns:
            self.table = self.table.loc[:,take_columns]

        if ignore_columns:
            self.table = self.table.drop(columns=ignore_columns)

        if take_only_mz:
            self.table = self.table.loc[:,[&#39;mass&#39;,&#39;intensity&#39;]]

        if intens_min is not None:
            self.table = self.table.loc[self.table[&#39;intensity&#39;]&gt;intens_min]

        if intens_max is not None:
            self.table = self.table.loc[self.table[&#39;intensity&#39;]&lt;intens_max]

        if mass_min is not None:
            self.table = self.table.loc[self.table[&#39;mass&#39;]&gt;mass_min]

        if mass_max is not None:
            self.table = self.table.loc[self.table[&#39;mass&#39;]&lt;mass_max]

        self.elems = self.find_elems()

        if self.elems is not None:
            self._mark_assigned_by_brutto()

        self.table = self.table.reset_index(drop=True)

        return self

    def _mark_assigned_by_brutto(self) -&gt; None:
        &#34;&#34;&#34;Mark paeks in loaded mass list if they have brutto

        Return
        ------
        MassSpectrum object with assigned mark
        &#34;&#34;&#34;

        assign = []
        for i, row in self.table.iterrows():
            flag = False
            for el in self.elems:
                if row[el] &gt; 0:
                    flag = True
            assign.append(flag) 
        self.table[&#39;assign&#39;] = assign

    def save(self, filename: Union[Path, str], sep: str = &#34;,&#34;) -&gt; None:
        &#34;&#34;&#34;
        Saves to csv MassSpectrum
        
        Parameters
        ----------
        filename: str
            Path for saving mass spectrum table with calculation to csv file
        sep: str
            Optional. Separator in saved file. By default it is &#39;,&#39;        
        &#34;&#34;&#34;
        self.table.to_csv(filename, sep=sep, index=False)

    def assign(
            self,
            generated_bruttos_table: pd.DataFrame = None,
            rel_error: float = 0.5,
            sign: str =&#39;-&#39;
    ) -&gt; &#34;MassSpectrum&#34;:
        &#34;&#34;&#34;
        Finding the nearest mass in generated_bruttos_table
        
        Parameters
        -----------
        generated_bruttos_table: pandas DataFrame 
            Optional. Contain column &#39;mass&#39; and elements, 
            should be sorted by &#39;mass&#39;.
            Can be generated by function brutto_generator.brutto_gen(). 
            if &#39;None&#39; generate table with default elemnets and ranges
            C: 0-40, H 0-80, O 0-40, N 0-2
        rel_error: float
            Optional? default 0.5, permissible error in ppm for assign mass to brutto formulas
        sign: str
            Optional. Deafult &#39;-&#39;.
            Mode in which mass spectrum was gotten. 
            &#39;-&#39; for negative mode
            &#39;+&#39; for positive mode
            None for neutral

        Return
        ------
        MassSpectra object with assigned signals
        &#34;&#34;&#34;

        if generated_bruttos_table is None:
            generated_bruttos_table = brutto_gen()

        table = self.table.loc[:,[&#39;mass&#39;, &#39;intensity&#39;]].copy()

        masses = generated_bruttos_table[&#34;mass&#34;].values
        
        if sign == &#39;-&#39;:
            mass_shift = - 0.00054858 + 1.007825  # electron and hydrogen mass
        elif sign == &#39;+&#39;:
            mass_shift = 0.00054858  # electron mass
        else:
            mass_shift = 0

        elems = list(generated_bruttos_table.drop(columns=[&#34;mass&#34;]))
        bruttos = generated_bruttos_table[elems].values.tolist()

        res = []
        for index, row in table.iterrows():
            mass = row[&#34;mass&#34;] + mass_shift
            idx = np.searchsorted(masses, mass, side=&#39;left&#39;)
            if idx &gt; 0 and (idx == len(masses) or np.fabs(mass - masses[idx - 1]) &lt; np.fabs(mass - masses[idx])):
                idx -= 1

            if np.fabs(masses[idx] - mass) / mass * 1e6 &lt;= rel_error:
                res.append({**dict(zip(elems, bruttos[idx])), &#34;assign&#34;: True})
            else:
                res.append({&#34;assign&#34;: False})

        res = pd.DataFrame(res)

        return MassSpectrum(table.join(res), elems=elems)

    def filter_by_C13(
        self, 
        rel_error: float = 0.5,
        remove: bool = False,
    ) -&gt; &#39;MassSpectrum&#39;:
        &#34;&#34;&#34; 
        C13 isotope peak checking

        Parameters
        ----------
        rel_error: float
            Optional. Default 0.5.
            Allowable ppm error when checking c13 isotope peak
        remove: bool
            Optional, default False. 
            if True peakes without C13 isotopes peak will be dropped
        
        Return
        ------
        MassSpectra object with cleaned or checked mass-signals
        &#34;&#34;&#34;

        table = self.table.sort_values(by=&#39;mass&#39;).reset_index(drop=True)
        
        flags = np.zeros(table.shape[0], dtype=bool)
        masses = table[&#34;mass&#34;].values
        
        C13_C12 = 1.003355  # C13 - C12 mass difference

        
        for index, row in table.iterrows():
            mass = row[&#34;mass&#34;] + C13_C12
            error = mass * rel_error * 0.000001

            idx = np.searchsorted(masses, mass, side=&#39;left&#39;)
            
            if idx &gt; 0 and (idx == len(masses) or np.fabs(mass - masses[idx - 1]) &lt; np.fabs(mass - masses[idx])):
                idx -= 1
            
            if np.fabs(masses[idx] - mass)  &lt;= error:
                flags[index] = True
        
        table[&#39;C13_peak&#39;] = flags

        if remove:
            table = table.loc[(table[&#39;C13_peak&#39;] == True) &amp; (table[&#39;assign&#39;] == True)].reset_index(drop=True)

        return MassSpectrum(table)

    def calculate_brutto(self) -&gt; &#39;MassSpectrum&#39;:
        &#34;&#34;&#34;
        Calculate brutto formulas from assign table

        Return
        ------
        MassSpectrum object wit calculated bruttos
        &#34;&#34;&#34;

        table = copy.deepcopy(self.table)

        elems = self.find_elems()
        out = []
        for i, row in table.iterrows():
            s = &#39;&#39;
            for el in elems:
                if row[el] == 1:
                    s = s + f&#39;{el}&#39;
                elif row[el] &gt; 0:
                    s = s + f&#39;{el}{int(row[el])}&#39;
            out.append(s)
        
        table[&#39;brutto&#39;] = out

        return MassSpectrum(table)

    def copy(self) -&gt; &#39;MassSpectrum&#39;:
        &#34;&#34;&#34;
        Deepcopy of self MassSpectrum object

        Return
        ------
        Deepcopy of self MassSpectrum object
        &#34;&#34;&#34;
        return copy.deepcopy(MassSpectrum(self.table))

    def calculate_error(self, sign: str =&#39;-&#39;) -&gt; &#34;MassSpectrum&#34;:
        &#34;&#34;&#34;
        Calculate relative and absolute error of assigned peaks

        Parameters
        ----------
        sign: str
            Optional. Default &#39;-&#39;. 
            Mode in which mass spectrum was gotten. 
            &#39;-&#39; for negative mode
            &#39;+&#39; for positive mode
            None for neutral
        
        Return
        ------
        MassSpectrum object wit calculated error
        &#34;&#34;&#34;
        if &#34;calculated_mass&#34; not in self.table:
            table = self.calculate_mass().table
        else:
            table = copy.deepcopy(self.table)

        if sign == &#39;-&#39;:
            table[&#34;abs_error&#34;] = table[&#34;mass&#34;] - table[&#34;calculated_mass&#34;] + (- 0.00054858 + 1.007825) #-electron + proton
        elif sign == &#39;+&#39;:
            table[&#34;abs_error&#34;] = table[&#34;mass&#34;] - table[&#34;calculated_mass&#34;] + 0.00054858 #+electron
        else:
            table[&#34;abs_error&#34;] = table[&#34;mass&#34;] - table[&#34;calculated_mass&#34;]
        
        table[&#34;rel_error&#34;] = table[&#34;abs_error&#34;] / table[&#34;mass&#34;] * 1e6

        return MassSpectrum(table)

    def show_error(self) -&gt; None:
        &#34;&#34;&#34;
        Plot relative error of assigned brutto formulas vs mass
        &#34;&#34;&#34;

        if &#34;rel_error&#34; not in self.table:
            self = self.calculate_error()      

        fig, ax = plt.subplots(figsize=(4, 4), dpi=75)
        ax.scatter(self.table[&#39;mass&#39;], self.table[&#39;rel_error&#39;], s=0.1)
        ax.set_xlabel(&#39;m/z, Da&#39;)
        ax.set_ylabel(&#39;error, ppm&#39;)

    def calculate_mass(self) -&gt; &#34;MassSpectrum&#34;:
        &#34;&#34;&#34;
        Calculate mass from assigned brutto formulas

        Return
        ------
        MassSpectrum object with calculated mass
        &#34;&#34;&#34;

        if &#34;assign&#34; not in self.table:
            raise SpectrumIsNotAssigned()
        
        table = copy.deepcopy(self.table)
        self.elems = self.find_elems()
        
        table = table.loc[:,self.elems]
        
        masses = get_elements_masses(self.elems)

        self.table[&#34;calculated_mass&#34;] = table.multiply(masses).sum(axis=1)
        self.table[&#34;calculated_mass&#34;] = np.round(self.table[&#34;calculated_mass&#34;], 6)
        self.table.loc[self.table[&#34;calculated_mass&#34;] == 0, &#34;calculated_mass&#34;] = np.NaN

        return MassSpectrum(self.table)
    
    def __repr__(self) -&gt; str:
        &#34;&#34;&#34;
        Representation of MassSpectrum object.

        Return
        ------
        the string representation of MassSpectrum object
        &#34;&#34;&#34;

        columns = [column for column in self.features if column in self.table]
        return self.table[columns].__repr__()

    def __str__(self) -&gt; str:
        &#34;&#34;&#34;
        Representation of MassSpectrum object.

        Return
        ------
        the string representation of MassSpectrum object
        &#34;&#34;&#34;
        columns = [column for column in self.features if column in self.table]
        return self.table[columns].__str__()

    def __or__(self: &#34;MassSpectrum&#34;, other: &#34;MassSpectrum&#34;) -&gt; &#34;MassSpectrum&#34;:
        &#34;&#34;&#34;
        Logic function or for two MassSpectrum object

        Work by calculated mass from brutto formulas

        Return
        ------
        MassSpectrum object contain all assigned brutto formulas from two spectrum
        &#34;&#34;&#34;
        
        if &#34;calculated_mass&#34; not in self.table:
            e = copy.deepcopy(self.calculate_mass())
        else:
            e = copy.deepcopy(self)
        if &#34;calculated_mass&#34; not in other.table:
            s = copy.deepcopy(other.calculate_mass())
        else:
            s = copy.deepcopy(other)

        a = e.table.dropna()
        b = s.table.dropna()
        
        a = a.append(b, ignore_index=True)
        a = a.drop_duplicates(subset=[&#39;calculated_mass&#39;])

        return MassSpectrum(a)

    def __xor__(self: &#34;MassSpectrum&#34;, other: &#34;MassSpectrum&#34;) -&gt; &#34;MassSpectrum&#34;:
        &#34;&#34;&#34;
        Logic function xor for two MassSpectrum object

        Work by calculated mass from brutto formulas

        Return
        ------
        MassSpectrum object contain xor assigned brutto formulas from two spectrum
        &#34;&#34;&#34;

        other2 = copy.deepcopy(self)
        sub1 = self.__sub__(other)
        sub2 = other.__sub__(other2)
        
        return sub1.__or__(sub2)

    def __and__(self: &#34;MassSpectrum&#34;, other: &#34;MassSpectrum&#34;) -&gt; &#34;MassSpectrum&#34;:
        &#34;&#34;&#34;
        Logic function and for two MassSpectrum object

        Work by calculated mass from brutto formulas

        Return
        ------
        MassSpectrum object contain common assigned brutto formulas from two spectrum
        &#34;&#34;&#34;

        if &#34;calculated_mass&#34; not in self.table:
            e = copy.deepcopy(self.calculate_mass())
        else:
            e = copy.deepcopy(self)
        if &#34;calculated_mass&#34; not in other.table:
            s = copy.deepcopy(other.calculate_mass())
        else:
            s = copy.deepcopy(other)

        a = e.table[&#39;calculated_mass&#39;].dropna().values
        b = s.table[&#39;calculated_mass&#39;].dropna().values
        
        operate = set(a) &amp; set(b)

        mark = []
        res = copy.deepcopy(self.table)
        for i, row in res.iterrows():
            if row[&#39;calculated_mass&#39;] in operate:
                mark.append(row[&#39;calculated_mass&#39;])
            else:
                mark.append(np.NaN)
        res[&#39;calculated_mass&#39;] = mark
        res = res.dropna()

        return MassSpectrum(res)

    def __add__(self: &#34;MassSpectrum&#34;, other: &#34;MassSpectrum&#34;) -&gt; &#34;MassSpectrum&#34;:
        &#34;&#34;&#34;
        Logic function or for two MassSpectrum object

        Work by calculated mass from brutto formulas

        Return
        ------
        MassSpectrum object contain all assigned brutto formulas from two spectrum
        &#34;&#34;&#34;
        return self.__or__(other)

    def __sub__(self, other):
        &#34;&#34;&#34;
        Logic function substraction for two MassSpectrum object

        Work by calculated mass from brutto formulas

        Return
        ------
        MassSpectrum object contain substraction assigned brutto formulas from two spectrum
        &#34;&#34;&#34;
        
        if &#34;calculated_mass&#34; not in self.table:
            e = copy.deepcopy(self.calculate_mass())
        else:
            e = copy.deepcopy(self)
        if &#34;calculated_mass&#34; not in other.table:
            s = copy.deepcopy(other.calculate_mass())
        else:
            s = copy.deepcopy(other)

        a = e.table[&#39;calculated_mass&#39;].dropna().values
        b = s.table[&#39;calculated_mass&#39;].dropna().values
        
        operate = set(a) - set(b)

        mark = []
        res = copy.deepcopy(self.table)
        for i, row in res.iterrows():
            if row[&#39;calculated_mass&#39;] in operate:
                mark.append(row[&#39;calculated_mass&#39;])
            else:
                mark.append(np.NaN)
        res[&#39;calculated_mass&#39;] = mark
        res = res.dropna()

        return MassSpectrum(res)

    def intens_sub(self, other:&#34;MassSpectrum&#34;) -&gt; &#34;MassSpectrum&#34;:
        &#34;&#34;&#34;
        Calculate substruction by intensivity

        Parameters
        ----------
        other: MassSpectrum object
            other mass-scpectrum

        Return
        ------
        MassSpectrum object contain only that peak
        that higher than in other. And intensity of this peaks
        is substraction of self and other.
        &#34;&#34;&#34;
        #find common masses
        m = self &amp; other
        msc = m.table[&#39;calculated_mass&#39;].values

        #extract table with common masses
        massE = self.table[&#39;calculated_mass&#39;].values
        rE = self.table[np.isin(massE, msc)]
        massL = other.table[&#39;calculated_mass&#39;].values
        rL = other.table[np.isin(massL, msc)]

        #substract intensity each others
        rE = rE.copy()
        rE[&#39;intensity&#39;] = rE[&#39;intensity&#39;] - rL[&#39;intensity&#39;]
        rE = rE.loc[rE[&#39;intensity&#39;] &gt; 0]
        
        #and add only own molecules
        return (self - other) + MassSpectrum(rE)  

    def __len__(self) -&gt; int:
        &#34;&#34;&#34;
        Length of Mass-Spectrum table

        Return
        ------
        int - length of Mass-Spectrum table
        &#34;&#34;&#34;
        return len(self.table)
    
    def __getitem__(self, item: Union[str, Sequence[str]]) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        Get items or slice from spec

        Return
        ------
        Pandas Dataframe or Series slices
        &#34;&#34;&#34;

        return self.table[item]

    def drop_unassigned(self) -&gt; &#34;MassSpectrum&#34;:
        &#34;&#34;&#34;
        Drop unassigned mass from Mass Spectrum table

        Return
        ------
        MassSpectrum object that contain only assigned by brutto formulas peaks

        Caution
        -------
        Danger of lose data - with these operation we exclude data that can be usefull
        &#34;&#34;&#34;

        if &#34;assign&#34; not in self.table:
            raise SpectrumIsNotAssigned()

        return MassSpectrum(self.table.loc[self.table[&#34;assign&#34;] == True].reset_index(drop=True))

    def calculate_simmilarity(self, other:&#34;MassSpectrum&#34;, mode:str=&#39;cosine&#39;) -&gt; float:
        &#34;&#34;&#34;
        Calculate Simmilarity

        Parameters
        ----------
        other: MassSpectrum object
            second MaasSpectrum object with that calc simmilarity
        mode: str
            Optionaly. Default cosine. 
            one of the similarity functions
            Mode can be: &#34;tanimoto&#34;, &#34;jaccard&#34;, &#34;cosine&#34;

        Return
        ------
        float Simmilarity index
        &#34;&#34;&#34;

        if &#39;calculated_mass&#39; not in self.table:
            self = self.calculate_mass()
        if &#39;calculated_mass&#39; not in other.table:
            other = other.calculate_mass()

        a = self.table[&#39;calculated_mass&#39;].dropna().values
        b = other.table[&#39;calculated_mass&#39;].dropna().values
        c = np.union1d(a, b)

        A = np.zeros(len(c), dtype=bool)
        B = np.zeros(len(c), dtype=bool)
        for i, el in enumerate(c):
            if el in a:
                A[i] = True
            if el in b:
                B[i] = True

        if mode == &#34;jaccard&#34;:
            return 1 - spatial.distance.jaccard(A, B)
        elif mode == &#34;tanimoto&#34;:
            return 1 - spatial.distance.rogerstanimoto(A, B)
        elif mode == &#39;cosine&#39;:
            return 1 - spatial.distance.cosine(A, B)
        else:
            raise Exception(f&#34;There is no such mode: {mode}&#34;)

    def calculate_cram(self) -&gt; &#34;MassSpectrum&#34;:
        &#34;&#34;&#34;
        Calculate if include into CRAM
        (carboxylic-rich alicyclic molecules)

        Return
        ------
        MassSpectrun object with check CRAM (bool)

        Reference
        ---------
        Hertkorn, N. et al. Characterization of a major 
        refractory component of marine dissolved organic matter.
        Geochimica et. Cosmochimica Acta 70, 2990-3010 (2006)
        &#34;&#34;&#34;
        spec = self.copy()
        if &#34;DBE&#34; not in spec.table:
            spec = spec.calculate_dbe()

        def check(row):
            if row[&#39;DBE&#39;]/row[&#39;C&#39;] &lt; 0.3 or row[&#39;DBE&#39;]/row[&#39;C&#39;] &gt; 0.68:
                return False
            if row[&#39;DBE&#39;]/row[&#39;H&#39;] &lt; 0.2 or row[&#39;DBE&#39;]/row[&#39;H&#39;] &gt; 0.95:
                return False
            if row[&#39;O&#39;] == 0:
                False
            elif row[&#39;DBE&#39;]/row[&#39;O&#39;] &lt; 0.77 or row[&#39;DBE&#39;]/row[&#39;O&#39;] &gt; 1.75:
                return False
            return True

        spec.table[&#39;CRAM&#39;] = spec.table.apply(check, axis=1)

        return spec

    def get_cram_value(self) -&gt; int:
        &#34;&#34;&#34;
        Calculate percent of CRAM molecules
        (carboxylic-rich alicyclic molecules)

        Return
        ------
        int. percent of CRAM molecules in mass-spec
        weight by intensity
        &#34;&#34;&#34;
        spec = self.copy()
        if &#34;CRAM&#34; not in spec.table:
            spec = spec.calculate_cram().drop_unassigned()

        value = spec.table.loc[spec.table[&#39;CRAM&#39;] == True, &#39;intensity&#39;].sum()/spec.table[&#39;intensity&#39;].sum()
        return int(value*100)

    def calculate_ai(self) -&gt; &#39;MassSpectrum&#39;:
        &#34;&#34;&#34;
        Calculate AI

        Return
        ------
        MassSpectrum object with calculated AI
        &#34;&#34;&#34;
        table = self.calculate_cai().calculate_dbe_ai().table
        table[&#34;AI&#34;] = table[&#34;DBE_AI&#34;] / table[&#34;CAI&#34;]

        return MassSpectrum(table)

    def calculate_cai(self) -&gt; &#39;MassSpectrum&#39;:
        &#34;&#34;&#34;
        Calculate CAI

        Return
        ------
        MassSpectrum object with calculated CAI
        &#34;&#34;&#34;
        
        if &#34;assign&#34; not in self.table:
            raise SpectrumIsNotAssigned()

        table = copy.deepcopy(self.table)

        # very careful
        # anyway it&#39;s necessary to have at least column with C?
        for element in &#34;CONSP&#34;:
            if element not in table:
                table[element] = 0

        self.table[&#39;CAI&#39;] = table[&#34;C&#34;] - table[&#34;O&#34;] - table[&#34;N&#34;] - table[&#34;S&#34;] - table[&#34;P&#34;]

        return self

    def calculate_dbe_ai(self) -&gt; &#39;MassSpectrum&#39;:
        &#34;&#34;&#34;
        Calculate DBE

        Return
        ------
        MassSpectrum object with calculated DBE
        &#34;&#34;&#34;
        if &#34;assign&#34; not in self.table:
            raise SpectrumIsNotAssigned()

        table = copy.deepcopy(self.table)

        for element in &#34;CHONPS&#34;:
            if element not in table:
                table[element] = 0

        self.table[&#39;DBE_AI&#39;] = 1.0 + table[&#34;C&#34;] - table[&#34;O&#34;] - table[&#34;S&#34;] - 0.5 * (table[&#34;H&#34;] + table[&#39;N&#39;] + table[&#34;P&#34;])

        return self

    def calculate_dbe(self) -&gt; &#39;MassSpectrum&#39;:
        &#34;&#34;&#34;
        Calculate DBE

        Return
        ------
        MassSpectrum object with calculated DBE
        &#34;&#34;&#34;
        if &#34;assign&#34; not in self.table:
            raise SpectrumIsNotAssigned()

        table = copy.deepcopy(self.table)

        for element in &#34;CHON&#34;:
            if element not in table:
                table[element] = 0

        self.table[&#39;DBE&#39;] = 1.0 + table[&#34;C&#34;] - 0.5 * (table[&#34;H&#34;] - table[&#39;N&#39;])

        return self

    def normalize(self) -&gt; &#39;MassSpectrum&#39;:
        &#34;&#34;&#34;
        Intensity normalize by max intensity
        
        Return
        ------
        Intensity normalized by max intensity MassSpectrum instance
        &#34;&#34;&#34;
        table = self.table.copy()
        table[&#39;intensity&#39;] /= table[&#39;intensity&#39;].max()
        return MassSpectrum(table)

    def head(self, num:int = None) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        Show head of mass spec table

        Parameters
        ----------
        num: int
            Optional. number of head string

        Return
        ------
        Pandas Dataframe head of MassSpec table
        &#34;&#34;&#34;
        if num is None:
            return self.table.head()
        else:
            return self.table.head(num)

    def tail(self, num:int = None) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        Show tail of mass spec table

        Parameters
        ----------
        num: int
            Optional. number of tail string

        Return
        ------
        Pandas Dataframe tail of MassSpec table
        &#34;&#34;&#34;
        if num is None:
            return self.table.tail()
        else:
            return self.table.tail(num)

    def draw(self,
        xlim: Tuple[Optional[float], Optional[float]] = (None, None),
        ylim: Tuple[Optional[float], Optional[float]] = (None, None),
        color: str = &#39;black&#39;,
        ax: plt.axes = None,
        ) -&gt; None:
        &#34;&#34;&#34;
        Draw mass spectrum

        All parameters is optional

        Parameters
        ----------
        xlim: Tuple (float, float)
            restrict for mass
        ylim: Tuple (float, float)
            restrict for intensity
        color: str
            color of draw
        ax: matplotlyp axes object
            send here ax to plot in your own condition
        &#34;&#34;&#34;

        df = self.table.sort_values(by=&#34;mass&#34;)

        mass = df.mass.values
        if xlim[0] is None:
            xlim = (mass.min(), xlim[1])
        if xlim[1] is None:
            xlim = (xlim[0], mass.max())

        intensity = df[&#39;intensity&#39;].values
        # filter first intensity and only after mass (because we will lose the information)
        intensity = intensity[(xlim[0] &lt;= mass) &amp; (mass &lt;= xlim[1])]
        mass = mass[(xlim[0] &lt;= mass) &amp; (mass &lt;= xlim[1])]

        # bas solution, probably it&#39;s needed to rewrite this piece
        M = np.zeros((len(mass), 3))
        M[:, 0] = mass
        M[:, 1] = mass
        M[:, 2] = mass
        M = M.reshape(-1)

        I = np.zeros((len(intensity), 3))
        I[:, 1] = intensity
        I = I.reshape(-1)

        if ax is None:
            fig, ax = plt.subplots(figsize=(4,4), dpi=75)
    
        ax.plot(M, I, color=color, linewidth=0.2)
        ax.plot([xlim[0], xlim[1]], [0, 0], color=color, linewidth=0.2)
        ax.set_xlim(xlim)
        ax.set_ylim(ylim)
        ax.set_xlabel(&#39;m/z, Da&#39;)
        ax.set_ylabel(&#39;Intensity&#39;)
        ax.set_title(f&#39;{len(self.table)} peaks&#39;)

        return

    def recallibrate(self, error_table: &#34;ErrorTable&#34; = None, how = &#39;assign&#39;) -&gt; &#34;MassSpectrum&#34;:
        &#39;&#39;&#39;
        Recallibrate data by error-table

        Parameters
        ----------
        error_table: ErrorTable object
            Optional. If None - calculate for self. 
            ErrorTable object contain table error in ppm for mass, default 100 string            

        how: str
            Optional. Default &#39;assign&#39;.
            If error_table is None we can choose how to recalculate.
            &#39;assign&#39; - by assign error, default.
            &#39;mdm&#39; - by calculation mass-difference map.
            filename - path to etalon spectrum, treated and saved by masslib

        Returns
        -------
        MassSpectrum object with recallibrated mass
        &#39;&#39;&#39;
        if error_table is None:
            if how == &#39;assign&#39;:
                if &#34;assign&#34; not in self.table:
                    raise SpectrumIsNotAssigned()
                error_table = ErrorTable().assign_error(self).zeroshift(self)
            elif how == &#39;mdm&#39;:
                error_table = ErrorTable().massdiff_error(self)
            else:
                etalon = MassSpectrum().load(filename=how)
                error_table = ErrorTable().etalon_error(spec=self, etalon=etalon)

        err = copy.deepcopy(error_table.table)
        data = self.table.reset_index(drop=True)
        wide = len(err)

        data[&#39;old_mass&#39;] = data[&#39;mass&#39;]

        min_mass = err[&#39;mass&#39;].min()
        max_mass = err[&#39;mass&#39;].max()
        a = np.linspace(min_mass, max_mass, wide+1)

        for i in range(wide):
            for ind in data.loc[(data[&#39;mass&#39;]&gt;a[i]) &amp; (data[&#39;mass&#39;]&lt;a[i+1])].index:
                mass = data.loc[ind, &#39;mass&#39;]
                e = mass * err.loc[i, &#39;ppm&#39;] / 1000000
                data.loc[ind, &#39;mass&#39;] = data.loc[ind, &#39;mass&#39;] + e
                
        return MassSpectrum(data)

    def assign_by_tmds (
        self, 
        tmds_spec: &#34;Tmds&#34; = None, 
        abs_error: float = 0.001,
        p = 0.2,
        max_num: int = None,
        C13_filter: bool = True
        ) -&gt; &#34;MassSpectrum&#34;:
        &#39;&#39;&#39;
        Assigne brutto formulas by TMDS

        Parameters
        ----------
        tmds_spec: Tmds object
            Optional. if None generate tmds spectr with default parameters
            Tmds object, include table with most probability mass difference
        abs_error: float
            Optional, default 0.001. Error for assign peaks by massdif
        p: float
            Optional. Default 0.2. 
            Relative probability coefficient for treshold tmds spectrum
        max_num: int
            Optional. Max mass diff numbers
        C13_filter: bool
            Use only peaks with C13 isotope peak for generate tmds

        Return
        ------
        MassSpectrum object new assign brutto formulas
        &#39;&#39;&#39;
        if &#34;assign&#34; not in self.table:
            raise SpectrumIsNotAssigned()

        if tmds_spec is None:
            tmds_spec = Tmds().calc(self, p=p, C13_filter=C13_filter) #by varifiy p-value we can choose how much mass-diff we will take
            tmds_spec = tmds_spec.assign(max_num=max_num)
            tmds_spec = tmds_spec.calculate_mass()

        tmds = tmds_spec.table.sort_values(by=&#39;probability&#39;, ascending=False).reset_index(drop=True)
        tmds = tmds.loc[tmds[&#39;probability&#39;] &gt; p]
        elem = tmds_spec.elems

        spec = copy.deepcopy(self)
        
        assign_false = copy.deepcopy(spec.table.loc[spec.table[&#39;assign&#39;] == False]).reset_index(drop=True)
        assign_true = copy.deepcopy(spec.table.loc[spec.table[&#39;assign&#39;] == True]).reset_index(drop=True)
        masses = assign_true[&#39;mass&#39;].values
        mass_dif_num = len(tmds)

        for i, row_tmds in tqdm(tmds.iterrows(), total=mass_dif_num):

            mass_shift = - row_tmds[&#39;calculated_mass&#39;]
            
            for index, row in assign_false.iterrows():
                if row[&#39;assign&#39;] == True:
                    continue
                     
                mass = row[&#34;mass&#34;] + mass_shift
                idx = np.searchsorted(masses, mass, side=&#39;left&#39;)
                if idx &gt; 0 and (idx == len(masses) or np.fabs(mass - masses[idx - 1]) &lt; np.fabs(mass - masses[idx])):
                    idx -= 1

                if np.fabs(masses[idx] - mass) &lt;= abs_error:
                    assign_false.loc[index,&#39;assign&#39;] = True
                    for el in elem:
                        assign_false.loc[index,el] = row_tmds[el] + assign_true.loc[idx,el]

        assign_true = assign_true.append(assign_false, ignore_index=True).sort_values(by=&#39;mass&#39;).reset_index(drop=True)

        out = MassSpectrum(assign_true)
        out = out.calculate_error()
        
        out_false = out.table.loc[out.table[&#39;assign&#39;] == False]
        out_true = out.table.loc[out.table[&#39;assign&#39;] == True].drop_duplicates(subset=&#34;calculated_mass&#34;)

        out2 = pd.merge(out_true, out_false, how=&#39;outer&#39;).reset_index(drop=True).sort_values(by=&#39;mass&#39;).reset_index(drop=True)
        
        return MassSpectrum(out2)

    def calculate_DBEvsO(self, ax=None, olim=None, **kwargs) -&gt; None:
        &#34;&#34;&#34;
        DBE by nO
        
        Paramters
        ---------
        ax: matplotlib axes
            ax fo outer plot. Default None
        olim: tuple of two int
            limit for nO. Deafult None
        **kwargs: dict
            dict for additional condition to scatter method 

        References
        ----------
        Bae, E., Yeo, I. J., Jeong, B., Shin, Y., Shin, K. H., &amp; Kim, S. (2011). 
        Study of double bond equivalents and the numbers of carbon and oxygen 
        atom distribution of dissolved organic matter with negative-mode FT-ICR MS.
        Analytical chemistry, 83(11), 4193-4199.
        
        &#34;&#34;&#34;

        spec = self.copy().calculate_dbe().drop_unassigned()
        if olim is None:
            no = list(range(5, int(spec.table[&#39;O&#39;].max())-4))
        else:
            no = list(range(olim[0],olim[1]))

        dbe_o = []
        
        for i in no:
            dbes = spec.table.loc[spec.table[&#39;O&#39;] == i, &#39;DBE&#39;]
            intens = spec.table.loc[spec.table[&#39;O&#39;] == i, &#39;intensity&#39;]
            dbe_o.append((dbes*intens).sum()/intens.sum())
    
        def linear(x, a, b):
            return a*x + b

        x = np.array(no)
        y = np.array(dbe_o)

        popt, pcov = curve_fit(linear, x, y)
        residuals = y- linear(x, *popt)
        ss_res = np.sum(residuals**2)
        ss_tot = np.sum((y-np.mean(y))**2)
        r_squared = 1 - (ss_res / ss_tot)

        if ax is None:
            fig,ax = plt.subplots(figsize=(3,3), dpi=100)
        
        ax.scatter(x, y, **kwargs)
        ax.plot(x, linear(x, *popt), label=f&#39;y={round(popt[0],2)}x + {round(popt[1],1)} R2={round(r_squared, 4)}&#39;, **kwargs)
        ax.set_xlim(4)
        ax.set_ylim(5)
        ax.set_xlabel(&#39;number of oxygen&#39;)
        ax.set_ylabel(&#39;DBE average&#39;)
        ax.legend()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="nhsmasslib.mass.MassSpectrum.assign"><code class="name flex">
<span>def <span class="ident">assign</span></span>(<span>self, generated_bruttos_table:pandas.core.frame.DataFrame=None, rel_error:float=0.5, sign:str='-') ><a title="nhsmasslib.mass.MassSpectrum" href="#nhsmasslib.mass.MassSpectrum">MassSpectrum</a></span>
</code></dt>
<dd>
<div class="desc"><p>Finding the nearest mass in generated_bruttos_table</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>generated_bruttos_table</code></strong> :&ensp;<code>pandas DataFrame </code></dt>
<dd>Optional. Contain column 'mass' and elements,
should be sorted by 'mass'.
Can be generated by function brutto_generator.brutto_gen().
if 'None' generate table with default elemnets and ranges
C: 0-40, H 0-80, O 0-40, N 0-2</dd>
<dt><strong><code>rel_error</code></strong> :&ensp;<code>float</code></dt>
<dd>Optional? default 0.5, permissible error in ppm for assign mass to brutto formulas</dd>
<dt><strong><code>sign</code></strong> :&ensp;<code>str</code></dt>
<dd>Optional. Deafult '-'.
Mode in which mass spectrum was gotten.
'-' for negative mode
'+' for positive mode
None for neutral</dd>
</dl>
<h2 id="return">Return</h2>
<p>MassSpectra object with assigned signals</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assign(
        self,
        generated_bruttos_table: pd.DataFrame = None,
        rel_error: float = 0.5,
        sign: str =&#39;-&#39;
) -&gt; &#34;MassSpectrum&#34;:
    &#34;&#34;&#34;
    Finding the nearest mass in generated_bruttos_table
    
    Parameters
    -----------
    generated_bruttos_table: pandas DataFrame 
        Optional. Contain column &#39;mass&#39; and elements, 
        should be sorted by &#39;mass&#39;.
        Can be generated by function brutto_generator.brutto_gen(). 
        if &#39;None&#39; generate table with default elemnets and ranges
        C: 0-40, H 0-80, O 0-40, N 0-2
    rel_error: float
        Optional? default 0.5, permissible error in ppm for assign mass to brutto formulas
    sign: str
        Optional. Deafult &#39;-&#39;.
        Mode in which mass spectrum was gotten. 
        &#39;-&#39; for negative mode
        &#39;+&#39; for positive mode
        None for neutral

    Return
    ------
    MassSpectra object with assigned signals
    &#34;&#34;&#34;

    if generated_bruttos_table is None:
        generated_bruttos_table = brutto_gen()

    table = self.table.loc[:,[&#39;mass&#39;, &#39;intensity&#39;]].copy()

    masses = generated_bruttos_table[&#34;mass&#34;].values
    
    if sign == &#39;-&#39;:
        mass_shift = - 0.00054858 + 1.007825  # electron and hydrogen mass
    elif sign == &#39;+&#39;:
        mass_shift = 0.00054858  # electron mass
    else:
        mass_shift = 0

    elems = list(generated_bruttos_table.drop(columns=[&#34;mass&#34;]))
    bruttos = generated_bruttos_table[elems].values.tolist()

    res = []
    for index, row in table.iterrows():
        mass = row[&#34;mass&#34;] + mass_shift
        idx = np.searchsorted(masses, mass, side=&#39;left&#39;)
        if idx &gt; 0 and (idx == len(masses) or np.fabs(mass - masses[idx - 1]) &lt; np.fabs(mass - masses[idx])):
            idx -= 1

        if np.fabs(masses[idx] - mass) / mass * 1e6 &lt;= rel_error:
            res.append({**dict(zip(elems, bruttos[idx])), &#34;assign&#34;: True})
        else:
            res.append({&#34;assign&#34;: False})

    res = pd.DataFrame(res)

    return MassSpectrum(table.join(res), elems=elems)</code></pre>
</details>
</dd>
<dt id="nhsmasslib.mass.MassSpectrum.assign_by_tmds"><code class="name flex">
<span>def <span class="ident">assign_by_tmds</span></span>(<span>self, tmds_spec:<a title="nhsmasslib.mass.Tmds" href="#nhsmasslib.mass.Tmds">Tmds</a>=None, abs_error:float=0.001, p=0.2, max_num:int=None, C13_filter:bool=True) ><a title="nhsmasslib.mass.MassSpectrum" href="#nhsmasslib.mass.MassSpectrum">MassSpectrum</a></span>
</code></dt>
<dd>
<div class="desc"><p>Assigne brutto formulas by TMDS</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>tmds_spec</code></strong> :&ensp;<code><a title="nhsmasslib.mass.Tmds" href="#nhsmasslib.mass.Tmds">Tmds</a> object</code></dt>
<dd>Optional. if None generate tmds spectr with default parameters
Tmds object, include table with most probability mass difference</dd>
<dt><strong><code>abs_error</code></strong> :&ensp;<code>float</code></dt>
<dd>Optional, default 0.001. Error for assign peaks by massdif</dd>
<dt><strong><code>p</code></strong> :&ensp;<code>float</code></dt>
<dd>Optional. Default 0.2.
Relative probability coefficient for treshold tmds spectrum</dd>
<dt><strong><code>max_num</code></strong> :&ensp;<code>int</code></dt>
<dd>Optional. Max mass diff numbers</dd>
<dt><strong><code>C13_filter</code></strong> :&ensp;<code>bool</code></dt>
<dd>Use only peaks with C13 isotope peak for generate tmds</dd>
</dl>
<h2 id="return">Return</h2>
<p>MassSpectrum object new assign brutto formulas</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assign_by_tmds (
    self, 
    tmds_spec: &#34;Tmds&#34; = None, 
    abs_error: float = 0.001,
    p = 0.2,
    max_num: int = None,
    C13_filter: bool = True
    ) -&gt; &#34;MassSpectrum&#34;:
    &#39;&#39;&#39;
    Assigne brutto formulas by TMDS

    Parameters
    ----------
    tmds_spec: Tmds object
        Optional. if None generate tmds spectr with default parameters
        Tmds object, include table with most probability mass difference
    abs_error: float
        Optional, default 0.001. Error for assign peaks by massdif
    p: float
        Optional. Default 0.2. 
        Relative probability coefficient for treshold tmds spectrum
    max_num: int
        Optional. Max mass diff numbers
    C13_filter: bool
        Use only peaks with C13 isotope peak for generate tmds

    Return
    ------
    MassSpectrum object new assign brutto formulas
    &#39;&#39;&#39;
    if &#34;assign&#34; not in self.table:
        raise SpectrumIsNotAssigned()

    if tmds_spec is None:
        tmds_spec = Tmds().calc(self, p=p, C13_filter=C13_filter) #by varifiy p-value we can choose how much mass-diff we will take
        tmds_spec = tmds_spec.assign(max_num=max_num)
        tmds_spec = tmds_spec.calculate_mass()

    tmds = tmds_spec.table.sort_values(by=&#39;probability&#39;, ascending=False).reset_index(drop=True)
    tmds = tmds.loc[tmds[&#39;probability&#39;] &gt; p]
    elem = tmds_spec.elems

    spec = copy.deepcopy(self)
    
    assign_false = copy.deepcopy(spec.table.loc[spec.table[&#39;assign&#39;] == False]).reset_index(drop=True)
    assign_true = copy.deepcopy(spec.table.loc[spec.table[&#39;assign&#39;] == True]).reset_index(drop=True)
    masses = assign_true[&#39;mass&#39;].values
    mass_dif_num = len(tmds)

    for i, row_tmds in tqdm(tmds.iterrows(), total=mass_dif_num):

        mass_shift = - row_tmds[&#39;calculated_mass&#39;]
        
        for index, row in assign_false.iterrows():
            if row[&#39;assign&#39;] == True:
                continue
                 
            mass = row[&#34;mass&#34;] + mass_shift
            idx = np.searchsorted(masses, mass, side=&#39;left&#39;)
            if idx &gt; 0 and (idx == len(masses) or np.fabs(mass - masses[idx - 1]) &lt; np.fabs(mass - masses[idx])):
                idx -= 1

            if np.fabs(masses[idx] - mass) &lt;= abs_error:
                assign_false.loc[index,&#39;assign&#39;] = True
                for el in elem:
                    assign_false.loc[index,el] = row_tmds[el] + assign_true.loc[idx,el]

    assign_true = assign_true.append(assign_false, ignore_index=True).sort_values(by=&#39;mass&#39;).reset_index(drop=True)

    out = MassSpectrum(assign_true)
    out = out.calculate_error()
    
    out_false = out.table.loc[out.table[&#39;assign&#39;] == False]
    out_true = out.table.loc[out.table[&#39;assign&#39;] == True].drop_duplicates(subset=&#34;calculated_mass&#34;)

    out2 = pd.merge(out_true, out_false, how=&#39;outer&#39;).reset_index(drop=True).sort_values(by=&#39;mass&#39;).reset_index(drop=True)
    
    return MassSpectrum(out2)</code></pre>
</details>
</dd>
<dt id="nhsmasslib.mass.MassSpectrum.calculate_DBEvsO"><code class="name flex">
<span>def <span class="ident">calculate_DBEvsO</span></span>(<span>self, ax=None, olim=None, **kwargs) >None</span>
</code></dt>
<dd>
<div class="desc"><p>DBE by nO</p>
<h2 id="paramters">Paramters</h2>
<p>ax: matplotlib axes
ax fo outer plot. Default None
olim: tuple of two int
limit for nO. Deafult None
**kwargs: dict
dict for additional condition to scatter method </p>
<h2 id="references">References</h2>
<p>Bae, E., Yeo, I. J., Jeong, B., Shin, Y., Shin, K. H., &amp; Kim, S. (2011).
Study of double bond equivalents and the numbers of carbon and oxygen
atom distribution of dissolved organic matter with negative-mode FT-ICR MS.
Analytical chemistry, 83(11), 4193-4199.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate_DBEvsO(self, ax=None, olim=None, **kwargs) -&gt; None:
    &#34;&#34;&#34;
    DBE by nO
    
    Paramters
    ---------
    ax: matplotlib axes
        ax fo outer plot. Default None
    olim: tuple of two int
        limit for nO. Deafult None
    **kwargs: dict
        dict for additional condition to scatter method 

    References
    ----------
    Bae, E., Yeo, I. J., Jeong, B., Shin, Y., Shin, K. H., &amp; Kim, S. (2011). 
    Study of double bond equivalents and the numbers of carbon and oxygen 
    atom distribution of dissolved organic matter with negative-mode FT-ICR MS.
    Analytical chemistry, 83(11), 4193-4199.
    
    &#34;&#34;&#34;

    spec = self.copy().calculate_dbe().drop_unassigned()
    if olim is None:
        no = list(range(5, int(spec.table[&#39;O&#39;].max())-4))
    else:
        no = list(range(olim[0],olim[1]))

    dbe_o = []
    
    for i in no:
        dbes = spec.table.loc[spec.table[&#39;O&#39;] == i, &#39;DBE&#39;]
        intens = spec.table.loc[spec.table[&#39;O&#39;] == i, &#39;intensity&#39;]
        dbe_o.append((dbes*intens).sum()/intens.sum())

    def linear(x, a, b):
        return a*x + b

    x = np.array(no)
    y = np.array(dbe_o)

    popt, pcov = curve_fit(linear, x, y)
    residuals = y- linear(x, *popt)
    ss_res = np.sum(residuals**2)
    ss_tot = np.sum((y-np.mean(y))**2)
    r_squared = 1 - (ss_res / ss_tot)

    if ax is None:
        fig,ax = plt.subplots(figsize=(3,3), dpi=100)
    
    ax.scatter(x, y, **kwargs)
    ax.plot(x, linear(x, *popt), label=f&#39;y={round(popt[0],2)}x + {round(popt[1],1)} R2={round(r_squared, 4)}&#39;, **kwargs)
    ax.set_xlim(4)
    ax.set_ylim(5)
    ax.set_xlabel(&#39;number of oxygen&#39;)
    ax.set_ylabel(&#39;DBE average&#39;)
    ax.legend()</code></pre>
</details>
</dd>
<dt id="nhsmasslib.mass.MassSpectrum.calculate_ai"><code class="name flex">
<span>def <span class="ident">calculate_ai</span></span>(<span>self) ><a title="nhsmasslib.mass.MassSpectrum" href="#nhsmasslib.mass.MassSpectrum">MassSpectrum</a></span>
</code></dt>
<dd>
<div class="desc"><p>Calculate AI</p>
<h2 id="return">Return</h2>
<p>MassSpectrum object with calculated AI</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate_ai(self) -&gt; &#39;MassSpectrum&#39;:
    &#34;&#34;&#34;
    Calculate AI

    Return
    ------
    MassSpectrum object with calculated AI
    &#34;&#34;&#34;
    table = self.calculate_cai().calculate_dbe_ai().table
    table[&#34;AI&#34;] = table[&#34;DBE_AI&#34;] / table[&#34;CAI&#34;]

    return MassSpectrum(table)</code></pre>
</details>
</dd>
<dt id="nhsmasslib.mass.MassSpectrum.calculate_brutto"><code class="name flex">
<span>def <span class="ident">calculate_brutto</span></span>(<span>self) ><a title="nhsmasslib.mass.MassSpectrum" href="#nhsmasslib.mass.MassSpectrum">MassSpectrum</a></span>
</code></dt>
<dd>
<div class="desc"><p>Calculate brutto formulas from assign table</p>
<h2 id="return">Return</h2>
<p>MassSpectrum object wit calculated bruttos</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate_brutto(self) -&gt; &#39;MassSpectrum&#39;:
    &#34;&#34;&#34;
    Calculate brutto formulas from assign table

    Return
    ------
    MassSpectrum object wit calculated bruttos
    &#34;&#34;&#34;

    table = copy.deepcopy(self.table)

    elems = self.find_elems()
    out = []
    for i, row in table.iterrows():
        s = &#39;&#39;
        for el in elems:
            if row[el] == 1:
                s = s + f&#39;{el}&#39;
            elif row[el] &gt; 0:
                s = s + f&#39;{el}{int(row[el])}&#39;
        out.append(s)
    
    table[&#39;brutto&#39;] = out

    return MassSpectrum(table)</code></pre>
</details>
</dd>
<dt id="nhsmasslib.mass.MassSpectrum.calculate_cai"><code class="name flex">
<span>def <span class="ident">calculate_cai</span></span>(<span>self) ><a title="nhsmasslib.mass.MassSpectrum" href="#nhsmasslib.mass.MassSpectrum">MassSpectrum</a></span>
</code></dt>
<dd>
<div class="desc"><p>Calculate CAI</p>
<h2 id="return">Return</h2>
<p>MassSpectrum object with calculated CAI</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate_cai(self) -&gt; &#39;MassSpectrum&#39;:
    &#34;&#34;&#34;
    Calculate CAI

    Return
    ------
    MassSpectrum object with calculated CAI
    &#34;&#34;&#34;
    
    if &#34;assign&#34; not in self.table:
        raise SpectrumIsNotAssigned()

    table = copy.deepcopy(self.table)

    # very careful
    # anyway it&#39;s necessary to have at least column with C?
    for element in &#34;CONSP&#34;:
        if element not in table:
            table[element] = 0

    self.table[&#39;CAI&#39;] = table[&#34;C&#34;] - table[&#34;O&#34;] - table[&#34;N&#34;] - table[&#34;S&#34;] - table[&#34;P&#34;]

    return self</code></pre>
</details>
</dd>
<dt id="nhsmasslib.mass.MassSpectrum.calculate_cram"><code class="name flex">
<span>def <span class="ident">calculate_cram</span></span>(<span>self) ><a title="nhsmasslib.mass.MassSpectrum" href="#nhsmasslib.mass.MassSpectrum">MassSpectrum</a></span>
</code></dt>
<dd>
<div class="desc"><p>Calculate if include into CRAM
(carboxylic-rich alicyclic molecules)</p>
<h2 id="return">Return</h2>
<p>MassSpectrun object with check CRAM (bool)</p>
<h2 id="reference">Reference</h2>
<p>Hertkorn, N. et al. Characterization of a major
refractory component of marine dissolved organic matter.
Geochimica et. Cosmochimica Acta 70, 2990-3010 (2006)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate_cram(self) -&gt; &#34;MassSpectrum&#34;:
    &#34;&#34;&#34;
    Calculate if include into CRAM
    (carboxylic-rich alicyclic molecules)

    Return
    ------
    MassSpectrun object with check CRAM (bool)

    Reference
    ---------
    Hertkorn, N. et al. Characterization of a major 
    refractory component of marine dissolved organic matter.
    Geochimica et. Cosmochimica Acta 70, 2990-3010 (2006)
    &#34;&#34;&#34;
    spec = self.copy()
    if &#34;DBE&#34; not in spec.table:
        spec = spec.calculate_dbe()

    def check(row):
        if row[&#39;DBE&#39;]/row[&#39;C&#39;] &lt; 0.3 or row[&#39;DBE&#39;]/row[&#39;C&#39;] &gt; 0.68:
            return False
        if row[&#39;DBE&#39;]/row[&#39;H&#39;] &lt; 0.2 or row[&#39;DBE&#39;]/row[&#39;H&#39;] &gt; 0.95:
            return False
        if row[&#39;O&#39;] == 0:
            False
        elif row[&#39;DBE&#39;]/row[&#39;O&#39;] &lt; 0.77 or row[&#39;DBE&#39;]/row[&#39;O&#39;] &gt; 1.75:
            return False
        return True

    spec.table[&#39;CRAM&#39;] = spec.table.apply(check, axis=1)

    return spec</code></pre>
</details>
</dd>
<dt id="nhsmasslib.mass.MassSpectrum.calculate_dbe"><code class="name flex">
<span>def <span class="ident">calculate_dbe</span></span>(<span>self) ><a title="nhsmasslib.mass.MassSpectrum" href="#nhsmasslib.mass.MassSpectrum">MassSpectrum</a></span>
</code></dt>
<dd>
<div class="desc"><p>Calculate DBE</p>
<h2 id="return">Return</h2>
<p>MassSpectrum object with calculated DBE</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate_dbe(self) -&gt; &#39;MassSpectrum&#39;:
    &#34;&#34;&#34;
    Calculate DBE

    Return
    ------
    MassSpectrum object with calculated DBE
    &#34;&#34;&#34;
    if &#34;assign&#34; not in self.table:
        raise SpectrumIsNotAssigned()

    table = copy.deepcopy(self.table)

    for element in &#34;CHON&#34;:
        if element not in table:
            table[element] = 0

    self.table[&#39;DBE&#39;] = 1.0 + table[&#34;C&#34;] - 0.5 * (table[&#34;H&#34;] - table[&#39;N&#39;])

    return self</code></pre>
</details>
</dd>
<dt id="nhsmasslib.mass.MassSpectrum.calculate_dbe_ai"><code class="name flex">
<span>def <span class="ident">calculate_dbe_ai</span></span>(<span>self) ><a title="nhsmasslib.mass.MassSpectrum" href="#nhsmasslib.mass.MassSpectrum">MassSpectrum</a></span>
</code></dt>
<dd>
<div class="desc"><p>Calculate DBE</p>
<h2 id="return">Return</h2>
<p>MassSpectrum object with calculated DBE</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate_dbe_ai(self) -&gt; &#39;MassSpectrum&#39;:
    &#34;&#34;&#34;
    Calculate DBE

    Return
    ------
    MassSpectrum object with calculated DBE
    &#34;&#34;&#34;
    if &#34;assign&#34; not in self.table:
        raise SpectrumIsNotAssigned()

    table = copy.deepcopy(self.table)

    for element in &#34;CHONPS&#34;:
        if element not in table:
            table[element] = 0

    self.table[&#39;DBE_AI&#39;] = 1.0 + table[&#34;C&#34;] - table[&#34;O&#34;] - table[&#34;S&#34;] - 0.5 * (table[&#34;H&#34;] + table[&#39;N&#39;] + table[&#34;P&#34;])

    return self</code></pre>
</details>
</dd>
<dt id="nhsmasslib.mass.MassSpectrum.calculate_error"><code class="name flex">
<span>def <span class="ident">calculate_error</span></span>(<span>self, sign:str='-') ><a title="nhsmasslib.mass.MassSpectrum" href="#nhsmasslib.mass.MassSpectrum">MassSpectrum</a></span>
</code></dt>
<dd>
<div class="desc"><p>Calculate relative and absolute error of assigned peaks</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>sign</code></strong> :&ensp;<code>str</code></dt>
<dd>Optional. Default '-'.
Mode in which mass spectrum was gotten.
'-' for negative mode
'+' for positive mode
None for neutral</dd>
</dl>
<h2 id="return">Return</h2>
<p>MassSpectrum object wit calculated error</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate_error(self, sign: str =&#39;-&#39;) -&gt; &#34;MassSpectrum&#34;:
    &#34;&#34;&#34;
    Calculate relative and absolute error of assigned peaks

    Parameters
    ----------
    sign: str
        Optional. Default &#39;-&#39;. 
        Mode in which mass spectrum was gotten. 
        &#39;-&#39; for negative mode
        &#39;+&#39; for positive mode
        None for neutral
    
    Return
    ------
    MassSpectrum object wit calculated error
    &#34;&#34;&#34;
    if &#34;calculated_mass&#34; not in self.table:
        table = self.calculate_mass().table
    else:
        table = copy.deepcopy(self.table)

    if sign == &#39;-&#39;:
        table[&#34;abs_error&#34;] = table[&#34;mass&#34;] - table[&#34;calculated_mass&#34;] + (- 0.00054858 + 1.007825) #-electron + proton
    elif sign == &#39;+&#39;:
        table[&#34;abs_error&#34;] = table[&#34;mass&#34;] - table[&#34;calculated_mass&#34;] + 0.00054858 #+electron
    else:
        table[&#34;abs_error&#34;] = table[&#34;mass&#34;] - table[&#34;calculated_mass&#34;]
    
    table[&#34;rel_error&#34;] = table[&#34;abs_error&#34;] / table[&#34;mass&#34;] * 1e6

    return MassSpectrum(table)</code></pre>
</details>
</dd>
<dt id="nhsmasslib.mass.MassSpectrum.calculate_mass"><code class="name flex">
<span>def <span class="ident">calculate_mass</span></span>(<span>self) ><a title="nhsmasslib.mass.MassSpectrum" href="#nhsmasslib.mass.MassSpectrum">MassSpectrum</a></span>
</code></dt>
<dd>
<div class="desc"><p>Calculate mass from assigned brutto formulas</p>
<h2 id="return">Return</h2>
<p>MassSpectrum object with calculated mass</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate_mass(self) -&gt; &#34;MassSpectrum&#34;:
    &#34;&#34;&#34;
    Calculate mass from assigned brutto formulas

    Return
    ------
    MassSpectrum object with calculated mass
    &#34;&#34;&#34;

    if &#34;assign&#34; not in self.table:
        raise SpectrumIsNotAssigned()
    
    table = copy.deepcopy(self.table)
    self.elems = self.find_elems()
    
    table = table.loc[:,self.elems]
    
    masses = get_elements_masses(self.elems)

    self.table[&#34;calculated_mass&#34;] = table.multiply(masses).sum(axis=1)
    self.table[&#34;calculated_mass&#34;] = np.round(self.table[&#34;calculated_mass&#34;], 6)
    self.table.loc[self.table[&#34;calculated_mass&#34;] == 0, &#34;calculated_mass&#34;] = np.NaN

    return MassSpectrum(self.table)</code></pre>
</details>
</dd>
<dt id="nhsmasslib.mass.MassSpectrum.calculate_simmilarity"><code class="name flex">
<span>def <span class="ident">calculate_simmilarity</span></span>(<span>self, other:<a title="nhsmasslib.mass.MassSpectrum" href="#nhsmasslib.mass.MassSpectrum">MassSpectrum</a>, mode:str='cosine') >float</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate Simmilarity</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>other</code></strong> :&ensp;<code><a title="nhsmasslib.mass.MassSpectrum" href="#nhsmasslib.mass.MassSpectrum">MassSpectrum</a> object</code></dt>
<dd>second MaasSpectrum object with that calc simmilarity</dd>
<dt><strong><code>mode</code></strong> :&ensp;<code>str</code></dt>
<dd>Optionaly. Default cosine.
one of the similarity functions
Mode can be: "tanimoto", "jaccard", "cosine"</dd>
</dl>
<h2 id="return">Return</h2>
<p>float Simmilarity index</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate_simmilarity(self, other:&#34;MassSpectrum&#34;, mode:str=&#39;cosine&#39;) -&gt; float:
    &#34;&#34;&#34;
    Calculate Simmilarity

    Parameters
    ----------
    other: MassSpectrum object
        second MaasSpectrum object with that calc simmilarity
    mode: str
        Optionaly. Default cosine. 
        one of the similarity functions
        Mode can be: &#34;tanimoto&#34;, &#34;jaccard&#34;, &#34;cosine&#34;

    Return
    ------
    float Simmilarity index
    &#34;&#34;&#34;

    if &#39;calculated_mass&#39; not in self.table:
        self = self.calculate_mass()
    if &#39;calculated_mass&#39; not in other.table:
        other = other.calculate_mass()

    a = self.table[&#39;calculated_mass&#39;].dropna().values
    b = other.table[&#39;calculated_mass&#39;].dropna().values
    c = np.union1d(a, b)

    A = np.zeros(len(c), dtype=bool)
    B = np.zeros(len(c), dtype=bool)
    for i, el in enumerate(c):
        if el in a:
            A[i] = True
        if el in b:
            B[i] = True

    if mode == &#34;jaccard&#34;:
        return 1 - spatial.distance.jaccard(A, B)
    elif mode == &#34;tanimoto&#34;:
        return 1 - spatial.distance.rogerstanimoto(A, B)
    elif mode == &#39;cosine&#39;:
        return 1 - spatial.distance.cosine(A, B)
    else:
        raise Exception(f&#34;There is no such mode: {mode}&#34;)</code></pre>
</details>
</dd>
<dt id="nhsmasslib.mass.MassSpectrum.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self) ><a title="nhsmasslib.mass.MassSpectrum" href="#nhsmasslib.mass.MassSpectrum">MassSpectrum</a></span>
</code></dt>
<dd>
<div class="desc"><p>Deepcopy of self MassSpectrum object</p>
<h2 id="return">Return</h2>
<p>Deepcopy of self MassSpectrum object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self) -&gt; &#39;MassSpectrum&#39;:
    &#34;&#34;&#34;
    Deepcopy of self MassSpectrum object

    Return
    ------
    Deepcopy of self MassSpectrum object
    &#34;&#34;&#34;
    return copy.deepcopy(MassSpectrum(self.table))</code></pre>
</details>
</dd>
<dt id="nhsmasslib.mass.MassSpectrum.draw"><code class="name flex">
<span>def <span class="ident">draw</span></span>(<span>self, xlim:Tuple[Optional[float],Optional[float]]=(None, None), ylim:Tuple[Optional[float],Optional[float]]=(None, None), color:str='black', ax:<functionaxesat0x7f7f08d865e0>=None) >None</span>
</code></dt>
<dd>
<div class="desc"><p>Draw mass spectrum</p>
<p>All parameters is optional</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>xlim</code></strong> :&ensp;<code>Tuple (float, float)</code></dt>
<dd>restrict for mass</dd>
<dt><strong><code>ylim</code></strong> :&ensp;<code>Tuple (float, float)</code></dt>
<dd>restrict for intensity</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>str</code></dt>
<dd>color of draw</dd>
<dt><strong><code>ax</code></strong> :&ensp;<code>matplotlyp axes object</code></dt>
<dd>send here ax to plot in your own condition</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw(self,
    xlim: Tuple[Optional[float], Optional[float]] = (None, None),
    ylim: Tuple[Optional[float], Optional[float]] = (None, None),
    color: str = &#39;black&#39;,
    ax: plt.axes = None,
    ) -&gt; None:
    &#34;&#34;&#34;
    Draw mass spectrum

    All parameters is optional

    Parameters
    ----------
    xlim: Tuple (float, float)
        restrict for mass
    ylim: Tuple (float, float)
        restrict for intensity
    color: str
        color of draw
    ax: matplotlyp axes object
        send here ax to plot in your own condition
    &#34;&#34;&#34;

    df = self.table.sort_values(by=&#34;mass&#34;)

    mass = df.mass.values
    if xlim[0] is None:
        xlim = (mass.min(), xlim[1])
    if xlim[1] is None:
        xlim = (xlim[0], mass.max())

    intensity = df[&#39;intensity&#39;].values
    # filter first intensity and only after mass (because we will lose the information)
    intensity = intensity[(xlim[0] &lt;= mass) &amp; (mass &lt;= xlim[1])]
    mass = mass[(xlim[0] &lt;= mass) &amp; (mass &lt;= xlim[1])]

    # bas solution, probably it&#39;s needed to rewrite this piece
    M = np.zeros((len(mass), 3))
    M[:, 0] = mass
    M[:, 1] = mass
    M[:, 2] = mass
    M = M.reshape(-1)

    I = np.zeros((len(intensity), 3))
    I[:, 1] = intensity
    I = I.reshape(-1)

    if ax is None:
        fig, ax = plt.subplots(figsize=(4,4), dpi=75)

    ax.plot(M, I, color=color, linewidth=0.2)
    ax.plot([xlim[0], xlim[1]], [0, 0], color=color, linewidth=0.2)
    ax.set_xlim(xlim)
    ax.set_ylim(ylim)
    ax.set_xlabel(&#39;m/z, Da&#39;)
    ax.set_ylabel(&#39;Intensity&#39;)
    ax.set_title(f&#39;{len(self.table)} peaks&#39;)

    return</code></pre>
</details>
</dd>
<dt id="nhsmasslib.mass.MassSpectrum.drop_unassigned"><code class="name flex">
<span>def <span class="ident">drop_unassigned</span></span>(<span>self) ><a title="nhsmasslib.mass.MassSpectrum" href="#nhsmasslib.mass.MassSpectrum">MassSpectrum</a></span>
</code></dt>
<dd>
<div class="desc"><p>Drop unassigned mass from Mass Spectrum table</p>
<h2 id="return">Return</h2>
<p>MassSpectrum object that contain only assigned by brutto formulas peaks</p>
<h2 id="caution">Caution</h2>
<p>Danger of lose data - with these operation we exclude data that can be usefull</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def drop_unassigned(self) -&gt; &#34;MassSpectrum&#34;:
    &#34;&#34;&#34;
    Drop unassigned mass from Mass Spectrum table

    Return
    ------
    MassSpectrum object that contain only assigned by brutto formulas peaks

    Caution
    -------
    Danger of lose data - with these operation we exclude data that can be usefull
    &#34;&#34;&#34;

    if &#34;assign&#34; not in self.table:
        raise SpectrumIsNotAssigned()

    return MassSpectrum(self.table.loc[self.table[&#34;assign&#34;] == True].reset_index(drop=True))</code></pre>
</details>
</dd>
<dt id="nhsmasslib.mass.MassSpectrum.filter_by_C13"><code class="name flex">
<span>def <span class="ident">filter_by_C13</span></span>(<span>self, rel_error:float=0.5, remove:bool=False) ><a title="nhsmasslib.mass.MassSpectrum" href="#nhsmasslib.mass.MassSpectrum">MassSpectrum</a></span>
</code></dt>
<dd>
<div class="desc"><p>C13 isotope peak checking</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>rel_error</code></strong> :&ensp;<code>float</code></dt>
<dd>Optional. Default 0.5.
Allowable ppm error when checking c13 isotope peak</dd>
<dt><strong><code>remove</code></strong> :&ensp;<code>bool</code></dt>
<dd>Optional, default False.
if True peakes without C13 isotopes peak will be dropped</dd>
</dl>
<h2 id="return">Return</h2>
<p>MassSpectra object with cleaned or checked mass-signals</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter_by_C13(
    self, 
    rel_error: float = 0.5,
    remove: bool = False,
) -&gt; &#39;MassSpectrum&#39;:
    &#34;&#34;&#34; 
    C13 isotope peak checking

    Parameters
    ----------
    rel_error: float
        Optional. Default 0.5.
        Allowable ppm error when checking c13 isotope peak
    remove: bool
        Optional, default False. 
        if True peakes without C13 isotopes peak will be dropped
    
    Return
    ------
    MassSpectra object with cleaned or checked mass-signals
    &#34;&#34;&#34;

    table = self.table.sort_values(by=&#39;mass&#39;).reset_index(drop=True)
    
    flags = np.zeros(table.shape[0], dtype=bool)
    masses = table[&#34;mass&#34;].values
    
    C13_C12 = 1.003355  # C13 - C12 mass difference

    
    for index, row in table.iterrows():
        mass = row[&#34;mass&#34;] + C13_C12
        error = mass * rel_error * 0.000001

        idx = np.searchsorted(masses, mass, side=&#39;left&#39;)
        
        if idx &gt; 0 and (idx == len(masses) or np.fabs(mass - masses[idx - 1]) &lt; np.fabs(mass - masses[idx])):
            idx -= 1
        
        if np.fabs(masses[idx] - mass)  &lt;= error:
            flags[index] = True
    
    table[&#39;C13_peak&#39;] = flags

    if remove:
        table = table.loc[(table[&#39;C13_peak&#39;] == True) &amp; (table[&#39;assign&#39;] == True)].reset_index(drop=True)

    return MassSpectrum(table)</code></pre>
</details>
</dd>
<dt id="nhsmasslib.mass.MassSpectrum.find_elems"><code class="name flex">
<span>def <span class="ident">find_elems</span></span>(<span>self) >Sequence[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Find elems from mass spectrum table.</p>
<p>Find elements in table columns. Used elems_mass_table with all elements and isotopes.
For example, element 'C' will be recognised as carbon 12C, element 'C_13" as 13C</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code> of <code>found elemets in columns label. For example: ['C','H','O','N']</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_elems(self) -&gt; Sequence[str]:
    &#34;&#34;&#34; 
    Find elems from mass spectrum table.

    Find elements in table columns. Used elems_mass_table with all elements and isotopes.
    For example, element &#39;C&#39; will be recognised as carbon 12C, element &#39;C_13&#34; as 13C

    Returns
    -------
    list of found elemets in columns label. For example: [&#39;C&#39;,&#39;H&#39;,&#39;O&#39;,&#39;N&#39;]
    &#34;&#34;&#34;

    main_elems = elements_table()[&#39;element&#39;].values
    all_elems = elements_table()[&#39;element_isotop&#39;].values

    elems = []
    for col in self.table.columns:
        if col in main_elems:
            elems.append(col)
        elif col in all_elems:
            elems.append(col)

    if len(elems) == 0:
        elems = None

    return elems</code></pre>
</details>
</dd>
<dt id="nhsmasslib.mass.MassSpectrum.get_cram_value"><code class="name flex">
<span>def <span class="ident">get_cram_value</span></span>(<span>self) >int</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate percent of CRAM molecules
(carboxylic-rich alicyclic molecules)</p>
<h2 id="return">Return</h2>
<p>int. percent of CRAM molecules in mass-spec
weight by intensity</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_cram_value(self) -&gt; int:
    &#34;&#34;&#34;
    Calculate percent of CRAM molecules
    (carboxylic-rich alicyclic molecules)

    Return
    ------
    int. percent of CRAM molecules in mass-spec
    weight by intensity
    &#34;&#34;&#34;
    spec = self.copy()
    if &#34;CRAM&#34; not in spec.table:
        spec = spec.calculate_cram().drop_unassigned()

    value = spec.table.loc[spec.table[&#39;CRAM&#39;] == True, &#39;intensity&#39;].sum()/spec.table[&#39;intensity&#39;].sum()
    return int(value*100)</code></pre>
</details>
</dd>
<dt id="nhsmasslib.mass.MassSpectrum.head"><code class="name flex">
<span>def <span class="ident">head</span></span>(<span>self, num:int=None) >pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Show head of mass spec table</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>num</code></strong> :&ensp;<code>int</code></dt>
<dd>Optional. number of head string</dd>
</dl>
<h2 id="return">Return</h2>
<p>Pandas Dataframe head of MassSpec table</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def head(self, num:int = None) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    Show head of mass spec table

    Parameters
    ----------
    num: int
        Optional. number of head string

    Return
    ------
    Pandas Dataframe head of MassSpec table
    &#34;&#34;&#34;
    if num is None:
        return self.table.head()
    else:
        return self.table.head(num)</code></pre>
</details>
</dd>
<dt id="nhsmasslib.mass.MassSpectrum.intens_sub"><code class="name flex">
<span>def <span class="ident">intens_sub</span></span>(<span>self, other:<a title="nhsmasslib.mass.MassSpectrum" href="#nhsmasslib.mass.MassSpectrum">MassSpectrum</a>) ><a title="nhsmasslib.mass.MassSpectrum" href="#nhsmasslib.mass.MassSpectrum">MassSpectrum</a></span>
</code></dt>
<dd>
<div class="desc"><p>Calculate substruction by intensivity</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>other</code></strong> :&ensp;<code><a title="nhsmasslib.mass.MassSpectrum" href="#nhsmasslib.mass.MassSpectrum">MassSpectrum</a> object</code></dt>
<dd>other mass-scpectrum</dd>
</dl>
<h2 id="return">Return</h2>
<p>MassSpectrum object contain only that peak
that higher than in other. And intensity of this peaks
is substraction of self and other.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def intens_sub(self, other:&#34;MassSpectrum&#34;) -&gt; &#34;MassSpectrum&#34;:
    &#34;&#34;&#34;
    Calculate substruction by intensivity

    Parameters
    ----------
    other: MassSpectrum object
        other mass-scpectrum

    Return
    ------
    MassSpectrum object contain only that peak
    that higher than in other. And intensity of this peaks
    is substraction of self and other.
    &#34;&#34;&#34;
    #find common masses
    m = self &amp; other
    msc = m.table[&#39;calculated_mass&#39;].values

    #extract table with common masses
    massE = self.table[&#39;calculated_mass&#39;].values
    rE = self.table[np.isin(massE, msc)]
    massL = other.table[&#39;calculated_mass&#39;].values
    rL = other.table[np.isin(massL, msc)]

    #substract intensity each others
    rE = rE.copy()
    rE[&#39;intensity&#39;] = rE[&#39;intensity&#39;] - rL[&#39;intensity&#39;]
    rE = rE.loc[rE[&#39;intensity&#39;] &gt; 0]
    
    #and add only own molecules
    return (self - other) + MassSpectrum(rE)  </code></pre>
</details>
</dd>
<dt id="nhsmasslib.mass.MassSpectrum.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>self, filename:Union[pathlib.Path,str], mapper:Mapping[str,str]=None, ignore_columns:Sequence[str]=None, take_columns:Sequence[str]=None, take_only_mz:Sequence[str]=False, sep:str=',', intens_min:float=None, intens_max:float=None, mass_min:float=None, mass_max:float=None) ><a title="nhsmasslib.mass.MassSpectrum" href="#nhsmasslib.mass.MassSpectrum">MassSpectrum</a></span>
</code></dt>
<dd>
<div class="desc"><p>Load mass pectrum table to MassSpectrum object</p>
<p>All parameters is optional except filename</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code></dt>
<dd>path to mass spectrum table, absoulute or relative</dd>
<dt><strong><code>mapper</code></strong> :&ensp;<code>dict</code></dt>
<dd>dictonary for recognize columns in mass spec file.
Example: {'m/z':'mass','I':'intensity'}</dd>
<dt><strong><code>ignore_columns</code></strong> :&ensp;<code>list</code> of <code>str</code></dt>
<dd>list with names of columns that willn't loaded.
if None load all columns.
Example: ["index", "s/n"]</dd>
<dt><strong><code>take_columns</code></strong> :&ensp;<code>list</code> of <code>str</code></dt>
<dd>list with names of columns that only will be loaded.
if None load all columns.
Example: ["mass", "intensity", "C", "H", "N", "O"]</dd>
<dt><strong><code>take_only_mz</code></strong> :&ensp;<code>bool</code></dt>
<dd>load only mass and intesivity columns</dd>
<dt><strong><code>sep</code></strong> :&ensp;<code>str</code></dt>
<dd>separator in mass spectrum table, \t - for tab.</dd>
<dt><strong><code>intens_min</code></strong> :&ensp;<code>numeric</code></dt>
<dd>bottom limit for intensivity.
by default None and don't restrict by this.
But for some spectrum it is necessary to cut noise.</dd>
<dt><strong><code>intens_max</code></strong> :&ensp;<code>numeric</code></dt>
<dd>upper limit for intensivity.
by default None and don't restrict by this</dd>
<dt><strong><code>mass_min</code></strong> :&ensp;<code>numeric</code></dt>
<dd>bottom limit for m/z.
by default None and don't restrict by this</dd>
<dt><strong><code>mass_max</code></strong> :&ensp;<code>numeric</code></dt>
<dd>upper limit for m/z.
by default None and don't restrict by this</dd>
</dl>
<h2 id="return">Return</h2>
<p>MassSpectrum object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load(
    self,
    filename: Union[Path, str],
    mapper: Mapping[str, str] = None,
    ignore_columns: Sequence[str] = None,
    take_columns: Sequence[str] = None,
    take_only_mz: Sequence[str] = False,
    sep: str = &#34;,&#34;,
    intens_min: float =  None,
    intens_max: float = None,
    mass_min: float =  None,
    mass_max: float = None,
) -&gt; &#34;MassSpectrum&#34;:
    &#34;&#34;&#34;
    Load mass pectrum table to MassSpectrum object

    All parameters is optional except filename

    Parameters
    ----------
    filename: str
        path to mass spectrum table, absoulute or relative
    mapper: dict
        dictonary for recognize columns in mass spec file. 
        Example: {&#39;m/z&#39;:&#39;mass&#39;,&#39;I&#39;:&#39;intensity&#39;}
    ignore_columns: list of str
        list with names of columns that willn&#39;t loaded.
        if None load all columns.
        Example: [&#34;index&#34;, &#34;s/n&#34;]
    take_columns: list of str
        list with names of columns that only will be loaded.
        if None load all columns.
        Example: [&#34;mass&#34;, &#34;intensity&#34;, &#34;C&#34;, &#34;H&#34;, &#34;N&#34;, &#34;O&#34;]
    take_only_mz: bool
        load only mass and intesivity columns
    sep: str
        separator in mass spectrum table, \\t - for tab.
    intens_min: numeric
        bottom limit for intensivity.
        by default None and don&#39;t restrict by this.
        But for some spectrum it is necessary to cut noise.
    intens_max: numeric
        upper limit for intensivity.
        by default None and don&#39;t restrict by this
    mass_min: numeric
        bottom limit for m/z.
        by default None and don&#39;t restrict by this
    mass_max: numeric
        upper limit for m/z.
        by default None and don&#39;t restrict by this

    Return
    ------
    MassSpectrum object
    &#34;&#34;&#34;

    self.table = pd.read_csv(filename, sep=sep)
    if mapper:
        self.table = self.table.rename(columns=mapper)

    if take_columns:
        self.table = self.table.loc[:,take_columns]

    if ignore_columns:
        self.table = self.table.drop(columns=ignore_columns)

    if take_only_mz:
        self.table = self.table.loc[:,[&#39;mass&#39;,&#39;intensity&#39;]]

    if intens_min is not None:
        self.table = self.table.loc[self.table[&#39;intensity&#39;]&gt;intens_min]

    if intens_max is not None:
        self.table = self.table.loc[self.table[&#39;intensity&#39;]&lt;intens_max]

    if mass_min is not None:
        self.table = self.table.loc[self.table[&#39;mass&#39;]&gt;mass_min]

    if mass_max is not None:
        self.table = self.table.loc[self.table[&#39;mass&#39;]&lt;mass_max]

    self.elems = self.find_elems()

    if self.elems is not None:
        self._mark_assigned_by_brutto()

    self.table = self.table.reset_index(drop=True)

    return self</code></pre>
</details>
</dd>
<dt id="nhsmasslib.mass.MassSpectrum.normalize"><code class="name flex">
<span>def <span class="ident">normalize</span></span>(<span>self) ><a title="nhsmasslib.mass.MassSpectrum" href="#nhsmasslib.mass.MassSpectrum">MassSpectrum</a></span>
</code></dt>
<dd>
<div class="desc"><p>Intensity normalize by max intensity</p>
<h2 id="return">Return</h2>
<p>Intensity normalized by max intensity MassSpectrum instance</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def normalize(self) -&gt; &#39;MassSpectrum&#39;:
    &#34;&#34;&#34;
    Intensity normalize by max intensity
    
    Return
    ------
    Intensity normalized by max intensity MassSpectrum instance
    &#34;&#34;&#34;
    table = self.table.copy()
    table[&#39;intensity&#39;] /= table[&#39;intensity&#39;].max()
    return MassSpectrum(table)</code></pre>
</details>
</dd>
<dt id="nhsmasslib.mass.MassSpectrum.recallibrate"><code class="name flex">
<span>def <span class="ident">recallibrate</span></span>(<span>self, error_table:<a title="nhsmasslib.mass.ErrorTable" href="#nhsmasslib.mass.ErrorTable">ErrorTable</a>=None, how='assign') ><a title="nhsmasslib.mass.MassSpectrum" href="#nhsmasslib.mass.MassSpectrum">MassSpectrum</a></span>
</code></dt>
<dd>
<div class="desc"><p>Recallibrate data by error-table</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>error_table</code></strong> :&ensp;<code><a title="nhsmasslib.mass.ErrorTable" href="#nhsmasslib.mass.ErrorTable">ErrorTable</a> object</code></dt>
<dd>Optional. If None - calculate for self.
ErrorTable object contain table error in ppm for mass, default 100 string</dd>
<dt><strong><code>how</code></strong> :&ensp;<code>str</code></dt>
<dd>Optional. Default 'assign'.
If error_table is None we can choose how to recalculate.
'assign' - by assign error, default.
'mdm' - by calculation mass-difference map.
filename - path to etalon spectrum, treated and saved by masslib</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="nhsmasslib.mass.MassSpectrum" href="#nhsmasslib.mass.MassSpectrum">MassSpectrum</a> object with recallibrated mass</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def recallibrate(self, error_table: &#34;ErrorTable&#34; = None, how = &#39;assign&#39;) -&gt; &#34;MassSpectrum&#34;:
    &#39;&#39;&#39;
    Recallibrate data by error-table

    Parameters
    ----------
    error_table: ErrorTable object
        Optional. If None - calculate for self. 
        ErrorTable object contain table error in ppm for mass, default 100 string            

    how: str
        Optional. Default &#39;assign&#39;.
        If error_table is None we can choose how to recalculate.
        &#39;assign&#39; - by assign error, default.
        &#39;mdm&#39; - by calculation mass-difference map.
        filename - path to etalon spectrum, treated and saved by masslib

    Returns
    -------
    MassSpectrum object with recallibrated mass
    &#39;&#39;&#39;
    if error_table is None:
        if how == &#39;assign&#39;:
            if &#34;assign&#34; not in self.table:
                raise SpectrumIsNotAssigned()
            error_table = ErrorTable().assign_error(self).zeroshift(self)
        elif how == &#39;mdm&#39;:
            error_table = ErrorTable().massdiff_error(self)
        else:
            etalon = MassSpectrum().load(filename=how)
            error_table = ErrorTable().etalon_error(spec=self, etalon=etalon)

    err = copy.deepcopy(error_table.table)
    data = self.table.reset_index(drop=True)
    wide = len(err)

    data[&#39;old_mass&#39;] = data[&#39;mass&#39;]

    min_mass = err[&#39;mass&#39;].min()
    max_mass = err[&#39;mass&#39;].max()
    a = np.linspace(min_mass, max_mass, wide+1)

    for i in range(wide):
        for ind in data.loc[(data[&#39;mass&#39;]&gt;a[i]) &amp; (data[&#39;mass&#39;]&lt;a[i+1])].index:
            mass = data.loc[ind, &#39;mass&#39;]
            e = mass * err.loc[i, &#39;ppm&#39;] / 1000000
            data.loc[ind, &#39;mass&#39;] = data.loc[ind, &#39;mass&#39;] + e
            
    return MassSpectrum(data)</code></pre>
</details>
</dd>
<dt id="nhsmasslib.mass.MassSpectrum.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>self, filename:Union[pathlib.Path,str], sep:str=',') >None</span>
</code></dt>
<dd>
<div class="desc"><p>Saves to csv MassSpectrum</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code></dt>
<dd>Path for saving mass spectrum table with calculation to csv file</dd>
<dt><strong><code>sep</code></strong> :&ensp;<code>str</code></dt>
<dd>Optional. Separator in saved file. By default it is ','</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save(self, filename: Union[Path, str], sep: str = &#34;,&#34;) -&gt; None:
    &#34;&#34;&#34;
    Saves to csv MassSpectrum
    
    Parameters
    ----------
    filename: str
        Path for saving mass spectrum table with calculation to csv file
    sep: str
        Optional. Separator in saved file. By default it is &#39;,&#39;        
    &#34;&#34;&#34;
    self.table.to_csv(filename, sep=sep, index=False)</code></pre>
</details>
</dd>
<dt id="nhsmasslib.mass.MassSpectrum.show_error"><code class="name flex">
<span>def <span class="ident">show_error</span></span>(<span>self) >None</span>
</code></dt>
<dd>
<div class="desc"><p>Plot relative error of assigned brutto formulas vs mass</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show_error(self) -&gt; None:
    &#34;&#34;&#34;
    Plot relative error of assigned brutto formulas vs mass
    &#34;&#34;&#34;

    if &#34;rel_error&#34; not in self.table:
        self = self.calculate_error()      

    fig, ax = plt.subplots(figsize=(4, 4), dpi=75)
    ax.scatter(self.table[&#39;mass&#39;], self.table[&#39;rel_error&#39;], s=0.1)
    ax.set_xlabel(&#39;m/z, Da&#39;)
    ax.set_ylabel(&#39;error, ppm&#39;)</code></pre>
</details>
</dd>
<dt id="nhsmasslib.mass.MassSpectrum.tail"><code class="name flex">
<span>def <span class="ident">tail</span></span>(<span>self, num:int=None) >pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Show tail of mass spec table</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>num</code></strong> :&ensp;<code>int</code></dt>
<dd>Optional. number of tail string</dd>
</dl>
<h2 id="return">Return</h2>
<p>Pandas Dataframe tail of MassSpec table</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tail(self, num:int = None) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    Show tail of mass spec table

    Parameters
    ----------
    num: int
        Optional. number of tail string

    Return
    ------
    Pandas Dataframe tail of MassSpec table
    &#34;&#34;&#34;
    if num is None:
        return self.table.tail()
    else:
        return self.table.tail(num)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="nhsmasslib.mass.MassSpectrumList"><code class="flex name class">
<span>class <span class="ident">MassSpectrumList</span></span>
<span>(</span><span>spectra:Sequence[<a title="nhsmasslib.mass.MassSpectrum" href="#nhsmasslib.mass.MassSpectrum">MassSpectrum</a>]=None, names:Optional[Sequence[str]]=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Class for work list of MassSpectrums objects</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>spectra</code></strong> :&ensp;<code>Sequence[<a title="nhsmasslib.mass.MassSpectrum" href="#nhsmasslib.mass.MassSpectrum">MassSpectrum</a>]</code></dt>
<dd>list of MassSpectrum objects</dd>
<dt><strong><code>names</code></strong> :&ensp;<code>Optional[Sequence[str]]</code></dt>
<dd>list of names for spectra</dd>
</dl>
<p>init MassSpectrumList Class</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>spectra</code></strong> :&ensp;<code>Sequence[<a title="nhsmasslib.mass.MassSpectrum" href="#nhsmasslib.mass.MassSpectrum">MassSpectrum</a>]</code></dt>
<dd>list of MassSpectrum objects</dd>
<dt><strong><code>names</code></strong> :&ensp;<code>Optional[Sequence[str]]</code></dt>
<dd>list of names for spectra</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MassSpectrumList(object):
    &#34;&#34;&#34;
    Class for work list of MassSpectrums objects
    
    Attributes
    ----------
    spectra: Sequence[MassSpectrum]
        list of MassSpectrum objects
    names: Optional[Sequence[str]]
        list of names for spectra
    &#34;&#34;&#34;

    def __init__(self, spectra: Sequence[MassSpectrum] = None, names: Optional[Sequence[str]] = None):
        &#34;&#34;&#34;
        init MassSpectrumList Class
        
        Parameters
        ----------
        spectra: Sequence[MassSpectrum]
            list of MassSpectrum objects
        names: Optional[Sequence[str]]
            list of names for spectra
        &#34;&#34;&#34;
        
        if spectra:
            self.spectra = spectra
        else:
            self.spectra = []

        if names:
            self.names = names
        elif len(self.spectra) &gt; 0:
            self.names = list(range(len(self.spectra)))
        else:
            self.names = []

    def calculate_similarity(self, mode: str = &#34;cosine&#34;) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Calculate similarity matrix for all spectra in MassSpectrumList

        Parameters
        ----------
        mode: str
            Optionaly. Default cosine. 
            one of the similarity functions
            Mode can be: &#34;tanimoto&#34;, &#34;jaccard&#34;, &#34;cosine&#34;

        Return
        ------
        similarity matrix, 2d np.ndarray with size [len(names), len(names)]&#34;&#34;&#34;

        def get_vector(a, b):
            # FIXME Probably bad solution
            c = np.union1d(a, b)
            A = np.zeros(len(c), dtype=bool)
            B = np.zeros(len(c), dtype=bool)
            for i, el in enumerate(c):
                if el in a:
                    A[i] = True
                if el in b:
                    B[i] = True
            return A, B

        def jaccard(a, b):
            A, B = get_vector(a, b)
            return 1 - spatial.distance.jaccard(A, B)

        def tanimoto(a, b):
            A, B = get_vector(a, b)
            return 1 - spatial.distance.rogerstanimoto(A, B)

        def cosine(a, b):
            A, B = get_vector(a, b)
            return 1 - spatial.distance.cosine(A, B)

        if mode == &#34;jaccard&#34;:
            similarity_func = jaccard
        elif mode == &#34;tanimoto&#34;:
            similarity_func = tanimoto
        elif mode == &#39;cosine&#39;:
            similarity_func = cosine
        else:
            raise Exception(f&#34;There is no such mode: {mode}&#34;)

        values = []
        for i in self.spectra:
            if &#39;calculated_mass&#39; not in i.table:
                i = i.calculate_mass()
            values.append([])
            for j in self.spectra:
                if &#39;calculated_mass&#39; not in j.table:
                    j = j.calculate_mass()
                values[-1].append(similarity_func(i.table[&#39;calculated_mass&#39;].dropna().values, j.table[&#39;calculated_mass&#39;].dropna().values))

        return np.array(values)

    def draw_similarity(
        self,
        mode: str = &#34;cosine&#34;,
        values: np.ndarray = None,
        ax: plt.axes = None,
        annot = True
        ) -&gt; None:
        &#34;&#34;&#34;
        Draw similarity matrix by using seaborn

        Parameters
        ----------
        values: np.ndarray
            Optionaly. Similarity matix.
            Default None - It is call calculate_similarity() method.
        mode: str
            Optionaly. If values is none for calculate matrix. 
            Default cosine. one of the similarity functions
            Mode can be: &#34;tanimoto&#34;, &#34;jaccard&#34;, &#34;cosine&#34;
        ax: matplotlib axes
            Entarnal axes for plot
        annotate: bool
            Draw value of similarity onto titles
        &#34;&#34;&#34;
        if values is None:
            values = self.calculate_similarity(mode=mode)

        if ax is None:
            fig, ax = plt.subplots(figsize=(len(self.spectra),len(self.spectra)), dpi=75)
        
        x_axis_labels = self.names
        y_axis_labels = self.names
        sns.heatmap(np.array(values), vmin=0, vmax=1, cmap=&#34;viridis&#34;, annot=annot, ax=ax, xticklabels=x_axis_labels, yticklabels=y_axis_labels)
        plt.title(mode)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="nhsmasslib.mass.MassSpectrumList.calculate_similarity"><code class="name flex">
<span>def <span class="ident">calculate_similarity</span></span>(<span>self, mode:str='cosine') >numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate similarity matrix for all spectra in MassSpectrumList</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>mode</code></strong> :&ensp;<code>str</code></dt>
<dd>Optionaly. Default cosine.
one of the similarity functions
Mode can be: "tanimoto", "jaccard", "cosine"</dd>
</dl>
<h2 id="return">Return</h2>
<p>similarity matrix, 2d np.ndarray with size [len(names), len(names)]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate_similarity(self, mode: str = &#34;cosine&#34;) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Calculate similarity matrix for all spectra in MassSpectrumList

    Parameters
    ----------
    mode: str
        Optionaly. Default cosine. 
        one of the similarity functions
        Mode can be: &#34;tanimoto&#34;, &#34;jaccard&#34;, &#34;cosine&#34;

    Return
    ------
    similarity matrix, 2d np.ndarray with size [len(names), len(names)]&#34;&#34;&#34;

    def get_vector(a, b):
        # FIXME Probably bad solution
        c = np.union1d(a, b)
        A = np.zeros(len(c), dtype=bool)
        B = np.zeros(len(c), dtype=bool)
        for i, el in enumerate(c):
            if el in a:
                A[i] = True
            if el in b:
                B[i] = True
        return A, B

    def jaccard(a, b):
        A, B = get_vector(a, b)
        return 1 - spatial.distance.jaccard(A, B)

    def tanimoto(a, b):
        A, B = get_vector(a, b)
        return 1 - spatial.distance.rogerstanimoto(A, B)

    def cosine(a, b):
        A, B = get_vector(a, b)
        return 1 - spatial.distance.cosine(A, B)

    if mode == &#34;jaccard&#34;:
        similarity_func = jaccard
    elif mode == &#34;tanimoto&#34;:
        similarity_func = tanimoto
    elif mode == &#39;cosine&#39;:
        similarity_func = cosine
    else:
        raise Exception(f&#34;There is no such mode: {mode}&#34;)

    values = []
    for i in self.spectra:
        if &#39;calculated_mass&#39; not in i.table:
            i = i.calculate_mass()
        values.append([])
        for j in self.spectra:
            if &#39;calculated_mass&#39; not in j.table:
                j = j.calculate_mass()
            values[-1].append(similarity_func(i.table[&#39;calculated_mass&#39;].dropna().values, j.table[&#39;calculated_mass&#39;].dropna().values))

    return np.array(values)</code></pre>
</details>
</dd>
<dt id="nhsmasslib.mass.MassSpectrumList.draw_similarity"><code class="name flex">
<span>def <span class="ident">draw_similarity</span></span>(<span>self, mode:str='cosine', values:numpy.ndarray=None, ax:<functionaxesat0x7f7f08d865e0>=None, annot=True) >None</span>
</code></dt>
<dd>
<div class="desc"><p>Draw similarity matrix by using seaborn</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>values</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>Optionaly. Similarity matix.
Default None - It is call calculate_similarity() method.</dd>
<dt><strong><code>mode</code></strong> :&ensp;<code>str</code></dt>
<dd>Optionaly. If values is none for calculate matrix.
Default cosine. one of the similarity functions
Mode can be: "tanimoto", "jaccard", "cosine"</dd>
<dt><strong><code>ax</code></strong> :&ensp;<code>matplotlib axes</code></dt>
<dd>Entarnal axes for plot</dd>
<dt><strong><code>annotate</code></strong> :&ensp;<code>bool</code></dt>
<dd>Draw value of similarity onto titles</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_similarity(
    self,
    mode: str = &#34;cosine&#34;,
    values: np.ndarray = None,
    ax: plt.axes = None,
    annot = True
    ) -&gt; None:
    &#34;&#34;&#34;
    Draw similarity matrix by using seaborn

    Parameters
    ----------
    values: np.ndarray
        Optionaly. Similarity matix.
        Default None - It is call calculate_similarity() method.
    mode: str
        Optionaly. If values is none for calculate matrix. 
        Default cosine. one of the similarity functions
        Mode can be: &#34;tanimoto&#34;, &#34;jaccard&#34;, &#34;cosine&#34;
    ax: matplotlib axes
        Entarnal axes for plot
    annotate: bool
        Draw value of similarity onto titles
    &#34;&#34;&#34;
    if values is None:
        values = self.calculate_similarity(mode=mode)

    if ax is None:
        fig, ax = plt.subplots(figsize=(len(self.spectra),len(self.spectra)), dpi=75)
    
    x_axis_labels = self.names
    y_axis_labels = self.names
    sns.heatmap(np.array(values), vmin=0, vmax=1, cmap=&#34;viridis&#34;, annot=annot, ax=ax, xticklabels=x_axis_labels, yticklabels=y_axis_labels)
    plt.title(mode)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="nhsmasslib.mass.Reaction"><code class="flex name class">
<span>class <span class="ident">Reaction</span></span>
<span>(</span><span>sourse:<a title="nhsmasslib.mass.MassSpectrum" href="#nhsmasslib.mass.MassSpectrum">MassSpectrum</a>=None, product:<a title="nhsmasslib.mass.MassSpectrum" href="#nhsmasslib.mass.MassSpectrum">MassSpectrum</a>=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Class for discover reaction by MS-difference methods</p>
<h2 id="atributes">Atributes</h2>
<p>sourse: MassSpectrum object
mass spectrum of source
product: MassSpectrum object
mass spectrum of product</p>
<p>Init Reaction</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>sourse</code></strong> :&ensp;<code><a title="nhsmasslib.mass.MassSpectrum" href="#nhsmasslib.mass.MassSpectrum">MassSpectrum</a> object</code></dt>
<dd>mass spectrum of source</dd>
<dt><strong><code>product</code></strong> :&ensp;<code><a title="nhsmasslib.mass.MassSpectrum" href="#nhsmasslib.mass.MassSpectrum">MassSpectrum</a> object</code></dt>
<dd>mass spectrum of product</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Reaction(object):
    &#34;&#34;&#34;
    Class for discover reaction by MS-difference methods

    Atributes
    ---------
    sourse: MassSpectrum object
        mass spectrum of source
    product: MassSpectrum object
        mass spectrum of product
    &#34;&#34;&#34;
    def __init__(self, 
        sourse:&#34;MassSpectrum&#34; = None, 
        product:&#34;MassSpectrum&#34; = None,
        ) -&gt; None:
        &#34;&#34;&#34;
        Init Reaction

        Parameters
        ---------
        sourse: MassSpectrum object
            mass spectrum of source
        product: MassSpectrum object
            mass spectrum of product
        &#34;&#34;&#34;
        self.sourse = sourse
        self.product = product

    def find_modification(self, brutto_table:pd.DataFrame) -&gt; &#34;Reaction&#34;:
        &#34;&#34;&#34;
        Find in source peaks that have modifed by diff-mass-es in brutto table
        Also cath them in product

        Parameters
        ----------
        brutto_table:pd.DataFrame
            table with element and their masses.
            Can be generated by function brutto_generator.brutto_gen().
        &#34;&#34;&#34;

        self.sourse = self.sourse.drop_unassigned().calculate_mass()
        self.product = self.product.drop_unassigned().calculate_mass()

        sourse_mass = self.sourse.table[&#39;calculated_mass&#39;].values
        product_mass = self.product.table[&#39;calculated_mass&#39;].values

        sourse_mass_num = len(sourse_mass)
        product_mass_num = len(product_mass)

        mdiff = np.zeros((sourse_mass_num, product_mass_num), dtype=float)
        for x in range(sourse_mass_num):
            for y in range(product_mass_num):
                mdiff[x,y] = product_mass[y]-sourse_mass[x]

        sourse_index = np.array([])
        product_index = np.array([])
        for i, row in brutto_table.iterrows():
            arr = np.where(mdiff == row[&#39;mass&#39;])
            sourse_index = np.hstack([sourse_index, arr[0]])
            product_index = np.hstack([product_index, arr[1]])

        self.sourse.table[&#39;modified&#39;] = False
        self.product.table[&#39;modified&#39;] = False

        self.sourse.table.loc[sourse_index,&#39;modified&#39;] = True
        self.product.table.loc[product_index,&#39;modified&#39;] = True

        return Reaction(sourse=self.sourse, product=self.product)

    def draw_modification(self,
        ax:plt.axes = None,
        sourse:bool = True,
        product:bool = True,
        sourse_color:str = &#39;red&#39;,
        product_color:str = &#39;blue&#39;,
        volume:float = 5
        )-&gt;None:
        &#34;&#34;&#34;
        Plot Van-Krevelen for modifed peaks in product and sourse

        Parameters
        ----------
        ax: plt.axes
            Optional. Use external ax
        sourse: bool
            Optional. Default True. plot sourse peaks
        product: bool
            Optional. Default True. plot product peaks
        sourse_color: str
            Optional. Default red. Color of sourse peaks
        product_color: str
            Optional. Default blue. Color of product peaks
        volume: float
            Optional. Default 5. Size of dot on VK
        &#34;&#34;&#34;

        if &#39;modified&#39; not in self.product.table or &#39;modified&#39; not in self.sourse.table:
            raise Exception(f&#34;Modification hasn&#39;t calculated&#34;)

        if ax is None:
            fig, ax = plt.subplots(figsize=(4,4), dpi = 75)

        if sourse:
            s = self.sourse.table.loc[self.sourse.table[&#39;modified&#39;] == True]
            vk_s = VanKrevelen(s).draw_scatter(ax=ax, volumes=volume, color=sourse_color)

        if product:
            p = self.sourse.table.loc[self.product.table[&#39;modified&#39;] == True]
            vk_p = VanKrevelen(p).draw_scatter(ax=ax, volumes=volume, color=product_color)        </code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="nhsmasslib.mass.Reaction.draw_modification"><code class="name flex">
<span>def <span class="ident">draw_modification</span></span>(<span>self, ax:<functionaxesat0x7f7f08d865e0>=None, sourse:bool=True, product:bool=True, sourse_color:str='red', product_color:str='blue', volume:float=5) >None</span>
</code></dt>
<dd>
<div class="desc"><p>Plot Van-Krevelen for modifed peaks in product and sourse</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>plt.axes</code></dt>
<dd>Optional. Use external ax</dd>
<dt><strong><code>sourse</code></strong> :&ensp;<code>bool</code></dt>
<dd>Optional. Default True. plot sourse peaks</dd>
<dt><strong><code>product</code></strong> :&ensp;<code>bool</code></dt>
<dd>Optional. Default True. plot product peaks</dd>
<dt><strong><code>sourse_color</code></strong> :&ensp;<code>str</code></dt>
<dd>Optional. Default red. Color of sourse peaks</dd>
<dt><strong><code>product_color</code></strong> :&ensp;<code>str</code></dt>
<dd>Optional. Default blue. Color of product peaks</dd>
<dt><strong><code>volume</code></strong> :&ensp;<code>float</code></dt>
<dd>Optional. Default 5. Size of dot on VK</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_modification(self,
    ax:plt.axes = None,
    sourse:bool = True,
    product:bool = True,
    sourse_color:str = &#39;red&#39;,
    product_color:str = &#39;blue&#39;,
    volume:float = 5
    )-&gt;None:
    &#34;&#34;&#34;
    Plot Van-Krevelen for modifed peaks in product and sourse

    Parameters
    ----------
    ax: plt.axes
        Optional. Use external ax
    sourse: bool
        Optional. Default True. plot sourse peaks
    product: bool
        Optional. Default True. plot product peaks
    sourse_color: str
        Optional. Default red. Color of sourse peaks
    product_color: str
        Optional. Default blue. Color of product peaks
    volume: float
        Optional. Default 5. Size of dot on VK
    &#34;&#34;&#34;

    if &#39;modified&#39; not in self.product.table or &#39;modified&#39; not in self.sourse.table:
        raise Exception(f&#34;Modification hasn&#39;t calculated&#34;)

    if ax is None:
        fig, ax = plt.subplots(figsize=(4,4), dpi = 75)

    if sourse:
        s = self.sourse.table.loc[self.sourse.table[&#39;modified&#39;] == True]
        vk_s = VanKrevelen(s).draw_scatter(ax=ax, volumes=volume, color=sourse_color)

    if product:
        p = self.sourse.table.loc[self.product.table[&#39;modified&#39;] == True]
        vk_p = VanKrevelen(p).draw_scatter(ax=ax, volumes=volume, color=product_color)        </code></pre>
</details>
</dd>
<dt id="nhsmasslib.mass.Reaction.find_modification"><code class="name flex">
<span>def <span class="ident">find_modification</span></span>(<span>self, brutto_table:pandas.core.frame.DataFrame) ><a title="nhsmasslib.mass.Reaction" href="#nhsmasslib.mass.Reaction">Reaction</a></span>
</code></dt>
<dd>
<div class="desc"><p>Find in source peaks that have modifed by diff-mass-es in brutto table
Also cath them in product</p>
<h2 id="parameters">Parameters</h2>
<p>brutto_table:pd.DataFrame
table with element and their masses.
Can be generated by function brutto_generator.brutto_gen().</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_modification(self, brutto_table:pd.DataFrame) -&gt; &#34;Reaction&#34;:
    &#34;&#34;&#34;
    Find in source peaks that have modifed by diff-mass-es in brutto table
    Also cath them in product

    Parameters
    ----------
    brutto_table:pd.DataFrame
        table with element and their masses.
        Can be generated by function brutto_generator.brutto_gen().
    &#34;&#34;&#34;

    self.sourse = self.sourse.drop_unassigned().calculate_mass()
    self.product = self.product.drop_unassigned().calculate_mass()

    sourse_mass = self.sourse.table[&#39;calculated_mass&#39;].values
    product_mass = self.product.table[&#39;calculated_mass&#39;].values

    sourse_mass_num = len(sourse_mass)
    product_mass_num = len(product_mass)

    mdiff = np.zeros((sourse_mass_num, product_mass_num), dtype=float)
    for x in range(sourse_mass_num):
        for y in range(product_mass_num):
            mdiff[x,y] = product_mass[y]-sourse_mass[x]

    sourse_index = np.array([])
    product_index = np.array([])
    for i, row in brutto_table.iterrows():
        arr = np.where(mdiff == row[&#39;mass&#39;])
        sourse_index = np.hstack([sourse_index, arr[0]])
        product_index = np.hstack([product_index, arr[1]])

    self.sourse.table[&#39;modified&#39;] = False
    self.product.table[&#39;modified&#39;] = False

    self.sourse.table.loc[sourse_index,&#39;modified&#39;] = True
    self.product.table.loc[product_index,&#39;modified&#39;] = True

    return Reaction(sourse=self.sourse, product=self.product)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="nhsmasslib.mass.SpectrumIsNotAssigned"><code class="flex name class">
<span>class <span class="ident">SpectrumIsNotAssigned</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Common base class for all non-exit exceptions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SpectrumIsNotAssigned(Exception):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="nhsmasslib.mass.Tmds"><code class="flex name class">
<span>class <span class="ident">Tmds</span></span>
<span>(</span><span>table:pandas.core.frame.DataFrame=None, elems:Sequence[str]=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A class for calculate TMDS spectrum</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>table</code></strong> :&ensp;<code>pandas Datarame</code></dt>
<dd>tmds spectrum - mass_dif, probability and caclulatedd parameters</dd>
<dt><strong><code>elems</code></strong> :&ensp;<code>Sequence[str]</code></dt>
<dd>elements in brutto formulas</dd>
</dl>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>table</code></strong> :&ensp;<code>pandas Datarame</code></dt>
<dd>Optional. tmds spectrum - mass_dif, probability and caclulatedd parameters</dd>
<dt><strong><code>elems</code></strong> :&ensp;<code>Sequence[str]</code></dt>
<dd>Optional. elements in brutto formulas</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Tmds(object):
    &#34;&#34;&#34;
    A class for calculate TMDS spectrum

    Attributes
    ----------
    table: pandas Datarame
        tmds spectrum - mass_dif, probability and caclulatedd parameters
    elems: Sequence[str]
        elements in brutto formulas
    &#34;&#34;&#34;

    def __init__(
        self,
        table: pd.DataFrame = None,
        elems: Sequence[str] = None
        ) -&gt; None:
        &#34;&#34;&#34;
        Parameters
        ----------
        table: pandas Datarame
            Optional. tmds spectrum - mass_dif, probability and caclulatedd parameters
        elems: Sequence[str]
            Optional. elements in brutto formulas
        &#34;&#34;&#34;

        self.elems = elems

        if table is None:
            self.table = pd.DataFrame()
        else:
            self.table = table
            self.elems = self.find_elems()

    def calc(
        self,
        mass_spec:&#34;MassSpectrum&#34;,
        other:&#34;MassSpectrum&#34;=None,
        p: float = 0.2,
        wide: int = 10,
        C13_filter:bool = True,
        ) -&gt; &#34;Tmds&#34;:

        &#34;&#34;&#34;
        Total mass difference statistic calculation 

        Parameters
        ----------
        mass_spec: MassSpectrum object
            for tmds calculation
        other: MassSpectrum object
            Optional. If None, TMDS will call by self.
        p: float
            Optional. Default 0.2. 
            Minimum relative probability for taking mass-difference
        wide: int
            Optional. Default 10.
            Minimum interval in 0.001*wide Da of peaeks.
        C13_filter: bool
            Optional. Default True. 
            Use only peaks that have C13 isotope peak

        Reference
        ---------
        Anal. Chem. 2009, 81, 10106
        &#34;&#34;&#34;

        spec = copy.deepcopy(mass_spec)
        if other is None:
            spec2 = copy.deepcopy(mass_spec)
        else:
            spec2 = copy.deepcopy(other)

        if C13_filter:
            spec = spec.filter_by_C13(remove=True)
            spec2 = spec2.filter_by_C13(remove=True)
        else:
            spec = spec.drop_unassigned()
            spec2 = spec2.drop_unassigned()

        masses = spec.table[&#39;mass&#39;].values
        masses2 = spec2.table[&#39;mass&#39;].values

        mass_num = len(masses)
        mass_num2 = len(masses2)

        if mass_num &lt;2 or mass_num2 &lt; 2:
            raise Exception(f&#34;Too low amount of assigned peaks&#34;)

        mdiff = np.zeros((mass_num, mass_num2), dtype=float)
        for x in range(mass_num):
            for y in range(x, mass_num2):
                dif = np.fabs(masses[x]-masses2[y])
                if dif &lt; 300:
                    mdiff[x,y] = dif

        mdiff = np.round(mdiff, 3)
        unique, counts = np.unique(mdiff, return_counts=True)
        counts[0] = 0

        tmds_spec = pd.DataFrame()
        tmds_spec[&#39;mass_dif&#39;] = unique
        tmds_spec[&#39;count&#39;] = counts
        tmds_spec[&#39;probability&#39;] = tmds_spec[&#39;count&#39;]/mass_num
        tmds_spec = tmds_spec.sort_values(by=&#39;mass_dif&#39;).reset_index(drop=True)

        value_zero = set([i/1000 for i in range (0, 300000)]) - set (unique)
        unique = np.append(unique, np.array(list(value_zero)))
        counts = np.append(counts, np.zeros(len(value_zero), dtype=float))

        peaks, properties = find_peaks(tmds_spec[&#39;probability&#39;], distance=wide, prominence=p/2)
        prob = []
        for peak in peaks:
            prob.append(tmds_spec.loc[peak-5:peak+5,&#39;probability&#39;].sum())
        tmds_spec = tmds_spec.loc[peaks].reset_index(drop=True)
        tmds_spec[&#39;probability&#39;] = prob
        tmds_spec = tmds_spec.loc[tmds_spec[&#39;probability&#39;] &gt; p]

        if len(tmds_spec) &lt; 0:
            raise Exception(f&#34;There isn&#39;t mass diff mass, decrease p-value&#34;)

        return Tmds(tmds_spec)
    
    def calc_by_brutto(
        self,
        mass_spec:&#34;MassSpectrum&#34;
        ) -&gt; &#34;Tmds&#34;:

        &#34;&#34;&#34;
        Calculate self difference by calculated mass from brutto

        Parameters
        ----------
        mass_spec: MassSpectrum object
            for tmds calculation

        Return
        ------
        Tmds object with assigned signals and elements
        &#34;&#34;&#34;

        mass = mass_spec.drop_unassigned().calculate_error().table[&#39;calculated_mass&#39;].values
        massl = len(mass)
        mdiff = np.zeros((massl, massl), dtype=float)
        for x in range(massl):
            for y in range(x, massl):
                mdiff[x,y] = np.fabs(mass[x]-mass[y])

        mdiff = np.round(mdiff, 6)
        unique, counts = np.unique(mdiff, return_counts=True)
        counts[0] = 0

        diff_spec = pd.DataFrame()
        diff_spec[&#39;mass_dif&#39;] = unique
        diff_spec[&#39;count&#39;] = counts
        diff_spec[&#39;probability&#39;] = diff_spec[&#39;count&#39;]/massl
        diff_spec = diff_spec.sort_values(by=&#39;mass_dif&#39;).reset_index(drop=True)

        return Tmds(diff_spec)

    def assign(
        self,
        generated_bruttos_table: pd.DataFrame = None,
        error: float = 0.001,
        gdf:dict = {&#39;C&#39;:(-1,20),&#39;H&#39;:(-4,40), &#39;O&#39;:(-1,20),&#39;N&#39;:(-1,2)},
        max_num: int = None
        ) -&gt; &#34;Tmds&#34;:

        &#34;&#34;&#34;
        Finding the nearest mass in generated_bruttos_table

        Parameters
        ----------
        generated_bruttos_table: pandas DataFrame 
            Optional. with column &#39;mass&#39; and elements, should be sorted by &#39;mass&#39;
        error: float
            Optional. Default 0.001. 
            absolute error iin Da for assign formulas
        gdf: dict
            Optional, default {&#39;C&#39;:(-1,20),&#39;H&#39;:(-4,40), &#39;O&#39;:(-1,20),&#39;N&#39;:(-1,2)}
            generate brutto table if generated_bruttos_table is None.
        max_num: int
            Optional. Default 100
        
        Return
        ------
        Tmds object with assigned signals and elements
        &#34;&#34;&#34;

        if generated_bruttos_table is None:
            generated_bruttos_table = brutto_gen(gdf, rules=False)
            generated_bruttos_table = generated_bruttos_table.loc[generated_bruttos_table[&#39;mass&#39;] &gt; 0]

        table = self.table.copy()

        masses = generated_bruttos_table[&#34;mass&#34;].values
        
        elems = list(generated_bruttos_table.drop(columns=[&#34;mass&#34;]))
        bruttos = generated_bruttos_table[elems].values.tolist()

        res = []
        for index, row in table.iterrows():
            mass = row[&#34;mass_dif&#34;]
            idx = np.searchsorted(masses, mass, side=&#39;left&#39;)
            if idx &gt; 0 and (idx == len(masses) or np.fabs(mass - masses[idx - 1]) &lt; np.fabs(mass - masses[idx])):
                idx -= 1

            if np.fabs(masses[idx] - mass)  &lt;= error:
                res.append({**dict(zip(elems, bruttos[idx])), &#34;assign&#34;: True, &#34;mass_dif&#34;:mass, &#34;probability&#34;:row[&#34;probability&#34;], &#34;count&#34;:row[&#34;count&#34;]})

        res = pd.DataFrame(res)

        if max_num is not None and len(res) &gt; max_num:
            res = res.sort_values(by=&#39;count&#39;, ascending=False).reset_index(drop=True)
            res = res.loc[:max_num].reset_index(drop=True)
            res = res.sort_values(by=&#39;mass_dif&#39;).reset_index(drop=True)
        
        return Tmds(table=res, elems=elems)

    def find_elems(self):
        &#34;&#34;&#34;
        Find elems from mass spectrum table.

        Find elements in table columns. Used elems_mass_table with all elements and isotopes.
        For example, element &#39;C&#39; will be recognised as carbon 12C, element &#39;C_13&#34; as 13C

        Returns
        -------
        list
            a list of found elemets. For example: [&#39;C&#39;,&#39;H&#39;,&#39;O&#39;,&#39;N&#39;]
        &#34;&#34;&#34;

        main_elems = elements_table()[&#39;element&#39;].values
        all_elems = elements_table()[&#39;element_isotop&#39;].values

        elems = []
        for col in self.table.columns:
            if col in main_elems:
                elems.append(col)
            elif col in all_elems:
                elems.append(col)

        return elems

    def calculate_mass(self) -&gt; &#34;Tmds&#34;:
        &#34;&#34;&#34;
        Calculate mass from brutto formulas in tmds table

        Return
        ------
        Tmds object with calculated mass for assigned brutto formulas
        &#34;&#34;&#34;
        
        table = copy.deepcopy(self.table)
        self.elems = self.find_elems()
        
        table = table.loc[:,self.elems]

        masses = get_elements_masses(self.elems)

        self.table[&#34;calculated_mass&#34;] = table.multiply(masses).sum(axis=1)
        self.table[&#34;calculated_mass&#34;] = np.round(self.table[&#34;calculated_mass&#34;], 6)
        self.table.loc[self.table[&#34;calculated_mass&#34;] == 0, &#34;calculated_mass&#34;] = np.NaN

        return Tmds(self.table, elems=self.elems)

    def draw(
        self,
        xlim: Tuple[float, float] = (None, None),
        ylim: Tuple[float, float] = (None, None),
        color: str = &#39;black&#39;,
        ax = None,
        ) -&gt; None:
        &#34;&#34;&#34;
        Draw TMDS spectrum

        All parameters is optional

        Parameters
        ----------
        xlim: Tuple (float, float)
            restrict for mass
        ylim: Tuple (float, float)
            restrict for probability
        color: str
            color of draw
        ax: matplotlyp axes object
            send here ax to plot in your own condition
        &#34;&#34;&#34;

        df = self.table.sort_values(by=&#34;mass_dif&#34;)

        mass = df[&#39;mass_dif&#39;].values
        if xlim[0] is None:
            xlim = (mass.min(), xlim[1])
        if xlim[1] is None:
            xlim = (xlim[0], mass.max())

        intensity = df[&#39;probability&#39;].values
        # filter first intensity and only after mass (because we will lose the information)
        intensity = intensity[(xlim[0] &lt;= mass) &amp; (mass &lt;= xlim[1])]
        mass = mass[(xlim[0] &lt;= mass) &amp; (mass &lt;= xlim[1])]

        # bas solution, probably it&#39;s needed to rewrite this piece
        M = np.zeros((len(mass), 3))
        M[:, 0] = mass
        M[:, 1] = mass
        M[:, 2] = mass
        M = M.reshape(-1)

        I = np.zeros((len(intensity), 3))
        I[:, 1] = intensity
        I = I.reshape(-1)

        if ax is None:
            fig, ax = plt.subplots(figsize=(4,4), dpi=75)
            
        ax.plot(M, I, color=color, linewidth=0.2)
        ax.plot([xlim[0], xlim[1]], [0, 0], color=color, linewidth=0.2)
        ax.set_xlim(xlim)
        ax.set_ylim(ylim)
        ax.set_xlabel(&#39;mass difference, Da&#39;)
        ax.set_ylabel(&#39;P&#39;)
        ax.set_title(f&#39;{len(self.table)} peaks&#39;)
        return

    def save(self, filename:str) -&gt; None:
        &#34;&#34;&#34;
        Save Tmds spectrum as csv

        Parameters
        ----------
        filename: str
            file name with path in which save tmds
        &#34;&#34;&#34;
        self.table.to_csv(filename)

    def load(self, filename:str) -&gt; &#34;Tmds&#34;:
        &#34;&#34;&#34;
        Load Tmds spectrum table from csv

        Parameters
        ----------
        filename: str
            file name with path in which load tmds
        &#34;&#34;&#34;
        return Tmds(pd.read_csv(filename))</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="nhsmasslib.mass.Tmds.assign"><code class="name flex">
<span>def <span class="ident">assign</span></span>(<span>self, generated_bruttos_table:pandas.core.frame.DataFrame=None, error:float=0.001, gdf:dict={'C': (-1, 20), 'H': (-4, 40), 'O': (-1, 20), 'N': (-1, 2)}, max_num:int=None) ><a title="nhsmasslib.mass.Tmds" href="#nhsmasslib.mass.Tmds">Tmds</a></span>
</code></dt>
<dd>
<div class="desc"><p>Finding the nearest mass in generated_bruttos_table</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>generated_bruttos_table</code></strong> :&ensp;<code>pandas DataFrame </code></dt>
<dd>Optional. with column 'mass' and elements, should be sorted by 'mass'</dd>
<dt><strong><code>error</code></strong> :&ensp;<code>float</code></dt>
<dd>Optional. Default 0.001.
absolute error iin Da for assign formulas</dd>
<dt><strong><code>gdf</code></strong> :&ensp;<code>dict</code></dt>
<dd>Optional, default {'C':(-1,20),'H':(-4,40), 'O':(-1,20),'N':(-1,2)}
generate brutto table if generated_bruttos_table is None.</dd>
<dt><strong><code>max_num</code></strong> :&ensp;<code>int</code></dt>
<dd>Optional. Default 100</dd>
</dl>
<h2 id="return">Return</h2>
<p>Tmds object with assigned signals and elements</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assign(
    self,
    generated_bruttos_table: pd.DataFrame = None,
    error: float = 0.001,
    gdf:dict = {&#39;C&#39;:(-1,20),&#39;H&#39;:(-4,40), &#39;O&#39;:(-1,20),&#39;N&#39;:(-1,2)},
    max_num: int = None
    ) -&gt; &#34;Tmds&#34;:

    &#34;&#34;&#34;
    Finding the nearest mass in generated_bruttos_table

    Parameters
    ----------
    generated_bruttos_table: pandas DataFrame 
        Optional. with column &#39;mass&#39; and elements, should be sorted by &#39;mass&#39;
    error: float
        Optional. Default 0.001. 
        absolute error iin Da for assign formulas
    gdf: dict
        Optional, default {&#39;C&#39;:(-1,20),&#39;H&#39;:(-4,40), &#39;O&#39;:(-1,20),&#39;N&#39;:(-1,2)}
        generate brutto table if generated_bruttos_table is None.
    max_num: int
        Optional. Default 100
    
    Return
    ------
    Tmds object with assigned signals and elements
    &#34;&#34;&#34;

    if generated_bruttos_table is None:
        generated_bruttos_table = brutto_gen(gdf, rules=False)
        generated_bruttos_table = generated_bruttos_table.loc[generated_bruttos_table[&#39;mass&#39;] &gt; 0]

    table = self.table.copy()

    masses = generated_bruttos_table[&#34;mass&#34;].values
    
    elems = list(generated_bruttos_table.drop(columns=[&#34;mass&#34;]))
    bruttos = generated_bruttos_table[elems].values.tolist()

    res = []
    for index, row in table.iterrows():
        mass = row[&#34;mass_dif&#34;]
        idx = np.searchsorted(masses, mass, side=&#39;left&#39;)
        if idx &gt; 0 and (idx == len(masses) or np.fabs(mass - masses[idx - 1]) &lt; np.fabs(mass - masses[idx])):
            idx -= 1

        if np.fabs(masses[idx] - mass)  &lt;= error:
            res.append({**dict(zip(elems, bruttos[idx])), &#34;assign&#34;: True, &#34;mass_dif&#34;:mass, &#34;probability&#34;:row[&#34;probability&#34;], &#34;count&#34;:row[&#34;count&#34;]})

    res = pd.DataFrame(res)

    if max_num is not None and len(res) &gt; max_num:
        res = res.sort_values(by=&#39;count&#39;, ascending=False).reset_index(drop=True)
        res = res.loc[:max_num].reset_index(drop=True)
        res = res.sort_values(by=&#39;mass_dif&#39;).reset_index(drop=True)
    
    return Tmds(table=res, elems=elems)</code></pre>
</details>
</dd>
<dt id="nhsmasslib.mass.Tmds.calc"><code class="name flex">
<span>def <span class="ident">calc</span></span>(<span>self, mass_spec:<a title="nhsmasslib.mass.MassSpectrum" href="#nhsmasslib.mass.MassSpectrum">MassSpectrum</a>, other:<a title="nhsmasslib.mass.MassSpectrum" href="#nhsmasslib.mass.MassSpectrum">MassSpectrum</a>=None, p:float=0.2, wide:int=10, C13_filter:bool=True) ><a title="nhsmasslib.mass.Tmds" href="#nhsmasslib.mass.Tmds">Tmds</a></span>
</code></dt>
<dd>
<div class="desc"><p>Total mass difference statistic calculation </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>mass_spec</code></strong> :&ensp;<code><a title="nhsmasslib.mass.MassSpectrum" href="#nhsmasslib.mass.MassSpectrum">MassSpectrum</a> object</code></dt>
<dd>for tmds calculation</dd>
<dt><strong><code>other</code></strong> :&ensp;<code><a title="nhsmasslib.mass.MassSpectrum" href="#nhsmasslib.mass.MassSpectrum">MassSpectrum</a> object</code></dt>
<dd>Optional. If None, TMDS will call by self.</dd>
<dt><strong><code>p</code></strong> :&ensp;<code>float</code></dt>
<dd>Optional. Default 0.2.
Minimum relative probability for taking mass-difference</dd>
<dt><strong><code>wide</code></strong> :&ensp;<code>int</code></dt>
<dd>Optional. Default 10.
Minimum interval in 0.001*wide Da of peaeks.</dd>
<dt><strong><code>C13_filter</code></strong> :&ensp;<code>bool</code></dt>
<dd>Optional. Default True.
Use only peaks that have C13 isotope peak</dd>
</dl>
<h2 id="reference">Reference</h2>
<p>Anal. Chem. 2009, 81, 10106</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc(
    self,
    mass_spec:&#34;MassSpectrum&#34;,
    other:&#34;MassSpectrum&#34;=None,
    p: float = 0.2,
    wide: int = 10,
    C13_filter:bool = True,
    ) -&gt; &#34;Tmds&#34;:

    &#34;&#34;&#34;
    Total mass difference statistic calculation 

    Parameters
    ----------
    mass_spec: MassSpectrum object
        for tmds calculation
    other: MassSpectrum object
        Optional. If None, TMDS will call by self.
    p: float
        Optional. Default 0.2. 
        Minimum relative probability for taking mass-difference
    wide: int
        Optional. Default 10.
        Minimum interval in 0.001*wide Da of peaeks.
    C13_filter: bool
        Optional. Default True. 
        Use only peaks that have C13 isotope peak

    Reference
    ---------
    Anal. Chem. 2009, 81, 10106
    &#34;&#34;&#34;

    spec = copy.deepcopy(mass_spec)
    if other is None:
        spec2 = copy.deepcopy(mass_spec)
    else:
        spec2 = copy.deepcopy(other)

    if C13_filter:
        spec = spec.filter_by_C13(remove=True)
        spec2 = spec2.filter_by_C13(remove=True)
    else:
        spec = spec.drop_unassigned()
        spec2 = spec2.drop_unassigned()

    masses = spec.table[&#39;mass&#39;].values
    masses2 = spec2.table[&#39;mass&#39;].values

    mass_num = len(masses)
    mass_num2 = len(masses2)

    if mass_num &lt;2 or mass_num2 &lt; 2:
        raise Exception(f&#34;Too low amount of assigned peaks&#34;)

    mdiff = np.zeros((mass_num, mass_num2), dtype=float)
    for x in range(mass_num):
        for y in range(x, mass_num2):
            dif = np.fabs(masses[x]-masses2[y])
            if dif &lt; 300:
                mdiff[x,y] = dif

    mdiff = np.round(mdiff, 3)
    unique, counts = np.unique(mdiff, return_counts=True)
    counts[0] = 0

    tmds_spec = pd.DataFrame()
    tmds_spec[&#39;mass_dif&#39;] = unique
    tmds_spec[&#39;count&#39;] = counts
    tmds_spec[&#39;probability&#39;] = tmds_spec[&#39;count&#39;]/mass_num
    tmds_spec = tmds_spec.sort_values(by=&#39;mass_dif&#39;).reset_index(drop=True)

    value_zero = set([i/1000 for i in range (0, 300000)]) - set (unique)
    unique = np.append(unique, np.array(list(value_zero)))
    counts = np.append(counts, np.zeros(len(value_zero), dtype=float))

    peaks, properties = find_peaks(tmds_spec[&#39;probability&#39;], distance=wide, prominence=p/2)
    prob = []
    for peak in peaks:
        prob.append(tmds_spec.loc[peak-5:peak+5,&#39;probability&#39;].sum())
    tmds_spec = tmds_spec.loc[peaks].reset_index(drop=True)
    tmds_spec[&#39;probability&#39;] = prob
    tmds_spec = tmds_spec.loc[tmds_spec[&#39;probability&#39;] &gt; p]

    if len(tmds_spec) &lt; 0:
        raise Exception(f&#34;There isn&#39;t mass diff mass, decrease p-value&#34;)

    return Tmds(tmds_spec)</code></pre>
</details>
</dd>
<dt id="nhsmasslib.mass.Tmds.calc_by_brutto"><code class="name flex">
<span>def <span class="ident">calc_by_brutto</span></span>(<span>self, mass_spec:<a title="nhsmasslib.mass.MassSpectrum" href="#nhsmasslib.mass.MassSpectrum">MassSpectrum</a>) ><a title="nhsmasslib.mass.Tmds" href="#nhsmasslib.mass.Tmds">Tmds</a></span>
</code></dt>
<dd>
<div class="desc"><p>Calculate self difference by calculated mass from brutto</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>mass_spec</code></strong> :&ensp;<code><a title="nhsmasslib.mass.MassSpectrum" href="#nhsmasslib.mass.MassSpectrum">MassSpectrum</a> object</code></dt>
<dd>for tmds calculation</dd>
</dl>
<h2 id="return">Return</h2>
<p>Tmds object with assigned signals and elements</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_by_brutto(
    self,
    mass_spec:&#34;MassSpectrum&#34;
    ) -&gt; &#34;Tmds&#34;:

    &#34;&#34;&#34;
    Calculate self difference by calculated mass from brutto

    Parameters
    ----------
    mass_spec: MassSpectrum object
        for tmds calculation

    Return
    ------
    Tmds object with assigned signals and elements
    &#34;&#34;&#34;

    mass = mass_spec.drop_unassigned().calculate_error().table[&#39;calculated_mass&#39;].values
    massl = len(mass)
    mdiff = np.zeros((massl, massl), dtype=float)
    for x in range(massl):
        for y in range(x, massl):
            mdiff[x,y] = np.fabs(mass[x]-mass[y])

    mdiff = np.round(mdiff, 6)
    unique, counts = np.unique(mdiff, return_counts=True)
    counts[0] = 0

    diff_spec = pd.DataFrame()
    diff_spec[&#39;mass_dif&#39;] = unique
    diff_spec[&#39;count&#39;] = counts
    diff_spec[&#39;probability&#39;] = diff_spec[&#39;count&#39;]/massl
    diff_spec = diff_spec.sort_values(by=&#39;mass_dif&#39;).reset_index(drop=True)

    return Tmds(diff_spec)</code></pre>
</details>
</dd>
<dt id="nhsmasslib.mass.Tmds.calculate_mass"><code class="name flex">
<span>def <span class="ident">calculate_mass</span></span>(<span>self) ><a title="nhsmasslib.mass.Tmds" href="#nhsmasslib.mass.Tmds">Tmds</a></span>
</code></dt>
<dd>
<div class="desc"><p>Calculate mass from brutto formulas in tmds table</p>
<h2 id="return">Return</h2>
<p>Tmds object with calculated mass for assigned brutto formulas</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate_mass(self) -&gt; &#34;Tmds&#34;:
    &#34;&#34;&#34;
    Calculate mass from brutto formulas in tmds table

    Return
    ------
    Tmds object with calculated mass for assigned brutto formulas
    &#34;&#34;&#34;
    
    table = copy.deepcopy(self.table)
    self.elems = self.find_elems()
    
    table = table.loc[:,self.elems]

    masses = get_elements_masses(self.elems)

    self.table[&#34;calculated_mass&#34;] = table.multiply(masses).sum(axis=1)
    self.table[&#34;calculated_mass&#34;] = np.round(self.table[&#34;calculated_mass&#34;], 6)
    self.table.loc[self.table[&#34;calculated_mass&#34;] == 0, &#34;calculated_mass&#34;] = np.NaN

    return Tmds(self.table, elems=self.elems)</code></pre>
</details>
</dd>
<dt id="nhsmasslib.mass.Tmds.draw"><code class="name flex">
<span>def <span class="ident">draw</span></span>(<span>self, xlim:Tuple[float,float]=(None, None), ylim:Tuple[float,float]=(None, None), color:str='black', ax=None) >None</span>
</code></dt>
<dd>
<div class="desc"><p>Draw TMDS spectrum</p>
<p>All parameters is optional</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>xlim</code></strong> :&ensp;<code>Tuple (float, float)</code></dt>
<dd>restrict for mass</dd>
<dt><strong><code>ylim</code></strong> :&ensp;<code>Tuple (float, float)</code></dt>
<dd>restrict for probability</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>str</code></dt>
<dd>color of draw</dd>
<dt><strong><code>ax</code></strong> :&ensp;<code>matplotlyp axes object</code></dt>
<dd>send here ax to plot in your own condition</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw(
    self,
    xlim: Tuple[float, float] = (None, None),
    ylim: Tuple[float, float] = (None, None),
    color: str = &#39;black&#39;,
    ax = None,
    ) -&gt; None:
    &#34;&#34;&#34;
    Draw TMDS spectrum

    All parameters is optional

    Parameters
    ----------
    xlim: Tuple (float, float)
        restrict for mass
    ylim: Tuple (float, float)
        restrict for probability
    color: str
        color of draw
    ax: matplotlyp axes object
        send here ax to plot in your own condition
    &#34;&#34;&#34;

    df = self.table.sort_values(by=&#34;mass_dif&#34;)

    mass = df[&#39;mass_dif&#39;].values
    if xlim[0] is None:
        xlim = (mass.min(), xlim[1])
    if xlim[1] is None:
        xlim = (xlim[0], mass.max())

    intensity = df[&#39;probability&#39;].values
    # filter first intensity and only after mass (because we will lose the information)
    intensity = intensity[(xlim[0] &lt;= mass) &amp; (mass &lt;= xlim[1])]
    mass = mass[(xlim[0] &lt;= mass) &amp; (mass &lt;= xlim[1])]

    # bas solution, probably it&#39;s needed to rewrite this piece
    M = np.zeros((len(mass), 3))
    M[:, 0] = mass
    M[:, 1] = mass
    M[:, 2] = mass
    M = M.reshape(-1)

    I = np.zeros((len(intensity), 3))
    I[:, 1] = intensity
    I = I.reshape(-1)

    if ax is None:
        fig, ax = plt.subplots(figsize=(4,4), dpi=75)
        
    ax.plot(M, I, color=color, linewidth=0.2)
    ax.plot([xlim[0], xlim[1]], [0, 0], color=color, linewidth=0.2)
    ax.set_xlim(xlim)
    ax.set_ylim(ylim)
    ax.set_xlabel(&#39;mass difference, Da&#39;)
    ax.set_ylabel(&#39;P&#39;)
    ax.set_title(f&#39;{len(self.table)} peaks&#39;)
    return</code></pre>
</details>
</dd>
<dt id="nhsmasslib.mass.Tmds.find_elems"><code class="name flex">
<span>def <span class="ident">find_elems</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Find elems from mass spectrum table.</p>
<p>Find elements in table columns. Used elems_mass_table with all elements and isotopes.
For example, element 'C' will be recognised as carbon 12C, element 'C_13" as 13C</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>a list of found elemets. For example: ['C','H','O','N']</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_elems(self):
    &#34;&#34;&#34;
    Find elems from mass spectrum table.

    Find elements in table columns. Used elems_mass_table with all elements and isotopes.
    For example, element &#39;C&#39; will be recognised as carbon 12C, element &#39;C_13&#34; as 13C

    Returns
    -------
    list
        a list of found elemets. For example: [&#39;C&#39;,&#39;H&#39;,&#39;O&#39;,&#39;N&#39;]
    &#34;&#34;&#34;

    main_elems = elements_table()[&#39;element&#39;].values
    all_elems = elements_table()[&#39;element_isotop&#39;].values

    elems = []
    for col in self.table.columns:
        if col in main_elems:
            elems.append(col)
        elif col in all_elems:
            elems.append(col)

    return elems</code></pre>
</details>
</dd>
<dt id="nhsmasslib.mass.Tmds.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>self, filename:str) ><a title="nhsmasslib.mass.Tmds" href="#nhsmasslib.mass.Tmds">Tmds</a></span>
</code></dt>
<dd>
<div class="desc"><p>Load Tmds spectrum table from csv</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code></dt>
<dd>file name with path in which load tmds</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load(self, filename:str) -&gt; &#34;Tmds&#34;:
    &#34;&#34;&#34;
    Load Tmds spectrum table from csv

    Parameters
    ----------
    filename: str
        file name with path in which load tmds
    &#34;&#34;&#34;
    return Tmds(pd.read_csv(filename))</code></pre>
</details>
</dd>
<dt id="nhsmasslib.mass.Tmds.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>self, filename:str) >None</span>
</code></dt>
<dd>
<div class="desc"><p>Save Tmds spectrum as csv</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code></dt>
<dd>file name with path in which save tmds</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save(self, filename:str) -&gt; None:
    &#34;&#34;&#34;
    Save Tmds spectrum as csv

    Parameters
    ----------
    filename: str
        file name with path in which save tmds
    &#34;&#34;&#34;
    self.table.to_csv(filename)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="nhsmasslib.mass.VanKrevelen"><code class="flex name class">
<span>class <span class="ident">VanKrevelen</span></span>
<span>(</span><span>table:Union[pandas.core.frame.DataFrame,ForwardRef('<a title="nhsmasslib.mass.MassSpectrum" href="#nhsmasslib.mass.MassSpectrum">MassSpectrum</a>'),None]=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A class used to plot Van-Krevelen diagramm</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>table</code></strong> :&ensp;<code>pandas Datarame</code> or <code><a title="nhsmasslib.mass.MassSpectrum" href="#nhsmasslib.mass.MassSpectrum">MassSpectrum</a> object</code></dt>
<dd>consist spectrum (mass and intensity of peaks) and all calculated parameters.
Must contain elements 'C', 'H', 'N'</dd>
</dl>
<p>Init and calculate C/H, O/C relatives</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>table</code></strong> :&ensp;<code>pandas Datarame</code> or <code><a title="nhsmasslib.mass.MassSpectrum" href="#nhsmasslib.mass.MassSpectrum">MassSpectrum</a> object</code></dt>
<dd>consist spectrum (mass and intensity of peaks) and all calculated parameters
Must contain elements 'C', 'H', 'N'</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class VanKrevelen(object):
    &#34;&#34;&#34;
    A class used to plot Van-Krevelen diagramm

    Attributes
    ----------
    table : pandas Datarame or MassSpectrum object
        consist spectrum (mass and intensity of peaks) and all calculated parameters.
        Must contain elements &#39;C&#39;, &#39;H&#39;, &#39;N&#39;
    &#34;&#34;&#34;

    def __init__(self, table: Optional[Union[pd.DataFrame, &#39;MassSpectrum&#39;]] = None) -&gt; None:
        &#34;&#34;&#34;
        Init and calculate C/H, O/C relatives

        Parameters
        ----------
        table : pandas Datarame or MassSpectrum object
            consist spectrum (mass and intensity of peaks) and all calculated parameters
            Must contain elements &#39;C&#39;, &#39;H&#39;, &#39;N&#39;
        &#34;&#34;&#34;
        if table is None:
            return

        if isinstance(table, MassSpectrum):
            table = table.table

        if not ((&#34;C&#34; in table and &#34;H&#34; in table and &#34;O&#34; in table) or (&#34;O/C&#34; in table or &#34;H/C&#34; in table)):
            raise CanNotCreateVanKrevelen()

        table = table.loc[table[&#34;C&#34;] &gt; 0]

        self.table = table
        if &#34;O/C&#34; not in self.table:
            self.table[&#34;O/C&#34;] = self.table[&#34;O&#34;] / self.table[&#34;C&#34;]

        if &#34;H/C&#34; not in self.table:
            self.table[&#34;H/C&#34;] = self.table[&#34;H&#34;] / self.table[&#34;C&#34;]

    def draw_density(
        self, 
        cmap:str =&#34;Blues&#34;, 
        ax: plt.axes = None, 
        shade: bool = True
        ) -&gt; None:
        &#34;&#34;&#34;
        Draw Van-Krevelen density

        All parameters is optional

        Parameters
        ----------
        cmap: str
            color map
        ax: matplotlib ax
            external ax
        shade: bool
            show shade
        &#34;&#34;&#34;
        sns.kdeplot(self.table[&#34;O/C&#34;], self.table[&#34;H/C&#34;], ax=ax, cmap=cmap, shade=shade)

    def draw_scatter(
        self, 
        ax:plt.axes = None, 
        volumes:float = None,
        color:str = &#39;blue&#39;,
        nitrogen:bool = False,
        sulphur:bool = False,
        alpha:float = 0.3, 
        mark_elem:str = None, 
        **kwargs) -&gt; None:
        &#34;&#34;&#34;
        plot Van-Krevelen diagramm

        All parameters is optional.

        Parameters
        ----------
        ax: Matplotlyb axes object
            send here ax if you want plot special graph
        volumes: float
            size of dot at diagram.
            By default calc by median intensity of spectrum
        color: str
            color of VK. Default blue
        nitrogen: bool
            mark nitrogen in brutto-formulas as orange
        sulphur: bool
            mark sulphur in brutto-formulas as green for CHOS and red for CHONS
        alpha: float
            transparency of dot at the scatter from 0 to 1
        mark_elem: str
            mark element in brutto-formulas by pink color
        **kwargs: dict
            dict for additional condition to scatter method        
        &#34;&#34;&#34;
        
        if ax is None:
            fig, ax = plt.subplots(figsize=(4, 4), dpi=75)
        else:
            ax=ax
        
        if volumes is None:
            self.table[&#39;volume&#39;] = self.table[&#39;intensity&#39;] / self.table[&#39;intensity&#39;].median()
        else:
            self.table[&#39;volume&#39;] = volumes

        self.table[&#39;color&#39;] = color

        if mark_elem is not None:
            
            self.table.loc[self.table[mark_elem] &gt; 0, &#39;color&#39;] = &#39;purple&#39;

        if nitrogen and &#39;N&#39; in self.table.columns:
            self.table.loc[(self.table[&#39;C&#39;] &gt; 0) &amp; (self.table[&#39;H&#39;] &gt; 0) &amp;(self.table[&#39;O&#39;] &gt; 0) &amp; (self.table[&#39;N&#39;] &gt; 0), &#39;color&#39;] = &#39;orange&#39;

        if sulphur and &#39;S&#39; in self.table.columns:
            self.table.loc[(self.table[&#39;C&#39;] &gt; 0) &amp; (self.table[&#39;H&#39;] &gt; 0) &amp;(self.table[&#39;O&#39;] &gt; 0) &amp; (self.table[&#39;N&#39;] &lt; 1) &amp; (self.table[&#39;S&#39;] &gt; 0), &#39;color&#39;] = &#39;green&#39;
            self.table.loc[(self.table[&#39;C&#39;] &gt; 0) &amp; (self.table[&#39;H&#39;] &gt; 0) &amp;(self.table[&#39;O&#39;] &gt; 0) &amp; (self.table[&#39;N&#39;] &gt; 0) &amp; (self.table[&#39;S&#39;] &gt; 0), &#39;color&#39;] = &#39;red&#39;
        
        if mark_elem is not None:
            ax.scatter(self.table.loc[self.table[mark_elem] &gt; 0, &#39;O/C&#39;], 
                        self.table.loc[self.table[mark_elem] &gt; 0, &#39;H/C&#39;],
                        s=self.table.loc[self.table[mark_elem] &gt; 0, &#39;volume&#39;], 
                        c=&#39;red&#39;, 
                        alpha=alpha, 
                        **kwargs)
        else:
            ax.scatter(self.table[&#34;O/C&#34;], self.table[&#34;H/C&#34;], s=self.table[&#39;volume&#39;], c=self.table[&#39;color&#39;], alpha=alpha, **kwargs)
        ax.set_xlabel(&#34;O/C&#34;)
        ax.set_ylabel(&#34;H/C&#34;)
        ax.yaxis.set_ticks(np.arange(0, 2.2, 0.4))
        ax.xaxis.set_ticks(np.arange(0, 1.1, 0.2))
        ax.set_xlim(0, 1)
        ax.set_ylim(0, 2.2)
        
        num_formules = self.table[&#39;C&#39;].count()
        ax.set_title(f&#39;{num_formules} formulas&#39;, size=10)

    def _plot_heatmap(self, df:pd.DataFrame) -&gt; None:
        &#34;&#34;&#34;Plot density map for VK

        Parameters
        ----------
        df: pd.DataFrame
            dataframe with density        
        &#34;&#34;&#34;

        fig, ax = plt.subplots(figsize=(4, 4), dpi=75)
        sns.heatmap(df.round(4),cmap=&#39;coolwarm&#39;,annot=True, linewidths=.5, ax=ax)
        bottom, top = ax.get_ylim()
        plt.yticks(rotation=0)
        plt.xticks(rotation=90) 
        ax.set_ylim(bottom + 0.5, top - 0.5)

        ax.set_xlabel(&#39;O/C&#39;)
        ax.set_ylabel(&#39;H/C&#39;)

    def squares(self, draw:bool = True) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        Calculate density  in VK divided into 20 squares

        Parameters:
        draw: bool
            Optional, default True. Draw heatmap for squares

        Return
        ------
        Pandas Dataframe with calculated square density
        &#34;&#34;&#34;

        d_table = []
        sq = []
        table = copy.deepcopy(self.table)
        total_i = len(table)
        for y in [ (1.8, 2.2), (1.4, 1.8), (1, 1.4), (0.6, 1), (0, 0.6)]:
            hc = []
            for x in  [(0, 0.25), (0.25, 0.5), (0.5, 0.75), (0.75, 1)]:
                temp = copy.deepcopy(self)
                temp.table = temp.table.loc[(temp.table[&#39;O/C&#39;] &gt;= x[0]) &amp; (temp.table[&#39;O/C&#39;] &lt; x[1]) &amp; (temp.table[&#39;H/C&#39;] &gt;= y[0]) &amp; (temp.table[&#39;H/C&#39;] &lt; y[1])]
                temp_i = len(temp.table)
                hc.append(temp_i/total_i)
                sq.append(temp_i/total_i)
            d_table.append(hc)
        out = pd.DataFrame(data = d_table, columns=[&#39;0-0.25&#39;, &#39;0,25-0.5&#39;,&#39;0.5-0.75&#39;,&#39;0.75-1&#39;], index=[&#39;1.8-2.2&#39;, &#39;1.4-1.8&#39;, &#39;1-1.4&#39;, &#39;0.6-1&#39;, &#39;0-0.6&#39;])
        self._plot_heatmap(out)

        # just for proper naming of squars. bad solution
        square = pd.DataFrame(data=sq, columns=[&#39;value&#39;], index=[5,10,15,20,   4,9,14,19,   3,8,13,18,    2,7,12,17,   1,6,11,16])

        return square.sort_index()

    def scatter_density(self, ax=None, ax_x=None, ax_y=None, color:str=&#39;blue&#39;, alpha:float=0.3, volumes:float=None) -&gt; None:
        &#34;&#34;&#34;
        Plot VK scatter with density
        Same as joinplot in seaborn
        but you can use external axes

        Parameters
        ----------
        ax: matplotlib ax
            central ax for scatter
        ax_x: matplotlib ax
            horizontal ax for density
        ax_y: matplotlib ax
            vertical ax for density
        color: str
            color for scatter and density
        alpha: float
            alpha for scatter
        &#34;&#34;&#34;
        if ax is None:
            fig = plt.figure(figsize=(6,6), dpi=100)
            gs = GridSpec(4, 4)

            ax = fig.add_subplot(gs[1:4, 0:3])
            ax_x = fig.add_subplot(gs[0,0:3])
            ax_y = fig.add_subplot(gs[1:4, 3])

        self.table[&#39;intensity&#39;] = self.table[&#39;intensity&#39;] / self.table[&#39;intensity&#39;].median()

        if volumes is None:
            self.table[&#39;volume&#39;] = self.table[&#39;intensity&#39;] / self.table[&#39;intensity&#39;].median()
        else:
            self.table[&#39;volume&#39;] = volumes

        ax.scatter(self.table[&#39;O/C&#39;],self.table[&#39;H/C&#39;], s=self.table[&#39;volume&#39;], alpha=alpha, c=color)
        ax.set_ylim(0,2.2)
        ax.set_xlim(0,1)
        ax.set_xlabel(&#34;O/C&#34;)
        ax.set_ylabel(&#34;H/C&#34;)
        ax.yaxis.set_ticks(np.arange(0, 2.2, 0.4))
        ax.xaxis.set_ticks(np.arange(0, 1.1, 0.2))

        oc = self.table[&#39;O/C&#39;]*self.table[&#39;intensity&#39;]
        hc = self.table[&#39;H/C&#39;]*self.table[&#39;intensity&#39;]
        total_int = self.table[&#39;intensity&#39;].sum()

        x = np.linspace(self.table[&#39;O/C&#39;].min(), self.table[&#39;O/C&#39;].max(), 100)        
        oc = np.array([])
        for i, el in enumerate(x[1:]):
            s = self.table.loc[(self.table[&#39;O/C&#39;] &gt; x[i-1]) &amp; (self.table[&#39;O/C&#39;] &lt;= el), &#39;intensity&#39;].sum()
            coun = len(self.table) * s/total_int
            m = (x[i-1] + x[i])/2
            oc = np.append(oc, [m]*int(coun))
        sns.kdeplot(x = oc, ax=ax_x, color=color, fill=True, alpha=0.1, bw_adjust=2)
        ax_x.set_axis_off()
        ax_x.set_xlim(0,1)
        
        y = np.linspace(self.table[&#39;H/C&#39;].min(), self.table[&#39;H/C&#39;].max(), 100)        
        hc = np.array([])
        for i, el in enumerate(y[1:]):
            s = self.table.loc[(self.table[&#39;H/C&#39;] &gt; y[i-1]) &amp; (self.table[&#39;H/C&#39;] &lt;= el), &#39;intensity&#39;].sum()
            coun = len(self.table) * s/total_int
            m = (y[i-1] + y[i])/2
            hc = np.append(hc, [m]*int(coun))
        sns.kdeplot(x = hc, ax=ax_y, color=color, vertical=True, fill=True, alpha=0.1, bw_adjust=2)
        ax_y.set_axis_off()
        ax_y.set_ylim(0,2.2)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="nhsmasslib.mass.VanKrevelen.draw_density"><code class="name flex">
<span>def <span class="ident">draw_density</span></span>(<span>self, cmap:str='Blues', ax:<functionaxesat0x7f7f08d865e0>=None, shade:bool=True) >None</span>
</code></dt>
<dd>
<div class="desc"><p>Draw Van-Krevelen density</p>
<p>All parameters is optional</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>cmap</code></strong> :&ensp;<code>str</code></dt>
<dd>color map</dd>
<dt><strong><code>ax</code></strong> :&ensp;<code>matplotlib ax</code></dt>
<dd>external ax</dd>
<dt><strong><code>shade</code></strong> :&ensp;<code>bool</code></dt>
<dd>show shade</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_density(
    self, 
    cmap:str =&#34;Blues&#34;, 
    ax: plt.axes = None, 
    shade: bool = True
    ) -&gt; None:
    &#34;&#34;&#34;
    Draw Van-Krevelen density

    All parameters is optional

    Parameters
    ----------
    cmap: str
        color map
    ax: matplotlib ax
        external ax
    shade: bool
        show shade
    &#34;&#34;&#34;
    sns.kdeplot(self.table[&#34;O/C&#34;], self.table[&#34;H/C&#34;], ax=ax, cmap=cmap, shade=shade)</code></pre>
</details>
</dd>
<dt id="nhsmasslib.mass.VanKrevelen.draw_scatter"><code class="name flex">
<span>def <span class="ident">draw_scatter</span></span>(<span>self, ax:<functionaxesat0x7f7f08d865e0>=None, volumes:float=None, color:str='blue', nitrogen:bool=False, sulphur:bool=False, alpha:float=0.3, mark_elem:str=None, **kwargs) >None</span>
</code></dt>
<dd>
<div class="desc"><p>plot Van-Krevelen diagramm</p>
<p>All parameters is optional.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>Matplotlyb axes object</code></dt>
<dd>send here ax if you want plot special graph</dd>
<dt><strong><code>volumes</code></strong> :&ensp;<code>float</code></dt>
<dd>size of dot at diagram.
By default calc by median intensity of spectrum</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>str</code></dt>
<dd>color of VK. Default blue</dd>
<dt><strong><code>nitrogen</code></strong> :&ensp;<code>bool</code></dt>
<dd>mark nitrogen in brutto-formulas as orange</dd>
<dt><strong><code>sulphur</code></strong> :&ensp;<code>bool</code></dt>
<dd>mark sulphur in brutto-formulas as green for CHOS and red for CHONS</dd>
<dt><strong><code>alpha</code></strong> :&ensp;<code>float</code></dt>
<dd>transparency of dot at the scatter from 0 to 1</dd>
<dt><strong><code>mark_elem</code></strong> :&ensp;<code>str</code></dt>
<dd>mark element in brutto-formulas by pink color</dd>
<dt><strong><code>**kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>dict for additional condition to scatter method</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_scatter(
    self, 
    ax:plt.axes = None, 
    volumes:float = None,
    color:str = &#39;blue&#39;,
    nitrogen:bool = False,
    sulphur:bool = False,
    alpha:float = 0.3, 
    mark_elem:str = None, 
    **kwargs) -&gt; None:
    &#34;&#34;&#34;
    plot Van-Krevelen diagramm

    All parameters is optional.

    Parameters
    ----------
    ax: Matplotlyb axes object
        send here ax if you want plot special graph
    volumes: float
        size of dot at diagram.
        By default calc by median intensity of spectrum
    color: str
        color of VK. Default blue
    nitrogen: bool
        mark nitrogen in brutto-formulas as orange
    sulphur: bool
        mark sulphur in brutto-formulas as green for CHOS and red for CHONS
    alpha: float
        transparency of dot at the scatter from 0 to 1
    mark_elem: str
        mark element in brutto-formulas by pink color
    **kwargs: dict
        dict for additional condition to scatter method        
    &#34;&#34;&#34;
    
    if ax is None:
        fig, ax = plt.subplots(figsize=(4, 4), dpi=75)
    else:
        ax=ax
    
    if volumes is None:
        self.table[&#39;volume&#39;] = self.table[&#39;intensity&#39;] / self.table[&#39;intensity&#39;].median()
    else:
        self.table[&#39;volume&#39;] = volumes

    self.table[&#39;color&#39;] = color

    if mark_elem is not None:
        
        self.table.loc[self.table[mark_elem] &gt; 0, &#39;color&#39;] = &#39;purple&#39;

    if nitrogen and &#39;N&#39; in self.table.columns:
        self.table.loc[(self.table[&#39;C&#39;] &gt; 0) &amp; (self.table[&#39;H&#39;] &gt; 0) &amp;(self.table[&#39;O&#39;] &gt; 0) &amp; (self.table[&#39;N&#39;] &gt; 0), &#39;color&#39;] = &#39;orange&#39;

    if sulphur and &#39;S&#39; in self.table.columns:
        self.table.loc[(self.table[&#39;C&#39;] &gt; 0) &amp; (self.table[&#39;H&#39;] &gt; 0) &amp;(self.table[&#39;O&#39;] &gt; 0) &amp; (self.table[&#39;N&#39;] &lt; 1) &amp; (self.table[&#39;S&#39;] &gt; 0), &#39;color&#39;] = &#39;green&#39;
        self.table.loc[(self.table[&#39;C&#39;] &gt; 0) &amp; (self.table[&#39;H&#39;] &gt; 0) &amp;(self.table[&#39;O&#39;] &gt; 0) &amp; (self.table[&#39;N&#39;] &gt; 0) &amp; (self.table[&#39;S&#39;] &gt; 0), &#39;color&#39;] = &#39;red&#39;
    
    if mark_elem is not None:
        ax.scatter(self.table.loc[self.table[mark_elem] &gt; 0, &#39;O/C&#39;], 
                    self.table.loc[self.table[mark_elem] &gt; 0, &#39;H/C&#39;],
                    s=self.table.loc[self.table[mark_elem] &gt; 0, &#39;volume&#39;], 
                    c=&#39;red&#39;, 
                    alpha=alpha, 
                    **kwargs)
    else:
        ax.scatter(self.table[&#34;O/C&#34;], self.table[&#34;H/C&#34;], s=self.table[&#39;volume&#39;], c=self.table[&#39;color&#39;], alpha=alpha, **kwargs)
    ax.set_xlabel(&#34;O/C&#34;)
    ax.set_ylabel(&#34;H/C&#34;)
    ax.yaxis.set_ticks(np.arange(0, 2.2, 0.4))
    ax.xaxis.set_ticks(np.arange(0, 1.1, 0.2))
    ax.set_xlim(0, 1)
    ax.set_ylim(0, 2.2)
    
    num_formules = self.table[&#39;C&#39;].count()
    ax.set_title(f&#39;{num_formules} formulas&#39;, size=10)</code></pre>
</details>
</dd>
<dt id="nhsmasslib.mass.VanKrevelen.scatter_density"><code class="name flex">
<span>def <span class="ident">scatter_density</span></span>(<span>self, ax=None, ax_x=None, ax_y=None, color:str='blue', alpha:float=0.3, volumes:float=None) >None</span>
</code></dt>
<dd>
<div class="desc"><p>Plot VK scatter with density
Same as joinplot in seaborn
but you can use external axes</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>matplotlib ax</code></dt>
<dd>central ax for scatter</dd>
<dt><strong><code>ax_x</code></strong> :&ensp;<code>matplotlib ax</code></dt>
<dd>horizontal ax for density</dd>
<dt><strong><code>ax_y</code></strong> :&ensp;<code>matplotlib ax</code></dt>
<dd>vertical ax for density</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>str</code></dt>
<dd>color for scatter and density</dd>
<dt><strong><code>alpha</code></strong> :&ensp;<code>float</code></dt>
<dd>alpha for scatter</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scatter_density(self, ax=None, ax_x=None, ax_y=None, color:str=&#39;blue&#39;, alpha:float=0.3, volumes:float=None) -&gt; None:
    &#34;&#34;&#34;
    Plot VK scatter with density
    Same as joinplot in seaborn
    but you can use external axes

    Parameters
    ----------
    ax: matplotlib ax
        central ax for scatter
    ax_x: matplotlib ax
        horizontal ax for density
    ax_y: matplotlib ax
        vertical ax for density
    color: str
        color for scatter and density
    alpha: float
        alpha for scatter
    &#34;&#34;&#34;
    if ax is None:
        fig = plt.figure(figsize=(6,6), dpi=100)
        gs = GridSpec(4, 4)

        ax = fig.add_subplot(gs[1:4, 0:3])
        ax_x = fig.add_subplot(gs[0,0:3])
        ax_y = fig.add_subplot(gs[1:4, 3])

    self.table[&#39;intensity&#39;] = self.table[&#39;intensity&#39;] / self.table[&#39;intensity&#39;].median()

    if volumes is None:
        self.table[&#39;volume&#39;] = self.table[&#39;intensity&#39;] / self.table[&#39;intensity&#39;].median()
    else:
        self.table[&#39;volume&#39;] = volumes

    ax.scatter(self.table[&#39;O/C&#39;],self.table[&#39;H/C&#39;], s=self.table[&#39;volume&#39;], alpha=alpha, c=color)
    ax.set_ylim(0,2.2)
    ax.set_xlim(0,1)
    ax.set_xlabel(&#34;O/C&#34;)
    ax.set_ylabel(&#34;H/C&#34;)
    ax.yaxis.set_ticks(np.arange(0, 2.2, 0.4))
    ax.xaxis.set_ticks(np.arange(0, 1.1, 0.2))

    oc = self.table[&#39;O/C&#39;]*self.table[&#39;intensity&#39;]
    hc = self.table[&#39;H/C&#39;]*self.table[&#39;intensity&#39;]
    total_int = self.table[&#39;intensity&#39;].sum()

    x = np.linspace(self.table[&#39;O/C&#39;].min(), self.table[&#39;O/C&#39;].max(), 100)        
    oc = np.array([])
    for i, el in enumerate(x[1:]):
        s = self.table.loc[(self.table[&#39;O/C&#39;] &gt; x[i-1]) &amp; (self.table[&#39;O/C&#39;] &lt;= el), &#39;intensity&#39;].sum()
        coun = len(self.table) * s/total_int
        m = (x[i-1] + x[i])/2
        oc = np.append(oc, [m]*int(coun))
    sns.kdeplot(x = oc, ax=ax_x, color=color, fill=True, alpha=0.1, bw_adjust=2)
    ax_x.set_axis_off()
    ax_x.set_xlim(0,1)
    
    y = np.linspace(self.table[&#39;H/C&#39;].min(), self.table[&#39;H/C&#39;].max(), 100)        
    hc = np.array([])
    for i, el in enumerate(y[1:]):
        s = self.table.loc[(self.table[&#39;H/C&#39;] &gt; y[i-1]) &amp; (self.table[&#39;H/C&#39;] &lt;= el), &#39;intensity&#39;].sum()
        coun = len(self.table) * s/total_int
        m = (y[i-1] + y[i])/2
        hc = np.append(hc, [m]*int(coun))
    sns.kdeplot(x = hc, ax=ax_y, color=color, vertical=True, fill=True, alpha=0.1, bw_adjust=2)
    ax_y.set_axis_off()
    ax_y.set_ylim(0,2.2)</code></pre>
</details>
</dd>
<dt id="nhsmasslib.mass.VanKrevelen.squares"><code class="name flex">
<span>def <span class="ident">squares</span></span>(<span>self, draw:bool=True) >pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate density
in VK divided into 20 squares</p>
<p>Parameters:
draw: bool
Optional, default True. Draw heatmap for squares</p>
<h2 id="return">Return</h2>
<p>Pandas Dataframe with calculated square density</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def squares(self, draw:bool = True) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    Calculate density  in VK divided into 20 squares

    Parameters:
    draw: bool
        Optional, default True. Draw heatmap for squares

    Return
    ------
    Pandas Dataframe with calculated square density
    &#34;&#34;&#34;

    d_table = []
    sq = []
    table = copy.deepcopy(self.table)
    total_i = len(table)
    for y in [ (1.8, 2.2), (1.4, 1.8), (1, 1.4), (0.6, 1), (0, 0.6)]:
        hc = []
        for x in  [(0, 0.25), (0.25, 0.5), (0.5, 0.75), (0.75, 1)]:
            temp = copy.deepcopy(self)
            temp.table = temp.table.loc[(temp.table[&#39;O/C&#39;] &gt;= x[0]) &amp; (temp.table[&#39;O/C&#39;] &lt; x[1]) &amp; (temp.table[&#39;H/C&#39;] &gt;= y[0]) &amp; (temp.table[&#39;H/C&#39;] &lt; y[1])]
            temp_i = len(temp.table)
            hc.append(temp_i/total_i)
            sq.append(temp_i/total_i)
        d_table.append(hc)
    out = pd.DataFrame(data = d_table, columns=[&#39;0-0.25&#39;, &#39;0,25-0.5&#39;,&#39;0.5-0.75&#39;,&#39;0.75-1&#39;], index=[&#39;1.8-2.2&#39;, &#39;1.4-1.8&#39;, &#39;1-1.4&#39;, &#39;0.6-1&#39;, &#39;0-0.6&#39;])
    self._plot_heatmap(out)

    # just for proper naming of squars. bad solution
    square = pd.DataFrame(data=sq, columns=[&#39;value&#39;], index=[5,10,15,20,   4,9,14,19,   3,8,13,18,    2,7,12,17,   1,6,11,16])

    return square.sort_index()</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="nhsmasslib" href="index.html">nhsmasslib</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="nhsmasslib.mass.CanNotCreateVanKrevelen" href="#nhsmasslib.mass.CanNotCreateVanKrevelen">CanNotCreateVanKrevelen</a></code></h4>
</li>
<li>
<h4><code><a title="nhsmasslib.mass.ErrorTable" href="#nhsmasslib.mass.ErrorTable">ErrorTable</a></code></h4>
<ul class="two-column">
<li><code><a title="nhsmasslib.mass.ErrorTable.assign_error" href="#nhsmasslib.mass.ErrorTable.assign_error">assign_error</a></code></li>
<li><code><a title="nhsmasslib.mass.ErrorTable.dif_mass" href="#nhsmasslib.mass.ErrorTable.dif_mass">dif_mass</a></code></li>
<li><code><a title="nhsmasslib.mass.ErrorTable.etalon_error" href="#nhsmasslib.mass.ErrorTable.etalon_error">etalon_error</a></code></li>
<li><code><a title="nhsmasslib.mass.ErrorTable.extrapolate" href="#nhsmasslib.mass.ErrorTable.extrapolate">extrapolate</a></code></li>
<li><code><a title="nhsmasslib.mass.ErrorTable.fit_kernel" href="#nhsmasslib.mass.ErrorTable.fit_kernel">fit_kernel</a></code></li>
<li><code><a title="nhsmasslib.mass.ErrorTable.kernel_density_map" href="#nhsmasslib.mass.ErrorTable.kernel_density_map">kernel_density_map</a></code></li>
<li><code><a title="nhsmasslib.mass.ErrorTable.massdiff_error" href="#nhsmasslib.mass.ErrorTable.massdiff_error">massdiff_error</a></code></li>
<li><code><a title="nhsmasslib.mass.ErrorTable.md_error_map" href="#nhsmasslib.mass.ErrorTable.md_error_map">md_error_map</a></code></li>
<li><code><a title="nhsmasslib.mass.ErrorTable.show_error" href="#nhsmasslib.mass.ErrorTable.show_error">show_error</a></code></li>
<li><code><a title="nhsmasslib.mass.ErrorTable.zeroshift" href="#nhsmasslib.mass.ErrorTable.zeroshift">zeroshift</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="nhsmasslib.mass.MassSpectrum" href="#nhsmasslib.mass.MassSpectrum">MassSpectrum</a></code></h4>
<ul class="">
<li><code><a title="nhsmasslib.mass.MassSpectrum.assign" href="#nhsmasslib.mass.MassSpectrum.assign">assign</a></code></li>
<li><code><a title="nhsmasslib.mass.MassSpectrum.assign_by_tmds" href="#nhsmasslib.mass.MassSpectrum.assign_by_tmds">assign_by_tmds</a></code></li>
<li><code><a title="nhsmasslib.mass.MassSpectrum.calculate_DBEvsO" href="#nhsmasslib.mass.MassSpectrum.calculate_DBEvsO">calculate_DBEvsO</a></code></li>
<li><code><a title="nhsmasslib.mass.MassSpectrum.calculate_ai" href="#nhsmasslib.mass.MassSpectrum.calculate_ai">calculate_ai</a></code></li>
<li><code><a title="nhsmasslib.mass.MassSpectrum.calculate_brutto" href="#nhsmasslib.mass.MassSpectrum.calculate_brutto">calculate_brutto</a></code></li>
<li><code><a title="nhsmasslib.mass.MassSpectrum.calculate_cai" href="#nhsmasslib.mass.MassSpectrum.calculate_cai">calculate_cai</a></code></li>
<li><code><a title="nhsmasslib.mass.MassSpectrum.calculate_cram" href="#nhsmasslib.mass.MassSpectrum.calculate_cram">calculate_cram</a></code></li>
<li><code><a title="nhsmasslib.mass.MassSpectrum.calculate_dbe" href="#nhsmasslib.mass.MassSpectrum.calculate_dbe">calculate_dbe</a></code></li>
<li><code><a title="nhsmasslib.mass.MassSpectrum.calculate_dbe_ai" href="#nhsmasslib.mass.MassSpectrum.calculate_dbe_ai">calculate_dbe_ai</a></code></li>
<li><code><a title="nhsmasslib.mass.MassSpectrum.calculate_error" href="#nhsmasslib.mass.MassSpectrum.calculate_error">calculate_error</a></code></li>
<li><code><a title="nhsmasslib.mass.MassSpectrum.calculate_mass" href="#nhsmasslib.mass.MassSpectrum.calculate_mass">calculate_mass</a></code></li>
<li><code><a title="nhsmasslib.mass.MassSpectrum.calculate_simmilarity" href="#nhsmasslib.mass.MassSpectrum.calculate_simmilarity">calculate_simmilarity</a></code></li>
<li><code><a title="nhsmasslib.mass.MassSpectrum.copy" href="#nhsmasslib.mass.MassSpectrum.copy">copy</a></code></li>
<li><code><a title="nhsmasslib.mass.MassSpectrum.draw" href="#nhsmasslib.mass.MassSpectrum.draw">draw</a></code></li>
<li><code><a title="nhsmasslib.mass.MassSpectrum.drop_unassigned" href="#nhsmasslib.mass.MassSpectrum.drop_unassigned">drop_unassigned</a></code></li>
<li><code><a title="nhsmasslib.mass.MassSpectrum.filter_by_C13" href="#nhsmasslib.mass.MassSpectrum.filter_by_C13">filter_by_C13</a></code></li>
<li><code><a title="nhsmasslib.mass.MassSpectrum.find_elems" href="#nhsmasslib.mass.MassSpectrum.find_elems">find_elems</a></code></li>
<li><code><a title="nhsmasslib.mass.MassSpectrum.get_cram_value" href="#nhsmasslib.mass.MassSpectrum.get_cram_value">get_cram_value</a></code></li>
<li><code><a title="nhsmasslib.mass.MassSpectrum.head" href="#nhsmasslib.mass.MassSpectrum.head">head</a></code></li>
<li><code><a title="nhsmasslib.mass.MassSpectrum.intens_sub" href="#nhsmasslib.mass.MassSpectrum.intens_sub">intens_sub</a></code></li>
<li><code><a title="nhsmasslib.mass.MassSpectrum.load" href="#nhsmasslib.mass.MassSpectrum.load">load</a></code></li>
<li><code><a title="nhsmasslib.mass.MassSpectrum.normalize" href="#nhsmasslib.mass.MassSpectrum.normalize">normalize</a></code></li>
<li><code><a title="nhsmasslib.mass.MassSpectrum.recallibrate" href="#nhsmasslib.mass.MassSpectrum.recallibrate">recallibrate</a></code></li>
<li><code><a title="nhsmasslib.mass.MassSpectrum.save" href="#nhsmasslib.mass.MassSpectrum.save">save</a></code></li>
<li><code><a title="nhsmasslib.mass.MassSpectrum.show_error" href="#nhsmasslib.mass.MassSpectrum.show_error">show_error</a></code></li>
<li><code><a title="nhsmasslib.mass.MassSpectrum.tail" href="#nhsmasslib.mass.MassSpectrum.tail">tail</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="nhsmasslib.mass.MassSpectrumList" href="#nhsmasslib.mass.MassSpectrumList">MassSpectrumList</a></code></h4>
<ul class="">
<li><code><a title="nhsmasslib.mass.MassSpectrumList.calculate_similarity" href="#nhsmasslib.mass.MassSpectrumList.calculate_similarity">calculate_similarity</a></code></li>
<li><code><a title="nhsmasslib.mass.MassSpectrumList.draw_similarity" href="#nhsmasslib.mass.MassSpectrumList.draw_similarity">draw_similarity</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="nhsmasslib.mass.Reaction" href="#nhsmasslib.mass.Reaction">Reaction</a></code></h4>
<ul class="">
<li><code><a title="nhsmasslib.mass.Reaction.draw_modification" href="#nhsmasslib.mass.Reaction.draw_modification">draw_modification</a></code></li>
<li><code><a title="nhsmasslib.mass.Reaction.find_modification" href="#nhsmasslib.mass.Reaction.find_modification">find_modification</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="nhsmasslib.mass.SpectrumIsNotAssigned" href="#nhsmasslib.mass.SpectrumIsNotAssigned">SpectrumIsNotAssigned</a></code></h4>
</li>
<li>
<h4><code><a title="nhsmasslib.mass.Tmds" href="#nhsmasslib.mass.Tmds">Tmds</a></code></h4>
<ul class="two-column">
<li><code><a title="nhsmasslib.mass.Tmds.assign" href="#nhsmasslib.mass.Tmds.assign">assign</a></code></li>
<li><code><a title="nhsmasslib.mass.Tmds.calc" href="#nhsmasslib.mass.Tmds.calc">calc</a></code></li>
<li><code><a title="nhsmasslib.mass.Tmds.calc_by_brutto" href="#nhsmasslib.mass.Tmds.calc_by_brutto">calc_by_brutto</a></code></li>
<li><code><a title="nhsmasslib.mass.Tmds.calculate_mass" href="#nhsmasslib.mass.Tmds.calculate_mass">calculate_mass</a></code></li>
<li><code><a title="nhsmasslib.mass.Tmds.draw" href="#nhsmasslib.mass.Tmds.draw">draw</a></code></li>
<li><code><a title="nhsmasslib.mass.Tmds.find_elems" href="#nhsmasslib.mass.Tmds.find_elems">find_elems</a></code></li>
<li><code><a title="nhsmasslib.mass.Tmds.load" href="#nhsmasslib.mass.Tmds.load">load</a></code></li>
<li><code><a title="nhsmasslib.mass.Tmds.save" href="#nhsmasslib.mass.Tmds.save">save</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="nhsmasslib.mass.VanKrevelen" href="#nhsmasslib.mass.VanKrevelen">VanKrevelen</a></code></h4>
<ul class="">
<li><code><a title="nhsmasslib.mass.VanKrevelen.draw_density" href="#nhsmasslib.mass.VanKrevelen.draw_density">draw_density</a></code></li>
<li><code><a title="nhsmasslib.mass.VanKrevelen.draw_scatter" href="#nhsmasslib.mass.VanKrevelen.draw_scatter">draw_scatter</a></code></li>
<li><code><a title="nhsmasslib.mass.VanKrevelen.scatter_density" href="#nhsmasslib.mass.VanKrevelen.scatter_density">scatter_density</a></code></li>
<li><code><a title="nhsmasslib.mass.VanKrevelen.squares" href="#nhsmasslib.mass.VanKrevelen.squares">squares</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>