<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>nhsmasslib.graph API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>nhsmasslib.graph</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#    Copyright 2022 Volikov Alexander &lt;ab.volikov@gmail.com&gt;
#
#    This file is part of nhsmasslib. 
#    Developed in Natural Humic System laboratory
#    Moscow State University (Head of lab - Perminova I.V.)
#
#    nhsmasslib is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    nhsmasslib is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with nhsmasslib.  If not, see &lt;http://www.gnu.org/licenses/&gt;.

from .mass import MassSpectrum, Tmds
from .brutto import gen_from_brutto

import numpy as np
import pandas as pd
import copy
import networkx as nx
from pyvis.network import Network
from tqdm import tqdm
import matplotlib.cm as cm
from matplotlib.colors import rgb2hex


class Metric(object):
    &#34;&#34;&#34;
    Calculate metric based on graph properties

    Atributes
    ---------
    spec: MassSpectrum object
    Massspectrum for calculate
    &#34;&#34;&#34;
    def __init__(self, spec:&#34;MassSpectrum&#34; = None) -&gt; None: 
        self.spec = spec

    def significance_fdcel(self, nodes:dict, dif:float) -&gt; float:
        &#34;&#34;&#34;
        Calculate length parameters of chain Graph with dif mass into mass-list

        Parameters
        ----------
        nodes: dict of nodes
            mass:intensivity. mass rounded by 6
        dif: diff_mass
            diff-mass inm rounded by 6
        
        Retun
        -----
        tuple (0,1)
        [0]:float - sum of n/total nodes
        where n - length of chain, 
        [1]:float - sum of all intensity includes in node 
        &#34;&#34;&#34;

        G = nx.DiGraph()
        
        mass = np.array(list(nodes.keys()))
        intensity = np.array(list(nodes.values()))

        for item in mass:
            res = np.round(item + dif,6)
            if res in mass:
                G.add_edge(item, res)

        roots = [n for (n, d) in G.in_degree if d == 0]
        leafs = [n for (n, d) in G.out_degree if d == 0]

        total_intens = np.sum(intensity[np.isin(mass, list(G.nodes))])
        branches = []

        for root in roots:
            path = list(nx.algorithms.all_simple_paths(G, root, leafs))
            n = len(path[0])
            s = 0
            for item in path[0]:
                s = s + nodes[item]
            branches.append(n*s/total_intens)

        return np.sum(branches), total_intens

    def get_FDCEL_table(self, length:int = 50) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        Calculate FDCEL (formulae differences chains Expected Length)

        Parameters
        ----------
        spec: MassSpectrm
            income mass spectrum with assigned brutti formulas
        length: int
            length of out fdcel vector

        Return
        ------
        Pandas Dataframe with columns &#39;calculated_mass&#39;, &#39;significance&#39;, &#39;difsum_intens&#39;
        &#34;&#34;&#34;

        spec = copy.deepcopy(self.spec).drop_unassigned().calculate_mass()
        diff = Tmds().calc_by_brutto(spec).assign(max_num=length).calculate_mass()
        mass = spec.table[&#39;calculated_mass&#39;].values
        intensivity = spec.table[&#39;intensity&#39;].values
        
        nodes = dict(zip(mass, intensivity))
        diff.table[&#39;significance&#39;] = 0
        diff.table[&#39;difsum_intens&#39;] = 0
        
        tim = len(diff.table)
        for i, row in tqdm(diff.table.iterrows(), total=tim):
            dif = row[&#39;calculated_mass&#39;]
            gr, nd = self.significance_fdcel(nodes, dif)
            diff.table.loc[i, &#39;significance&#39;] = gr
            diff.table.loc[i, &#39;difsum_intens&#39;] = nd

        return diff.table.loc[:,[&#39;calculated_mass&#39;, &#39;significance&#39;, &#39;difsum_intens&#39;]]

    def calc_fdcel(self, spec1: &#34;MassSpectrum&#34;, spec2: &#34;MassSpectrum&#34;) -&gt; float:
        &#34;&#34;&#34;
        Calculate FDCEL

        Parameters
        ----------
        spec1: MassSpectrum object
            first spec
        spec2: MassSpectrum object
            second spec

        Return
        ------
        float: FDCEL value
        &#34;&#34;&#34;

        fdecel_table1 = Metric(spec1).get_FDCEL_table()
        fdecel_table2 = Metric(spec2).get_FDCEL_table()

        res = fdecel_table1.merge(fdecel_table2, on=&#39;calculated_mass&#39;)

        total_intens = spec1.drop_unassigned().table[&#39;intensity&#39;].sum() + spec2.drop_unassigned().table[&#39;intensity&#39;].sum()
        res[&#39;w&#39;] = (res[&#39;difsum_intens_x&#39;] + res[&#39;difsum_intens_y&#39;])/total_intens
        res[&#39;fdcel&#39;] = res[&#39;w&#39;] * np.fabs(res[&#39;significance_x&#39;] - res[&#39;significance_y&#39;])
        fdcel = res[&#39;fdcel&#39;].sum()/len(res)

        return fdcel

    def graph_features(self, mass:np.array, dif:float) -&gt; float:
        &#34;&#34;&#34;
        Calculate chain characteristic for diff mass

        Parameters
        ----------
        mass:
            mass:intensivity. mass rounded by 6
        dif: diff_mass
            diff-mass inm rounded by 6
        
        Return
        ------
        tuple of characteristics
        &#39;nodes&#39;, &#39;chains&#39;, &#39;max_chain&#39;, &#39;median chain&#39;
        &#34;&#34;&#34;

        G = nx.DiGraph()
        
        for item in mass:
            res = np.round(item + dif,6)
            if res in mass:
                G.add_edge(item, res)
        
        roots = [n for (n, d) in G.in_degree if d == 0]
        leafs = [n for (n, d) in G.out_degree if d == 0]

        branches = []

        for root in roots:
            path = list(nx.algorithms.all_simple_paths(G, root, leafs))
            n = len(path[0])
            if n &gt; 2:
                branches.append(n)

        return len(list(G.nodes)), len(branches), np.max(branches), np.median(branches)

    def get_graph_table(self, length:int = 50) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        Calculate chains characteristic in graph for mass diff

        Parameters
        ----------
        spec: MassSpectrm
            income mass spectrum with assigned brutti formulas
        length: int
            length of out fdcel vector

        Return
        ------
        Pandas Table with characteristics
        Add to TMDS table &#39;nodes&#39;, &#39;chains&#39;, &#39;max_chain&#39;, &#39;median chain&#39;
        &#34;&#34;&#34;

        spec = copy.deepcopy(self.spec).drop_unassigned().calculate_mass()
        diff = Tmds().calc_by_brutto(spec).assign(max_num=length).calculate_mass()
        mass = spec.table[&#39;calculated_mass&#39;].values
        
        tim = len(diff.table)
        res = []
        for i, row in tqdm(diff.table.iterrows(), total=tim):
            dif = row[&#39;calculated_mass&#39;]
            res.append(self.graph_features(mass, dif))

        feat = [&#39;nodes&#39;, &#39;chains&#39;, &#39;max_chain&#39;, &#39;median chain&#39;]
        diff.table = diff.table.join(pd.DataFrame(data = res, columns=feat))

        return diff.table

class Vis(object):
    &#34;&#34;&#34;
    Generate visulization

    Atributes
    ---------
    G: Networkx Graph
    &#34;&#34;&#34;

    def __init__(self, G:nx.Graph=None) -&gt; None:
        self.G = G

    def generate(self, 
                spec:&#34;MassSpectrum&#34;, 
                dif_table:pd.DataFrame = None,
                brutto_name = True
                ) -&gt; nx.DiGraph:
        &#34;&#34;&#34;
        Generate direct grpah from massspectrum and difference table

        Parameters
        ----------
        spec: MassSpectrum object
            mass spec with assigned brutto
        dif_table: pd.DataFrame
            table contatin columns &#39;calculated_mass&#39; and optional &#39;name&#39;, &#39;color&#39;.
            Optional. if None - generate default dif table.
        brutto_name: bool
            Optional. Default True. Replace mass for brutto in graph
        &#34;&#34;&#34;
        spec = copy.deepcopy(spec)
        spec = spec.drop_unassigned().calculate_mass()
        mass = spec.table[&#39;calculated_mass&#39;].values

        if dif_table is None:
            dif_table = self.gen_diftable()

        if brutto_name:
            spec = spec.calculate_brutto()
            brutto = spec.table[&#39;brutto&#39;].to_list()
            massl = spec.table[&#39;calculated_mass&#39;].to_list()
            nods = dict(zip(massl, brutto))
        
        G = nx.Graph()

        for i, dif_row in dif_table.iterrows():
            dif = dif_row[&#39;calculated_mass&#39;]

            if &#39;names&#39; in dif_row:
                dif_name = dif_row[&#39;names&#39;]
            else:
                dif_name = str(dif)
            if &#39;color&#39; in dif_row:
                dif_color = dif_row[&#39;color&#39;]
            else:
                dif_color = &#39;#07438c&#39;

            for item in mass:
                res = np.round(item + dif,6)
                if res in mass:
                    if brutto_name:
                        G.add_node(nods[item])
                        G.add_node(nods[res])
                        G.add_edge(nods[item], nods[res], weight=dif_name, color=dif_color)
                    else:
                        G.add_node(str(item))
                        G.add_node(str(res))
                        G.add_edge(str(item), str(res), weight=dif_name, color=dif_color)
        return Vis(G)

    def to_html(self, filename:str, size:str =&#39;800px&#39;) -&gt; None :
        &#34;&#34;&#34;
        Generate html with graph

        Parameters
        ----------
        filename: str
            file to save html
        size: str
            optional, default 800px. Size of graph        
        &#34;&#34;&#34;

        net = Network(size, size)
        net.from_nx(self.G)
        net.show_buttons(filter_=[&#39;physics&#39;])
        net.show(f&#39;{filename}&#39;)

    def gen_diftable(self, el = None, count = None, colors=True) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        Generate dif table for plotting graph

        Parameters
        ----------
        col: list of str
            Optional. list with elements.
            Default = [&#39;C&#39;,&#39;H&#39;,&#39;O&#39;]
        count: list with list
            Optional. Count of elements.
            Default
            [[1,2,0],
            [1,0,1],
            [0,2,0],
            [1,2,1],
            [1,0,2],
            [0,2,1]]
        colors: bool
            if colors generate colors for difmasses

        Return
        ------
        pd.DataFrame with most usual diffmass        
        &#34;&#34;&#34;
        default = False

        if el is None:
            el = [&#39;C&#39;,&#39;H&#39;,&#39;O&#39;]
        if count is None:
            default = True
            count = [[1,2,0],
                    [1,0,1],
                    [0,2,0],
                    [1,2,1],
                    [1,0,2],
                    [0,2,1]]

        dif_table = pd.DataFrame(data=count, columns=el)
        dif_table = gen_from_brutto(dif_table)
        
        col = []
        for row in count:
            c = &#39;&#39;
            for i, e in enumerate(el):
                if row[i] == 1:
                    c = c + f&#39;{e}&#39;
                elif row[i] &gt; 0:
                    c = c + f&#39;{e}{int(row[i])}&#39;
            col.append(c)
        dif_table[&#39;names&#39;] = col

        if colors:
            col = []
            cmap = cm.get_cmap(&#39;hsv&#39;, len(count)+1)   
            for i in range(cmap.N):
                rgba = cmap(i)
                col.append(rgb2hex(rgba))
            dif_table[&#39;color&#39;] = col[1:]

        return dif_table


if __name__ == &#39;__main__&#39;:
    pass</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="nhsmasslib.graph.Metric"><code class="flex name class">
<span>class <span class="ident">Metric</span></span>
<span>(</span><span>spec: MassSpectrum = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate metric based on graph properties</p>
<h2 id="atributes">Atributes</h2>
<p>spec: MassSpectrum object
Massspectrum for calculate</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Metric(object):
    &#34;&#34;&#34;
    Calculate metric based on graph properties

    Atributes
    ---------
    spec: MassSpectrum object
    Massspectrum for calculate
    &#34;&#34;&#34;
    def __init__(self, spec:&#34;MassSpectrum&#34; = None) -&gt; None: 
        self.spec = spec

    def significance_fdcel(self, nodes:dict, dif:float) -&gt; float:
        &#34;&#34;&#34;
        Calculate length parameters of chain Graph with dif mass into mass-list

        Parameters
        ----------
        nodes: dict of nodes
            mass:intensivity. mass rounded by 6
        dif: diff_mass
            diff-mass inm rounded by 6
        
        Retun
        -----
        tuple (0,1)
        [0]:float - sum of n/total nodes
        where n - length of chain, 
        [1]:float - sum of all intensity includes in node 
        &#34;&#34;&#34;

        G = nx.DiGraph()
        
        mass = np.array(list(nodes.keys()))
        intensity = np.array(list(nodes.values()))

        for item in mass:
            res = np.round(item + dif,6)
            if res in mass:
                G.add_edge(item, res)

        roots = [n for (n, d) in G.in_degree if d == 0]
        leafs = [n for (n, d) in G.out_degree if d == 0]

        total_intens = np.sum(intensity[np.isin(mass, list(G.nodes))])
        branches = []

        for root in roots:
            path = list(nx.algorithms.all_simple_paths(G, root, leafs))
            n = len(path[0])
            s = 0
            for item in path[0]:
                s = s + nodes[item]
            branches.append(n*s/total_intens)

        return np.sum(branches), total_intens

    def get_FDCEL_table(self, length:int = 50) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        Calculate FDCEL (formulae differences chains Expected Length)

        Parameters
        ----------
        spec: MassSpectrm
            income mass spectrum with assigned brutti formulas
        length: int
            length of out fdcel vector

        Return
        ------
        Pandas Dataframe with columns &#39;calculated_mass&#39;, &#39;significance&#39;, &#39;difsum_intens&#39;
        &#34;&#34;&#34;

        spec = copy.deepcopy(self.spec).drop_unassigned().calculate_mass()
        diff = Tmds().calc_by_brutto(spec).assign(max_num=length).calculate_mass()
        mass = spec.table[&#39;calculated_mass&#39;].values
        intensivity = spec.table[&#39;intensity&#39;].values
        
        nodes = dict(zip(mass, intensivity))
        diff.table[&#39;significance&#39;] = 0
        diff.table[&#39;difsum_intens&#39;] = 0
        
        tim = len(diff.table)
        for i, row in tqdm(diff.table.iterrows(), total=tim):
            dif = row[&#39;calculated_mass&#39;]
            gr, nd = self.significance_fdcel(nodes, dif)
            diff.table.loc[i, &#39;significance&#39;] = gr
            diff.table.loc[i, &#39;difsum_intens&#39;] = nd

        return diff.table.loc[:,[&#39;calculated_mass&#39;, &#39;significance&#39;, &#39;difsum_intens&#39;]]

    def calc_fdcel(self, spec1: &#34;MassSpectrum&#34;, spec2: &#34;MassSpectrum&#34;) -&gt; float:
        &#34;&#34;&#34;
        Calculate FDCEL

        Parameters
        ----------
        spec1: MassSpectrum object
            first spec
        spec2: MassSpectrum object
            second spec

        Return
        ------
        float: FDCEL value
        &#34;&#34;&#34;

        fdecel_table1 = Metric(spec1).get_FDCEL_table()
        fdecel_table2 = Metric(spec2).get_FDCEL_table()

        res = fdecel_table1.merge(fdecel_table2, on=&#39;calculated_mass&#39;)

        total_intens = spec1.drop_unassigned().table[&#39;intensity&#39;].sum() + spec2.drop_unassigned().table[&#39;intensity&#39;].sum()
        res[&#39;w&#39;] = (res[&#39;difsum_intens_x&#39;] + res[&#39;difsum_intens_y&#39;])/total_intens
        res[&#39;fdcel&#39;] = res[&#39;w&#39;] * np.fabs(res[&#39;significance_x&#39;] - res[&#39;significance_y&#39;])
        fdcel = res[&#39;fdcel&#39;].sum()/len(res)

        return fdcel

    def graph_features(self, mass:np.array, dif:float) -&gt; float:
        &#34;&#34;&#34;
        Calculate chain characteristic for diff mass

        Parameters
        ----------
        mass:
            mass:intensivity. mass rounded by 6
        dif: diff_mass
            diff-mass inm rounded by 6
        
        Return
        ------
        tuple of characteristics
        &#39;nodes&#39;, &#39;chains&#39;, &#39;max_chain&#39;, &#39;median chain&#39;
        &#34;&#34;&#34;

        G = nx.DiGraph()
        
        for item in mass:
            res = np.round(item + dif,6)
            if res in mass:
                G.add_edge(item, res)
        
        roots = [n for (n, d) in G.in_degree if d == 0]
        leafs = [n for (n, d) in G.out_degree if d == 0]

        branches = []

        for root in roots:
            path = list(nx.algorithms.all_simple_paths(G, root, leafs))
            n = len(path[0])
            if n &gt; 2:
                branches.append(n)

        return len(list(G.nodes)), len(branches), np.max(branches), np.median(branches)

    def get_graph_table(self, length:int = 50) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        Calculate chains characteristic in graph for mass diff

        Parameters
        ----------
        spec: MassSpectrm
            income mass spectrum with assigned brutti formulas
        length: int
            length of out fdcel vector

        Return
        ------
        Pandas Table with characteristics
        Add to TMDS table &#39;nodes&#39;, &#39;chains&#39;, &#39;max_chain&#39;, &#39;median chain&#39;
        &#34;&#34;&#34;

        spec = copy.deepcopy(self.spec).drop_unassigned().calculate_mass()
        diff = Tmds().calc_by_brutto(spec).assign(max_num=length).calculate_mass()
        mass = spec.table[&#39;calculated_mass&#39;].values
        
        tim = len(diff.table)
        res = []
        for i, row in tqdm(diff.table.iterrows(), total=tim):
            dif = row[&#39;calculated_mass&#39;]
            res.append(self.graph_features(mass, dif))

        feat = [&#39;nodes&#39;, &#39;chains&#39;, &#39;max_chain&#39;, &#39;median chain&#39;]
        diff.table = diff.table.join(pd.DataFrame(data = res, columns=feat))

        return diff.table</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="nhsmasslib.graph.Metric.calc_fdcel"><code class="name flex">
<span>def <span class="ident">calc_fdcel</span></span>(<span>self, spec1: MassSpectrum, spec2: MassSpectrum) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate FDCEL</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>spec1</code></strong> :&ensp;<code>MassSpectrum object</code></dt>
<dd>first spec</dd>
<dt><strong><code>spec2</code></strong> :&ensp;<code>MassSpectrum object</code></dt>
<dd>second spec</dd>
</dl>
<h2 id="return">Return</h2>
<p>float: FDCEL value</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_fdcel(self, spec1: &#34;MassSpectrum&#34;, spec2: &#34;MassSpectrum&#34;) -&gt; float:
    &#34;&#34;&#34;
    Calculate FDCEL

    Parameters
    ----------
    spec1: MassSpectrum object
        first spec
    spec2: MassSpectrum object
        second spec

    Return
    ------
    float: FDCEL value
    &#34;&#34;&#34;

    fdecel_table1 = Metric(spec1).get_FDCEL_table()
    fdecel_table2 = Metric(spec2).get_FDCEL_table()

    res = fdecel_table1.merge(fdecel_table2, on=&#39;calculated_mass&#39;)

    total_intens = spec1.drop_unassigned().table[&#39;intensity&#39;].sum() + spec2.drop_unassigned().table[&#39;intensity&#39;].sum()
    res[&#39;w&#39;] = (res[&#39;difsum_intens_x&#39;] + res[&#39;difsum_intens_y&#39;])/total_intens
    res[&#39;fdcel&#39;] = res[&#39;w&#39;] * np.fabs(res[&#39;significance_x&#39;] - res[&#39;significance_y&#39;])
    fdcel = res[&#39;fdcel&#39;].sum()/len(res)

    return fdcel</code></pre>
</details>
</dd>
<dt id="nhsmasslib.graph.Metric.get_FDCEL_table"><code class="name flex">
<span>def <span class="ident">get_FDCEL_table</span></span>(<span>self, length: int = 50) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate FDCEL (formulae differences chains Expected Length)</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>spec</code></strong> :&ensp;<code>MassSpectrm</code></dt>
<dd>income mass spectrum with assigned brutti formulas</dd>
<dt><strong><code>length</code></strong> :&ensp;<code>int</code></dt>
<dd>length of out fdcel vector</dd>
</dl>
<h2 id="return">Return</h2>
<p>Pandas Dataframe with columns 'calculated_mass', 'significance', 'difsum_intens'</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_FDCEL_table(self, length:int = 50) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    Calculate FDCEL (formulae differences chains Expected Length)

    Parameters
    ----------
    spec: MassSpectrm
        income mass spectrum with assigned brutti formulas
    length: int
        length of out fdcel vector

    Return
    ------
    Pandas Dataframe with columns &#39;calculated_mass&#39;, &#39;significance&#39;, &#39;difsum_intens&#39;
    &#34;&#34;&#34;

    spec = copy.deepcopy(self.spec).drop_unassigned().calculate_mass()
    diff = Tmds().calc_by_brutto(spec).assign(max_num=length).calculate_mass()
    mass = spec.table[&#39;calculated_mass&#39;].values
    intensivity = spec.table[&#39;intensity&#39;].values
    
    nodes = dict(zip(mass, intensivity))
    diff.table[&#39;significance&#39;] = 0
    diff.table[&#39;difsum_intens&#39;] = 0
    
    tim = len(diff.table)
    for i, row in tqdm(diff.table.iterrows(), total=tim):
        dif = row[&#39;calculated_mass&#39;]
        gr, nd = self.significance_fdcel(nodes, dif)
        diff.table.loc[i, &#39;significance&#39;] = gr
        diff.table.loc[i, &#39;difsum_intens&#39;] = nd

    return diff.table.loc[:,[&#39;calculated_mass&#39;, &#39;significance&#39;, &#39;difsum_intens&#39;]]</code></pre>
</details>
</dd>
<dt id="nhsmasslib.graph.Metric.get_graph_table"><code class="name flex">
<span>def <span class="ident">get_graph_table</span></span>(<span>self, length: int = 50) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate chains characteristic in graph for mass diff</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>spec</code></strong> :&ensp;<code>MassSpectrm</code></dt>
<dd>income mass spectrum with assigned brutti formulas</dd>
<dt><strong><code>length</code></strong> :&ensp;<code>int</code></dt>
<dd>length of out fdcel vector</dd>
</dl>
<h2 id="return">Return</h2>
<p>Pandas Table with characteristics
Add to TMDS table 'nodes', 'chains', 'max_chain', 'median chain'</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_graph_table(self, length:int = 50) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    Calculate chains characteristic in graph for mass diff

    Parameters
    ----------
    spec: MassSpectrm
        income mass spectrum with assigned brutti formulas
    length: int
        length of out fdcel vector

    Return
    ------
    Pandas Table with characteristics
    Add to TMDS table &#39;nodes&#39;, &#39;chains&#39;, &#39;max_chain&#39;, &#39;median chain&#39;
    &#34;&#34;&#34;

    spec = copy.deepcopy(self.spec).drop_unassigned().calculate_mass()
    diff = Tmds().calc_by_brutto(spec).assign(max_num=length).calculate_mass()
    mass = spec.table[&#39;calculated_mass&#39;].values
    
    tim = len(diff.table)
    res = []
    for i, row in tqdm(diff.table.iterrows(), total=tim):
        dif = row[&#39;calculated_mass&#39;]
        res.append(self.graph_features(mass, dif))

    feat = [&#39;nodes&#39;, &#39;chains&#39;, &#39;max_chain&#39;, &#39;median chain&#39;]
    diff.table = diff.table.join(pd.DataFrame(data = res, columns=feat))

    return diff.table</code></pre>
</details>
</dd>
<dt id="nhsmasslib.graph.Metric.graph_features"><code class="name flex">
<span>def <span class="ident">graph_features</span></span>(<span>self, mass: <built-in function array>, dif: float) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate chain characteristic for diff mass</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt>mass:</dt>
<dt>mass:intensivity. mass rounded by 6</dt>
<dt><strong><code>dif</code></strong> :&ensp;<code>diff_mass</code></dt>
<dd>diff-mass inm rounded by 6</dd>
</dl>
<h2 id="return">Return</h2>
<p>tuple of characteristics
'nodes', 'chains', 'max_chain', 'median chain'</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def graph_features(self, mass:np.array, dif:float) -&gt; float:
    &#34;&#34;&#34;
    Calculate chain characteristic for diff mass

    Parameters
    ----------
    mass:
        mass:intensivity. mass rounded by 6
    dif: diff_mass
        diff-mass inm rounded by 6
    
    Return
    ------
    tuple of characteristics
    &#39;nodes&#39;, &#39;chains&#39;, &#39;max_chain&#39;, &#39;median chain&#39;
    &#34;&#34;&#34;

    G = nx.DiGraph()
    
    for item in mass:
        res = np.round(item + dif,6)
        if res in mass:
            G.add_edge(item, res)
    
    roots = [n for (n, d) in G.in_degree if d == 0]
    leafs = [n for (n, d) in G.out_degree if d == 0]

    branches = []

    for root in roots:
        path = list(nx.algorithms.all_simple_paths(G, root, leafs))
        n = len(path[0])
        if n &gt; 2:
            branches.append(n)

    return len(list(G.nodes)), len(branches), np.max(branches), np.median(branches)</code></pre>
</details>
</dd>
<dt id="nhsmasslib.graph.Metric.significance_fdcel"><code class="name flex">
<span>def <span class="ident">significance_fdcel</span></span>(<span>self, nodes: dict, dif: float) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate length parameters of chain Graph with dif mass into mass-list</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>nodes</code></strong> :&ensp;<code>dict</code> of <code>nodes</code></dt>
<dd>mass:intensivity. mass rounded by 6</dd>
<dt><strong><code>dif</code></strong> :&ensp;<code>diff_mass</code></dt>
<dd>diff-mass inm rounded by 6</dd>
</dl>
<h2 id="retun">Retun</h2>
<p>tuple (0,1)
[0]:float - sum of n/total nodes
where n - length of chain,
[1]:float - sum of all intensity includes in node</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def significance_fdcel(self, nodes:dict, dif:float) -&gt; float:
    &#34;&#34;&#34;
    Calculate length parameters of chain Graph with dif mass into mass-list

    Parameters
    ----------
    nodes: dict of nodes
        mass:intensivity. mass rounded by 6
    dif: diff_mass
        diff-mass inm rounded by 6
    
    Retun
    -----
    tuple (0,1)
    [0]:float - sum of n/total nodes
    where n - length of chain, 
    [1]:float - sum of all intensity includes in node 
    &#34;&#34;&#34;

    G = nx.DiGraph()
    
    mass = np.array(list(nodes.keys()))
    intensity = np.array(list(nodes.values()))

    for item in mass:
        res = np.round(item + dif,6)
        if res in mass:
            G.add_edge(item, res)

    roots = [n for (n, d) in G.in_degree if d == 0]
    leafs = [n for (n, d) in G.out_degree if d == 0]

    total_intens = np.sum(intensity[np.isin(mass, list(G.nodes))])
    branches = []

    for root in roots:
        path = list(nx.algorithms.all_simple_paths(G, root, leafs))
        n = len(path[0])
        s = 0
        for item in path[0]:
            s = s + nodes[item]
        branches.append(n*s/total_intens)

    return np.sum(branches), total_intens</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="nhsmasslib.graph.Vis"><code class="flex name class">
<span>class <span class="ident">Vis</span></span>
<span>(</span><span>G: networkx.classes.graph.Graph = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate visulization</p>
<h2 id="atributes">Atributes</h2>
<p>G: Networkx Graph</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Vis(object):
    &#34;&#34;&#34;
    Generate visulization

    Atributes
    ---------
    G: Networkx Graph
    &#34;&#34;&#34;

    def __init__(self, G:nx.Graph=None) -&gt; None:
        self.G = G

    def generate(self, 
                spec:&#34;MassSpectrum&#34;, 
                dif_table:pd.DataFrame = None,
                brutto_name = True
                ) -&gt; nx.DiGraph:
        &#34;&#34;&#34;
        Generate direct grpah from massspectrum and difference table

        Parameters
        ----------
        spec: MassSpectrum object
            mass spec with assigned brutto
        dif_table: pd.DataFrame
            table contatin columns &#39;calculated_mass&#39; and optional &#39;name&#39;, &#39;color&#39;.
            Optional. if None - generate default dif table.
        brutto_name: bool
            Optional. Default True. Replace mass for brutto in graph
        &#34;&#34;&#34;
        spec = copy.deepcopy(spec)
        spec = spec.drop_unassigned().calculate_mass()
        mass = spec.table[&#39;calculated_mass&#39;].values

        if dif_table is None:
            dif_table = self.gen_diftable()

        if brutto_name:
            spec = spec.calculate_brutto()
            brutto = spec.table[&#39;brutto&#39;].to_list()
            massl = spec.table[&#39;calculated_mass&#39;].to_list()
            nods = dict(zip(massl, brutto))
        
        G = nx.Graph()

        for i, dif_row in dif_table.iterrows():
            dif = dif_row[&#39;calculated_mass&#39;]

            if &#39;names&#39; in dif_row:
                dif_name = dif_row[&#39;names&#39;]
            else:
                dif_name = str(dif)
            if &#39;color&#39; in dif_row:
                dif_color = dif_row[&#39;color&#39;]
            else:
                dif_color = &#39;#07438c&#39;

            for item in mass:
                res = np.round(item + dif,6)
                if res in mass:
                    if brutto_name:
                        G.add_node(nods[item])
                        G.add_node(nods[res])
                        G.add_edge(nods[item], nods[res], weight=dif_name, color=dif_color)
                    else:
                        G.add_node(str(item))
                        G.add_node(str(res))
                        G.add_edge(str(item), str(res), weight=dif_name, color=dif_color)
        return Vis(G)

    def to_html(self, filename:str, size:str =&#39;800px&#39;) -&gt; None :
        &#34;&#34;&#34;
        Generate html with graph

        Parameters
        ----------
        filename: str
            file to save html
        size: str
            optional, default 800px. Size of graph        
        &#34;&#34;&#34;

        net = Network(size, size)
        net.from_nx(self.G)
        net.show_buttons(filter_=[&#39;physics&#39;])
        net.show(f&#39;{filename}&#39;)

    def gen_diftable(self, el = None, count = None, colors=True) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        Generate dif table for plotting graph

        Parameters
        ----------
        col: list of str
            Optional. list with elements.
            Default = [&#39;C&#39;,&#39;H&#39;,&#39;O&#39;]
        count: list with list
            Optional. Count of elements.
            Default
            [[1,2,0],
            [1,0,1],
            [0,2,0],
            [1,2,1],
            [1,0,2],
            [0,2,1]]
        colors: bool
            if colors generate colors for difmasses

        Return
        ------
        pd.DataFrame with most usual diffmass        
        &#34;&#34;&#34;
        default = False

        if el is None:
            el = [&#39;C&#39;,&#39;H&#39;,&#39;O&#39;]
        if count is None:
            default = True
            count = [[1,2,0],
                    [1,0,1],
                    [0,2,0],
                    [1,2,1],
                    [1,0,2],
                    [0,2,1]]

        dif_table = pd.DataFrame(data=count, columns=el)
        dif_table = gen_from_brutto(dif_table)
        
        col = []
        for row in count:
            c = &#39;&#39;
            for i, e in enumerate(el):
                if row[i] == 1:
                    c = c + f&#39;{e}&#39;
                elif row[i] &gt; 0:
                    c = c + f&#39;{e}{int(row[i])}&#39;
            col.append(c)
        dif_table[&#39;names&#39;] = col

        if colors:
            col = []
            cmap = cm.get_cmap(&#39;hsv&#39;, len(count)+1)   
            for i in range(cmap.N):
                rgba = cmap(i)
                col.append(rgb2hex(rgba))
            dif_table[&#39;color&#39;] = col[1:]

        return dif_table</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="nhsmasslib.graph.Vis.gen_diftable"><code class="name flex">
<span>def <span class="ident">gen_diftable</span></span>(<span>self, el=None, count=None, colors=True) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Generate dif table for plotting graph</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>col</code></strong> :&ensp;<code>list</code> of <code>str</code></dt>
<dd>Optional. list with elements.
Default = ['C','H','O']</dd>
<dt><strong><code>count</code></strong> :&ensp;<code>list with list</code></dt>
<dd>Optional. Count of elements.
Default
[[1,2,0],
[1,0,1],
[0,2,0],
[1,2,1],
[1,0,2],
[0,2,1]]</dd>
<dt><strong><code>colors</code></strong> :&ensp;<code>bool</code></dt>
<dd>if colors generate colors for difmasses</dd>
</dl>
<h2 id="return">Return</h2>
<p>pd.DataFrame with most usual diffmass</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gen_diftable(self, el = None, count = None, colors=True) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    Generate dif table for plotting graph

    Parameters
    ----------
    col: list of str
        Optional. list with elements.
        Default = [&#39;C&#39;,&#39;H&#39;,&#39;O&#39;]
    count: list with list
        Optional. Count of elements.
        Default
        [[1,2,0],
        [1,0,1],
        [0,2,0],
        [1,2,1],
        [1,0,2],
        [0,2,1]]
    colors: bool
        if colors generate colors for difmasses

    Return
    ------
    pd.DataFrame with most usual diffmass        
    &#34;&#34;&#34;
    default = False

    if el is None:
        el = [&#39;C&#39;,&#39;H&#39;,&#39;O&#39;]
    if count is None:
        default = True
        count = [[1,2,0],
                [1,0,1],
                [0,2,0],
                [1,2,1],
                [1,0,2],
                [0,2,1]]

    dif_table = pd.DataFrame(data=count, columns=el)
    dif_table = gen_from_brutto(dif_table)
    
    col = []
    for row in count:
        c = &#39;&#39;
        for i, e in enumerate(el):
            if row[i] == 1:
                c = c + f&#39;{e}&#39;
            elif row[i] &gt; 0:
                c = c + f&#39;{e}{int(row[i])}&#39;
        col.append(c)
    dif_table[&#39;names&#39;] = col

    if colors:
        col = []
        cmap = cm.get_cmap(&#39;hsv&#39;, len(count)+1)   
        for i in range(cmap.N):
            rgba = cmap(i)
            col.append(rgb2hex(rgba))
        dif_table[&#39;color&#39;] = col[1:]

    return dif_table</code></pre>
</details>
</dd>
<dt id="nhsmasslib.graph.Vis.generate"><code class="name flex">
<span>def <span class="ident">generate</span></span>(<span>self, spec: MassSpectrum, dif_table: pandas.core.frame.DataFrame = None, brutto_name=True) ‑> networkx.classes.digraph.DiGraph</span>
</code></dt>
<dd>
<div class="desc"><p>Generate direct grpah from massspectrum and difference table</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>spec</code></strong> :&ensp;<code>MassSpectrum object</code></dt>
<dd>mass spec with assigned brutto</dd>
<dt><strong><code>dif_table</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>table contatin columns 'calculated_mass' and optional 'name', 'color'.
Optional. if None - generate default dif table.</dd>
<dt><strong><code>brutto_name</code></strong> :&ensp;<code>bool</code></dt>
<dd>Optional. Default True. Replace mass for brutto in graph</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate(self, 
            spec:&#34;MassSpectrum&#34;, 
            dif_table:pd.DataFrame = None,
            brutto_name = True
            ) -&gt; nx.DiGraph:
    &#34;&#34;&#34;
    Generate direct grpah from massspectrum and difference table

    Parameters
    ----------
    spec: MassSpectrum object
        mass spec with assigned brutto
    dif_table: pd.DataFrame
        table contatin columns &#39;calculated_mass&#39; and optional &#39;name&#39;, &#39;color&#39;.
        Optional. if None - generate default dif table.
    brutto_name: bool
        Optional. Default True. Replace mass for brutto in graph
    &#34;&#34;&#34;
    spec = copy.deepcopy(spec)
    spec = spec.drop_unassigned().calculate_mass()
    mass = spec.table[&#39;calculated_mass&#39;].values

    if dif_table is None:
        dif_table = self.gen_diftable()

    if brutto_name:
        spec = spec.calculate_brutto()
        brutto = spec.table[&#39;brutto&#39;].to_list()
        massl = spec.table[&#39;calculated_mass&#39;].to_list()
        nods = dict(zip(massl, brutto))
    
    G = nx.Graph()

    for i, dif_row in dif_table.iterrows():
        dif = dif_row[&#39;calculated_mass&#39;]

        if &#39;names&#39; in dif_row:
            dif_name = dif_row[&#39;names&#39;]
        else:
            dif_name = str(dif)
        if &#39;color&#39; in dif_row:
            dif_color = dif_row[&#39;color&#39;]
        else:
            dif_color = &#39;#07438c&#39;

        for item in mass:
            res = np.round(item + dif,6)
            if res in mass:
                if brutto_name:
                    G.add_node(nods[item])
                    G.add_node(nods[res])
                    G.add_edge(nods[item], nods[res], weight=dif_name, color=dif_color)
                else:
                    G.add_node(str(item))
                    G.add_node(str(res))
                    G.add_edge(str(item), str(res), weight=dif_name, color=dif_color)
    return Vis(G)</code></pre>
</details>
</dd>
<dt id="nhsmasslib.graph.Vis.to_html"><code class="name flex">
<span>def <span class="ident">to_html</span></span>(<span>self, filename: str, size: str = '800px') ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Generate html with graph</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code></dt>
<dd>file to save html</dd>
<dt><strong><code>size</code></strong> :&ensp;<code>str</code></dt>
<dd>optional, default 800px. Size of graph</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_html(self, filename:str, size:str =&#39;800px&#39;) -&gt; None :
    &#34;&#34;&#34;
    Generate html with graph

    Parameters
    ----------
    filename: str
        file to save html
    size: str
        optional, default 800px. Size of graph        
    &#34;&#34;&#34;

    net = Network(size, size)
    net.from_nx(self.G)
    net.show_buttons(filter_=[&#39;physics&#39;])
    net.show(f&#39;{filename}&#39;)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="nhsmasslib" href="index.html">nhsmasslib</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="nhsmasslib.graph.Metric" href="#nhsmasslib.graph.Metric">Metric</a></code></h4>
<ul class="">
<li><code><a title="nhsmasslib.graph.Metric.calc_fdcel" href="#nhsmasslib.graph.Metric.calc_fdcel">calc_fdcel</a></code></li>
<li><code><a title="nhsmasslib.graph.Metric.get_FDCEL_table" href="#nhsmasslib.graph.Metric.get_FDCEL_table">get_FDCEL_table</a></code></li>
<li><code><a title="nhsmasslib.graph.Metric.get_graph_table" href="#nhsmasslib.graph.Metric.get_graph_table">get_graph_table</a></code></li>
<li><code><a title="nhsmasslib.graph.Metric.graph_features" href="#nhsmasslib.graph.Metric.graph_features">graph_features</a></code></li>
<li><code><a title="nhsmasslib.graph.Metric.significance_fdcel" href="#nhsmasslib.graph.Metric.significance_fdcel">significance_fdcel</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="nhsmasslib.graph.Vis" href="#nhsmasslib.graph.Vis">Vis</a></code></h4>
<ul class="">
<li><code><a title="nhsmasslib.graph.Vis.gen_diftable" href="#nhsmasslib.graph.Vis.gen_diftable">gen_diftable</a></code></li>
<li><code><a title="nhsmasslib.graph.Vis.generate" href="#nhsmasslib.graph.Vis.generate">generate</a></code></li>
<li><code><a title="nhsmasslib.graph.Vis.to_html" href="#nhsmasslib.graph.Vis.to_html">to_html</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>